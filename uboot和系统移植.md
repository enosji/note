# 1、uboot学习前传

## 1.1、为什么有uboot

### 1.1.1、计算机系统的主要部件

（1）计算机系统就是有CPU来做核心进行运行的系统。典型的计算机系统有：PC机（台式机+笔记本）、嵌入式设备（手机、平板电脑、游戏机）、单片机（家用电器像电饭锅、空调）

（2）计算机系统的组成部件非常多，不同的计算机系统组成部件也不同。但是所有的计算机系统运行时需要的主要核心部件都是3个东西：CPU + 外部存储器（Flash/硬盘） + 内部存储器（DDR SDRAM/SDRAM/SRAM）

### 1.1.2、PC机的启动过程

（1）典型的PC机的部署：BIOS程序部署在PC机主板上（随主板出厂时已经预制了），操作系统部署在硬盘上，内存在掉电时无作用，CPU在掉电时不工作。

（2）启动过程：PC上电后先执行BIOS程序（实际上PC的BIOS就是NorFlash），BIOS程序负责初始化DDR内存，负责初始化硬盘，然后从硬盘上将OS镜像读取到DDR中，然后跳转到DDR中去执行OS直到启动（OS启动后BIOS就无用了）

### 1.1.3、典型嵌入式linux系统启动过程

（1）嵌入式系统的部署和启动都是参考PC机的。只是设备上有一些差别

（2）典型嵌入式系统的部署：uboot程序部署在Flash（能作为启动设备的Flash）上、OS部署在FLash（嵌入式系统中用Flash代替了硬盘）上、内存在掉电时无作用，CPU在掉电时不工作。

（3）启动过程：嵌入式系统上电后先执行uboot、然后uboot负责初始化DDR，初始化Flash，然后将OS从Flash中读取到DDR中，然后启动OS（OS启动后uboot就无用了）

总结：嵌入式系统和PC机的启动过程几乎没有两样，只是BIOS成了uboot，硬盘成了Flash。

### 1.1.4、android系统启动过程

（1）android系统的启动和linux系统（前面讲的典型的嵌入式系统启动）几乎一样。几乎一样意思就是前面完全一样，只是在内核启动后加载根文件系统后不同了。

（2）可以认为启动分为2个阶段：第一个阶段是uboot到OS启动；第二个阶段是OS启动后到rootfs加载到命令行执行；现在我们主要研究第一个阶段，android的启动和linux的差别在第二阶段。

### 1.1.5、总结：uboot到底是干嘛的

（1）uboot主要作用是用来启动操作系统内核。

（2）uboot还要负责部署整个计算机系统。

（3）uboot中还有操作Flash等板子上硬盘的驱动。

（4）uboot还得提供一个命令行界面供人来操作。

***

## 1.2、为什么是uboot

### 1.2.1、uboot从哪里来的？

（1）uboot是SourceForge上的开源项目

（2）uboot项目的作者：一个德国人最早发起的项目

（3）uboot就是由一个人发起，然后由整个网络上所有感兴趣的人共同维护发展而来的一个bootloader。

### 1.2.2、uboot的发展历程

（1）自己使用的小开源项目。

（2）被更多人认可使用

（3）被SoC厂商默认支持。

总结：uboot经过多年发展，已经成为事实上的业内bootloader标准。现在大部分的嵌入式设备都会默认使用uboot来做为bootloader。

### 1.2.3、uboot的版本号问题

（1）早期的uboot的版本号类似于这样：uboot1.3.4。后来版本号便成了类似于uboot-2010.06。

（2）uboot的核心部分几乎没怎么变化，越新的版本支持的开发板越多而已，对于一个老版本的芯片来说，新旧版本的uboot并没有差异。

### 1.2.4、uboot的可移植性的正确理解

（1）uboot就是universal bootloader（通用的启动代码），通用的意思就是在各种地方都可以用。所以说uboot具有可移植性。

（2）uboot具有可移植性并不是说uboot在哪个开发板都可以随便用，而是说uboot具有在源代码级别的移植能力，可以针对多个开发板进行移植，移植后就可以在这个开发板上使用了。

### 1.2.5、总结：时势造英雄，任何牛逼的东西都是时代的产物

uboot的出现是一种必然，如果没有uboot也会有另一个bootloader来代替。

****

## 1.3、uboot必须解决哪些问题

### 1.3.1、自身可开机直接启动

（1）一般的SoC都支持多种启动方式，譬如SD卡启动、NorFlash启动、NandFlash启动等·····uboot要能够开机启动，必须根据具体的SoC的启动设计来设计uboot

（2）uboot必须进行和硬件相对应的代码级别的更改和移植，才能够保证可以从相应的启动介质启动。uboot中第一阶段的start.S文件中具体处理了这一块。

### 1.3.2、能够引导操作系统内核启动并给内核传参

（1）uboot的终极目标就是启动内核。

（2）linux内核在设计的时候，设计为可以被传参。也就是说我们可以在uboot中事先给linux内核准备一些启动参数放在内存中特定位置然后传给内核，内核启动后会到这个特定位置去取uboot传给他的参数，然后在内核中解析这些参数，这些参数将被用来指导linux内核的启动过程。

### 1.3.3、能提供系统部署功能

（1）uboot必须能够被人借助而完成整个系统（包括uboot、kernel、rootfs等的镜像）在Flash上的烧录下载工作。

（2）裸机教程中刷机（ARM裸机第三部分）就是利用uboot中的fastboot功能将各种镜像烧录到iNand中，然后从iNand启动。

### 1.3.4、能进行soc级和板级硬件管理

（1）uboot中实现了一部分硬件的控制能力（uboot中初始化了一部分硬件），因为uboot为了完成一些任务必须让这些硬件工作。譬如uboot要实现刷机必须能驱动iNand，譬如uboot要在刷机时LCD上显示进度条就必须能驱动LCD，譬如uboot能够通过串口提供操作界面就必须驱动串口。譬如uboot要实现网络功能就必须驱动网卡芯片。

（2）SoC级（譬如串口）就是SoC内部外设，板级就是SoC外面开发板上面的硬件（譬如网卡、iNand）

### 1.3.5、uboot的“生命周期”

（1）uboot的生命周期就是指：uboot什么时候开始运行，什么时候结束运行。

（2）uboot本质上是一个裸机程序（不是操作系统），一旦uboot开始SoC就会单纯运行uboot（意思就是uboot运行的时候别的程序是不可能同时运行的），一旦uboot结束运行则无法再回到uboot（所以uboot启动了内核后uboot自己本身就死了，要想再次看到uboot界面只能重启系统。重启并不是复活了刚才的uboot，重启只是uboot的另一生）

（3）uboot的入口和出口。uboot的入口就是开机自动启动，uboot的唯一出口就是启动内核。uboot还可以执行很多别的任务（譬如烧录系统），但是其他任务执行完后都可以回到uboot的命令行继续执行uboot命令，而启动内核命令一旦执行就回不来了。

总结：一切都是为了启动内核

****

## 1.4、uboot的工作方式

### 1.4.1、从裸机程序镜像uboot.bin说起

（1）uboot的本质就是一个裸机程序，和我们裸机全集中写的那些裸机程序xx.bin并没有本质区别。如果非说要有区别，那就是：我们写的大部分小于16KB，而uboot大于16KB（一般uboot在180k-400k之间）

（2）uboot本身是一个开源项目，由若干个.c文件和.h文件组成，配置编译之后会生成一个uboot.bin，这就是uboot这个裸机程序的镜像文件。然后这个镜像文件被合理的烧录到启动介质中拿给SoC去启动。也就是说uboot在没有运行时表现为uboot.bin，一般躺在启动介质中。

（3）uboot运行时会被加载到内存中然后一条指令一条指令的拿给CPU去运行。

### 1.4.2、uboot的命令式shell界面

（1）普通的裸机程序运行起来就直接执行了，执行时效果和代码有关。

（2）有些程序需要和人进行交互，于是乎程序中就实现了一个shell（shell就是提供人机交互的一个界面，回想ARM裸机全集第十六部分），uboot就实现了一个shell。

注意：shell并不是操作系统，和操作系统一点关系都没有。linux中打开一个终端后就得到了一个shell，可以输入命令回车执行。uboot中的shell工作方式和linux中的终端shell非常像（其实几乎是一样的，只是命令集不一样。譬如linux中可以ls，uboot中ls就不识别）

### 1.4.3、掌握uboot使用的2个关键点：命令和环境变量

（1）uboot启动后大部分时间和工作都是在shell下完成的（譬如uboot要部署系统要在shell下输命令、要设置环境变量也得在命令行地下，要启动内核也要在命令行底下敲命令）

（2）命令就是uboot的shell中可以识别的各种命令。uboot中有几十个命令，其中有一些常用另一些不常用（我们还可以自己给uboot添加命令），后面会用几节课时间来依次学习uboot中常用命令。

（3）uboot的环境变量和操作系统的环境变量工作原理和方式几乎完全相同。uboot在设计时借助了操作系统的设计理念（命令行工作方式借鉴了linux终端命令行，环境变量借鉴了操作系统的环境变量，uboot的驱动管理几乎完全照抄了linux的驱动框架）。

（4）环境变量可以被认为是系统的全局变量，环境变量名都是系统内置的（认识就认识，不认识就不认识，这部分是系统自带的默认的环境变量，譬如PATH；但是也有一部分环境变量是自己添加的，自己添加的系统就不认识但是我们自己认识）。系统或者我们自己的程序在运行时可以通过读取环境变量来指导程序的运行。这样设计的好处就是灵活，譬如我们要让一个程序更改运行方法，不用去重新修改程序代码再重新编译运行，而只要修改相应的环境变量就可以了。

（5）环境变量就是运行时的配置属性。

### 1.4.4、思考：结合ARM裸机部分进行理解和印证

（1）及时复习ARM裸机中和现在讲到的相关的知识点，在复习中巩固ARM裸机中学到的。这过程中如果原来学习记了笔记非常容易容易好，如果没有记笔记那就难办了。

（2）及时对照原来ARM裸机中讲到的相关部分，可以帮助理解当前讲到的知识点。

（3）结合ARM裸机中和现在讲的，对比分析思考，会得到更多。

****

## 1.5、uboot的常用命令

### 1.5.1、类似linux终端的行缓冲命令行

（1）行缓冲的意思就是：当我们向终端命令行输入命令的时候，这些命令没有立即被系统识别，而是被缓冲到一个缓存区（也就是系统认为我们还没有输入完），当我们按下回车键（换行）后系统就认为我们输入完了，然后将缓冲区中所有刚才输入的作为命令拿去分析处理。

（2）linux终端设计有3种缓冲机制：无缓冲、行缓冲、全缓冲

### 1.5.2、有些命令有简化的别名

（1）譬如printenv命令可以简化为print，譬如setenv可以简化为set

### 1.5.3、有些命令会带参数（注意格式是固定的）

（1）uboot的每个命令都有事先规定好的各种格式。有些命令就是不带参数的，譬如printenv/print命令；有些命令带可选的参数（可以带也可以不带，当然带不带参数的执行结果是不同的）；有些命令带必须的参数（譬如setenv/set命令）

### 1.5.4、命令中的特殊符号（譬如单引号）

（1）uboot的有些命令带的参数非常长，为了告诉uboot这个非常长而且中间有好多个空格的东西是给他的一整个参数，所以用单引号将这个很长且中间有空格隔开的参数引起来。

（2）别的符号也许也有，而且有特定的意义。当碰到uboot的命令行有特殊符号时要注意不是弄错了，而是可能有特别的含义。

### 1.5.5、有些命令是一个命令族（譬如movi）

（1）命令族意思就是好多个命令开头都是用同一个命令关键字的，但是后面的参数不一样，这些命令的功能和作用也不同。这就叫一个命令族。

（2）同一个命令族中所有的命令都有极大的关联，譬如movi开头的命令族都和moviNand（EMMC、iNand）操作有关。

### 1.5.6、第一个命令：printenv/print

（1）print命令不用带参数，作用是打印出系统中所有的环境变量。

（2）环境变量就好像程序的全局变量一样。程序中任何地方都可以根据需要去调用或者更改环境变量（一般都是调用），环境变量和全局变量不同之处在于：全局变量的生命周期是在程序的一次运行当中，开始运行时诞生程序结束时死亡，下次运行程序时从头开始；但是环境变量被存储在Flash的另一块专门区域（Flash上有一个环境变量分区），一旦我们在程序中保存了该环境变量，那么下次开机时该环境变量的值将维持上一次更改保存后的值。

### 1.5.7、设置（添加/更改）环境变量：setenv/set

（1）用法：set name value

### 1.5.8、保存环境变量的更改：saveenv/save

（1）saveenv/save命令不带参数，直接执行，作用是将内存中的环境变量的值同步保存到Flash中环境变量的分区。注意：环境变量的保存是整体的覆盖保存，也就是说内存中所有的环境变量都会整体的将Flash中环境变量分区中原来的内容整体覆盖。

### 1.5.9、网络测试指令：ping

（1）命令用法： ping ip地址

注意：ping是测试开发板和主机之间的网络链接，注意以下步骤：

​	1)首先要插上网线。
​	2)先试图ping通主机windows。注意Windows中有线网卡的地址设置（设置本地连接）。设		置主机windows的本地连接IPv4地址为192.168.1.10
​	3)第三步确认开发板中uboot里几个网络相关的环境变量的值对不对。最重要的是ipaddr（这		个环境变量表示当前开发板的IP地址），这个地址必须和主机windows的IP地址在同一个		网段。

网段的概念：一个IP地址分为2部分，一部分是网段地址，另一部分是网段内的主机地址（由子网掩码来区分哪一部分是网段地址，哪一部分是IP地址）。在子网掩码是255.255.255.0的情况下，192.168.1.10这个IP地址的前三部分（192.168.1.）属于网段地址，第4部分（10）属于主机地址。

#### 1.5.9.1、开发板运行linux下和主机Windows的ping通

（1）先将开发板刷机成linux+QT镜像（刷机见裸机教程第三部分），然后启动进入linux命令行终端下。

（2）在linux下使用ifconfig命令将开发板中linux系统的IP地址设置为和主机windows同一网段（为了上课方便，以后就固定：主机windows地址192.168.1.10，开发板uboot或linux的地址为192.168.1.20，虚拟机ubuntu地址为192.168.1.141）

（3）此时开发板端ping windows通的。

（4）windows中ping开发板也是通的。

说明：首先开发板和主机的网络部分硬件都是好的，网络连接也是好的，主机windows中的网络软件设置是好的。

#### 1.5.9.2、开发板运行linux下和虚拟机ubuntu的ping通

（1）在linux基础课中讲过：虚拟机的网卡设置可以选择好几种方式，常用的就是NAT和桥接（bridged）。

（2）虚拟机要和开发板进行网络通信，只能通过桥接方式连接。

（3）虚拟机要想被开发板ping通，设置步骤如下：
	第一步：虚拟机设置成桥接方式。
	第二步：虚拟机的菜单中有个“虚拟网络编辑器”，这里面要设置为桥接到有线网卡。（默认是自动的，自动的一般会影响ping通。因为电脑现在一般都有2个网卡：一个有线的一个无线的。如果选了自动，那么虚拟机会自动桥接到无线网卡上，但是我们却是通过有线网卡来连接开发板的，自然ping不通）
	第三步：在虚拟机ubuntu中设置IP地址为192.168.1.141（可以通过/etc/network/interfaces文件来设置静态的然后重启；也可以直接命令行ifconfig去设置）

（4）此时开发板ping虚拟机ubuntu应该就通了。

（5）此时虚拟机ubuntu中ping开发板也是通的。

#### 1.5.9.3、开发板运行uboot下和主机Windows的ping通

（1）刚才开发板运行linux时和主机windows、虚拟机ubuntu都ping通了，说明硬件和连接和主机设置没错。

（2）此时开发板重启进入uboot，设置好ipaddr、gatewayip，然后去ping windows发现还是不通。 怀疑uboot本身网络驱动有问题。

（3）然后同样情况下尝试去ping通虚拟机ubuntu，理论分析应该也不通，但是实际发现是通的。

#### 1.5.9.4、开发板运行uboot下和虚拟机ubuntu的ping通

（1）uboot和虚拟机ubuntu互相ping通（前提是虚拟机ubuntu设置为桥接，且桥接到有线网卡，且ip地址设置正确的情况下）

结论：开发板中运行的uboot有点小bug，ping windows就不通，ping虚拟机ubuntu就通。

### 1.5.10、tftp下载指令：tftp

（1）uboot本身主要目标是启动内核，为了完成启动内核必须要能够部署内核，uboot为了部署内核就需要将内核镜像从主机中下载过来然后烧录到本地flash中。uboot如何从主机（windows或者虚拟机ubuntu）下载镜像到开发板上？有很多种方式，主流方式是：fastboot和tftp。
fastboot的方式是通过USB线进行数据传输。
tftp的方式是通过有线网络的。典型的方式就是通过网络，fastboot是近些年才新发展的。

（2）tftp方式下载时实际上uboot扮演的是tftp客户端程序角色，主机windows或虚拟机ubuntu中必须有一个tftp服务器，然后将要下载的镜像文件放在服务器的下载目录中，然后开发板中使用uboot的tftp命令去下载即可。

（3）有些人习惯在windows中搭建tftp服务器，一般是用一些软件来搭建（譬如tftpd32，使用起来比较简单）；有些人习惯在linux下搭建tftp服务器，可以参考网盘中的虚拟机下载目录下的一个教程《嵌入式开发环境搭建-基于14.04.pdf》，这里面有ubuntu中搭建tftp服务器的教程，也可以自己上网搜索教程尝试。（如果你直接就用我的虚拟机，那就已经搭建好了，不用再搭建了；如果是自己新装的那就参考文档搭建；如果你的版本和我的不一样那搭建过程可能不一样）

（4）我的虚拟机搭建的时候设置的tftp下载目录是/tftpboot，将要被下载的镜像复制到这个目录下。

（5）检查开发板uboot的环境变量，注意serverip必须设置为虚拟机ubuntu的ip地址。（serverip这个环境变量的意义就是主机tftp服务器的ip地址）

（6）然后在开发板的uboot下先ping通虚拟机ubuntu，然后再尝试下载：tftp 0x30000000 zImage-qt（意思是将服务器上名为zImage-qt的文件下载到开发板内存的0x30000000地址处。）

（7）镜像下载到开发板的DDR中后，uboot就可以用movi指令进行镜像的烧写了。
注意：
		1）如果你是用的windows下的tftp服务器，那uboot的serverip就要设置为和windwos下tftp服务器的ip地址一样（windows下的tftp服务器软件设置的时候就有个步骤是让你设置服务器的ip地址，这个ip地址和主机windows必须在一个网段）。

​		2）整个过程中间环节比较多，实际做的时候可能最后会下载不下来。这时候可能的问题非常多，不要问我，自己对照视频课程讲的思路来排查。（譬如：第一步应该先保证uboot和ubuntu可以ping通；第二步再保证ubuntu中tftp服务器搭建没错；第三步再实现tftp下载。如果第一步有问题参考网络设置部分，第二步有问题（tftp本地测试下载ok，但是开发板就是不行），有一个解决方案就是使用windows下的tftp服务器）

### 1.5.11、nfs启动内核命令：nfs

作用：让开发板通过网络的方式远程从服务器端挂载根文件系统

ubuntu安装nfs服务器的步骤：
1. 检查nfs服务是否安装（可以忽略）
	sudo dpkg -s nfs-kernel-server
	
2. 安装nfs服务(前提：可以上网)
	sudo apt-get install nfs-kernel-server
	
3. 配置nfs服务
	1》在家目录下创建nfs文件夹
		mkdir nfs 
	2》设置文件夹的权限最大
		chmod 777 nfs 
	3》拷贝根文件系统到nfs目录下
		根文件系统一会发给你们(rootfs.tar.xz)
		cp /mnt/hgfs/share/rootfs.tar.xz ~/nfs
	4》对根文件系统的压缩包进行解压缩
		cd ~/nfs
		tar -vxf rootfs.tar.xz
	5》配置nfs服务的环境变量
		sudo vi /etc/exports
		在文件的最后一行添加以下内容：
		/home/stu/nfs/rootfs/  *(rw,sync,no_subtree_check,no_root_squash) 
		注：小括号中的每个参数之间不要出现空格
		解析：
		/home/linux/nfs/rootfs/：自己的根文件系统的路径
						需要修改为自己的路径
	
		* ：所有的用户，
				注：*和后边的左括号"("之间不可以出现空格.
		rw:可读可写的权限
		sync：同步文件
		no_subtree_check:不对子目录检查文件的权限
		no_root_squash:如果客户端为root用户，那么他对整个文件具有root的权限
	 * 注意：这段话前边不要加#,#号是这个文件中的注释符号
	
4. 重启nfs服务(任选其一)
	1. sudo service nfs-kernel-server start  启动nfs服务
	2. sudo service nfs-kernel-server restart  重启nfs服务
	
5. 本地测试nfs服务是否安装成功
	1》回到家目录下
		cd ~
	2》sudo mount -t nfs 本机IP地址:/home/stu/nfs/rootfs/ /mnt
	
	nfs:使用nfs服务，将本机IP地址:/home/stu/nfs/rootfs/
	文件挂载到/mnt目录下
	
	3》检查/mnt目录下是否挂载成功
		cd /mnt 
		ls 
	
	4》卸载挂载的文件
		sudo umount /mnt
		注意：不可以在/mnt目录下执行卸载的命令

### 1.5.12、SD卡/iNand操作指令movi

（1）开发板如果用SD卡/EMMC/iNand等作为Flash，则在uboot中操作flash的指令为movi（或mmc）

（2）movi指令是一个命令集，有很多子命令，具体用法可以help movi查看。

（3）movi的指令都是movi read和movi write一组的，movi read用来读取iNand到DDR上，movi write用来将DDR中的内容写入iNand中。理解这些指令时一定要注意涉及到的2个硬件：iNand和DDR内存。

（4）movi read  {u-boot | kernel} {addr}   这个命令使用了一种通用型的描述方法来描述：movi 和 read外面没有任何标记说明每一次使用这个指令都是必选的；一对大括号{}括起来的部分必选1个，大括号中的竖线表是多选一。中括号[]表示可选参数（可以有也可以没有）

（5）指令有多种用法，譬如 movi read u-boot 0x30000000，意思就是把iNand中的u-boot分区读出到DDR的0x30000000起始的位置处。（uboot代码中将iNand分成了很多个分区，每个分区有地址范围和分区名，uboot程序操作中可以使用直接地址来操作iNand分区，也可以使用分区名来操作分区。）；注意这里的0x30000000也可以直接写作30000000，意思是一样的（uboot的命令行中所有数字都被默认当作十六进制处理，不管你加不加0x都一样）。

### 1.5.13、NandFlash操作指令nand

（1）理解方法和操作方法完全类似于movi指令

### 1.5.14、内存操作指令：mm、mw、md

（1）DDR中是没有分区的（只听说过对硬盘、Flash进行分区，没听说过对内存进行分区····），但是内存使用时要注意，千万不能越界踩到别人了。因为uboot是一个裸机程序，不像操作系统会由系统整体管理所有内存，系统负责分配和管理，系统会保证内存不会随便越界。然后裸机程序中uboot并不管理所有内存，内存是散的随便用的，所以如果程序员（使用uboot的人）自己不注意就可能出现自己把自己的数据给覆盖了。（所以你思考下我们为什么把uboot放在23E00000地址处）

（2）md就是memory display，用来显示内存中的内容。

（3）mw就是memory write，将内容写到内存中

（4）mm就是memory modify，修改内存中的某一块，说白了还是写内存（如果需要批量的逐个单元的修改内存，用mm最合适）

### 1.5.15、启动内核指令：bootm、go

（1）uboot的终极目标就是启动内核，启动内核在uboot中表现为一个指令，uboot命令行中调用这个指令就会启动内核（不管成功与否，所以这个指令是一条死路）。

（2）差别：bootm启动内核同时给内核传参，而go命令启动内核不传参。bootm其实才是正宗的启动内核的命令，一般情况下都用这个；go命令本来不是专为启动内核设计的，go命令内部其实就是一个函数指针指向一个内存地址然后直接调用那个函数，go命令的实质就是PC直接跳转到一个内存地址去运行而已。go命令可以用来在uboot中执行任何的裸机程序（有一种调试裸机程序的方法就是事先启动uboot，然后在uboot中去下载裸机程序，用go命令去执行裸机程序）

****

## 1.6、uboot的常用环境变量

### 1.6.1、如何理解环境变量

（1）环境变量就相当于是uboot的全局变量

### 1.6.2、环境变量如何参与程序运行

（1）环境变量有2份，一份在Flash中，另一份在DDR中。uboot开机时一次性从Flash中读取全部环境变量到DDR中作为环境变量的初始化值，然后使用过程中都是用DDR中这一份，用户可以用saveenv指令将DDR中的环境变量重新写入Flash中去更新Flash中环境变量。下次开机时又会从Flash中再读一次。

（2）环境变量在uboot中是用字符串表示的，也就是说uboot是按照字符匹配的方式来区分各个环境变量的。因此用的时候一定要注意不要打错字了。

### 1.6.3、自动运行倒数时间：bootdelay

（1）通过setenv命令去设置倒计时时间

### 1.6.4、网络设置：ipaddr serverip 

（1）ipaddr是开发板的本地IP地址
（2）serverip是开发板通过tftp指令去tftp服务器下载东西时，tftp服务器的IP地址。
（3）gatewayip是开发板的本地网关地址
（4）netmask是子网掩码
（5）ethaddr是开发板的本地网卡的MAC地址。

### 1.6.5、自动运行命令设置：bootcmd

（1）uboot启动后会开机自动倒数bootdelay秒，如果没有人按下回车打断启动，则uboot会自动执行启动命令来启动内核。

（2）uboot开机自动启动时实际就是在内部执行了bootcmd这个环境变量的值所对应的命令集。

（3）bootcmd=movi read kernel 30008000; bootm 30008000   意思是：将iNand的kernel分区读取到DDR内存的0x30008000地址处，然后使用bootm启动命令从内存0x30008000处去启动内核。

（4）set bootcmd printenv，然后saveenv；然后重启则会看到启动倒数后自动执行printenv命令打印出环境变量。这个小实验说明开机自动执行了bootcmd。

（5）set bootcmd 'movi read kernel 30008000; bootm 30008000'

### 1.6.6、uboot给kernel传参：bootargs

（1）linux内核启动时可以接收uboot给他传递的启动参数，这些启动参数是uboot和内核约定好的形式、内容，linux内核在这些启动参数的指导下完成启动过程。这样的设计是为了灵活，为了内核在不重新编译的情况下可以用不同的方式启动。

（2）我们要做的事情就是：在uboot的环境变量中设置bootargs，然后bootm命令启动内核时会自动将bootargs传给内核。

（3）bootargs=console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3			

意义解释：
console=ttySAC2,115200	控制台使用串口2，波特率115200.
root=/dev/mmcblk0p2	rw	根文件系统在SD卡端口0设备（iNand）第2分区，根文件系统是可读可写的
init=/linuxrc			linux的进程1（init进程）的路径
rootfstype=ext3			根文件系统的类型是ext3

（4）内核传参非常重要。在内核移植的时候，新手经常因为忘记给内核传参，或者给内核传递的参数不对，造成内核启动不起来。

### 1.6.7、新建、更改、删除一个环境变量的方法

（1）新建一个环境变量，使用set var value

（2）更改一个环境变量，使用set var value

（3）删除一个环境变量，使用set var

### 1.6.8、注意：环境变量更改后的保存

（1）修改完成环境变量后一定要保存，否则下次开机更改就又没了。

****

## 1.7、uboot中对Flash和DDR的管理

### 1.7.1、uboot阶段Flash的分区

（1）所谓分区，就是说对Flash进行分块管理。

（2）PC机等产品中，因为大家都是在操作系统下使用硬盘的，整个硬盘由操作系统统一管理，操作系统会使用文件系统帮我们管理硬盘空间。（管理保证了文件之间不会互相堆叠），于是乎使用者不用自己太过在意分区问题。

（3）在uboot中是没有操作系统的，因此我们对Flash（相当于硬盘）的管理必须事先使用分区界定（实际上在uboot中和kernel中都有个分区表，分区表就是我们在做系统移植时对Flash的整体管理分配方法）。有了这个界定后，我们在部署系统时按照分区界定方法来部署，uboot和kernel的软件中也是按照这个分区界定来工作，就不会错。

（4）分区方法不是一定的，不是固定的，是可以变动的。但是在一个移植中必须事先设计好定死，一般在设计系统移植时就会定好，定的标准是：
uboot:uboot必须从Flash起始地址开始存放（也许是扇区0，也许是扇区1，也许是其他，取决于SoC的启动设计），uboot分区的大小必须保证uboot肯定能放下，一般设计为512KB或者1MB（因为一般uboot肯定不足512KB，给再大其实也可以工作，但是浪费）；
环境变量：环境变量分区一般紧贴着uboot来存放，大小为32KB或者更多一点。
kernel：kernel可以紧贴环境变量存放，大小一般为3MB或5MB或其他。
rootfs：······
剩下的就是自由分区，一般kernel启动后将自由分区挂载到rootfs下使用

总结：一般规律如下：
（1）各分区彼此相连，前面一个分区的结尾就是后一个分区的开头。
（2）整个flash充分利用，从开头到结尾。
（3）uboot必须在Flash开头，其他分区相对位置是可变的。
（4）各分区的大小由系统移植工程师自己来定，一般定为合适大小（不能太小，太小了容易溢出；不能太大，太大了浪费空间）
（5）分区在系统移植前确定好，在uboot中和kernel中使用同一个分区表。将来在系统部署时和系统代码中的分区方法也必须一样。

### 1.7.2、uboot阶段DDR的分区

（1）DDR的分区和Flash的分区不同，主要是因为Flash是掉电存在的，而DDR是掉电消失，因此可以说DDR是每次系统运行时才开始部署使用的。

（2）内存的分区主要是在linux内核启动起来之前，linux内核启动后内核的内存管理模块会接管整个内存空间，那时候就不用我们来管了。

（3）注意内存分区关键就在于内存中哪一块用来干什么必须分配好，以避免各个不同功能使用了同一块内存造成的互相踩踏。譬如说我们tftp 0x23E00000 zImage去下载zImage到内存的0x23E00000处就会出错，因为这个内存处实际是uboot的镜像所在。这样下载会导致下载的zImage把内存中的uboot给冲掉。

****

# 2、shell和Makefile

## 2.1、shell介绍

### 2.1.1、shell是操作系统的终端命令行

（1）shell可以理解为软件系统提供给用户操作的命令行界面，可以说它是人机交互的一种方式。

（2）我们可以使用shell和操作系统、uboot等软件系统进行交互。具体来说就是我们通过shell给软件系统输入命令然后回车执行，执行完成后又会回到shell命令行可以再次输入命令执行。

（3）上述的操作方式一般情况下工作很好，但是有缺陷。譬如我们要在linux下创建一个文件a.c，可以touch a.c 但是如果我现在是用在linux下创建100个文件，分别为a1.c  a2.c.....a100.c 如果这时候还是手工去命令行下执行命令创建也可以，但是很累。最好的做法就是把创建过程写成一个shell脚本程序，然后去执行这个shell脚本程序，执行这个程序的效果和手工在命令行输入那些命令效果一样的。（回忆在arm裸机中安装交叉编译工具链时，创建arm-linux-xxx的符号链接时）

### 2.1.2、shell是一类编程语言

（1）编写shell脚本时使用的语言就是shell语言，又叫脚本语言。

（2）shell脚本其实是一类语言而不是一个语言。

### 2.1.3、常用shell语言：sh、bash、csh、ksh、perl、python等

（1）在linux下常用的脚本语言其实就是bash、sh；

（2）perl、python这样的高级shell脚本语言，常用在网络管理配置等领域，系统运维人员一般要学习这些。

（3）脚本语言一般在嵌入式中应用，主要是用来做配置。（一个复杂的嵌入式程序都是可配置的，配置过程就是用脚本语言来实现的）自然不会使用过于复杂的脚本语言特性，因此只需要针对性的学习即可。

（4）linux下最常用的脚本就是bash，我们学习也是以bash为主。

### 2.1.4、shell脚本的运行机制：解释运行

（1）C语言（C++）这种编写过程是：编写出源代码（源代码是不能直接运行的）然后编译链接形成可执行二进制程序，然后才能运行；而脚本程序不同，脚本程序编写好后源代码即可直接运行（没有编译链接过程）

（2）shell程序是解释运行的，所谓解释运行就是说当我们执行一个shell程序时，shell解析器会逐行的解释shell程序代码，然后一行一行的去运行。（顺序结构）

（3）CPU实际只认识二进制代码，根本不认识源代码。脚本程序源代码其实也不是二进制代码，CPU也不认识，也不能直接执行。只不过脚本程序的编译链接过程不是以脚本程序源代码为单位进行的，而是在脚本运行过程中逐行的解释执行时才去完成脚本程序源代码转成二进制的过程（不一定是编译链接，因为这行脚本程序可能早就编译连接好了，这里我们只是调用它）的。

****

## 2.2、动手写第一个shell

### 2.2.1、编辑器、编译器、运行方法（脚本的3种执行方法）

（1）shell程序是文本格式的，只要是文本编辑器都可以。但是因为我们的shell是要在linux系统下运行的，所以换行符必须是'\n'，而windows下的换行符是"\r\n"，因此windows中的编辑器写的shell不能在linux下运行。所以我们整个课程都是在linux下使用vi编辑器（实际上是vim）进行编写调试的。

（2）编译器  不涉及，因为shell是解释性语言，直接编辑完就可以运行。

（3）shell程序运行的运行有多种方法，这里介绍三种方法：
第一种：./xx.sh，和运行二进制可执行程序方法一样。这样运行shell要求shell程序必须具有可执行权限。chmod a+x xx.sh来添加可执行权限。
第二种：source xx.sh，source是linux的一个命令，这个命令就是用来执行脚本程序的。这样运行不需要脚本具有可执行权限。
第三种：bash xx.sh，bash是一个脚本程序解释器，本质上是一个可执行程序。这样执行相当于我们执行了bash程序，然后把xx.sh作为argv[1]传给他运行。

### 2.2.2、hello world程序和解释

```bash
#!/bin/bash

echo "hello world"
```

（1）shell程序的第一行一般都是： #!/bin/sh		这行话以#!开始，后面加上一个pathname，这行话的意思就是指定shell程序执行时被哪个解释器解释执行。所以我们这里写上/bin/sh意思就是这个shell将来被当前机器中/bin目录下的sh可执行程序执行。
可以将第一行写为：#!/bin/bash来指定使用bash执行该脚本。
==注意==：在ubuntu上面默认使用的解释器sh其实不是bash，而是dash。dash是ubuntu中默认使用的脚本解释器。

（2）脚本中的注释使用#，#开头的行是注释行。如果有多行需要注释，每行前面都要加#。（#就相当于是C语言中的//）

（3）shell程序的正文，由很多行shell语句构成。

### 2.2.3、shell并不神秘

（1）shell就是把以前命令行中键入执行的命令写成了程序。shell其实就是为了避免反复的在命令行下手工输入而发明的一种把手工输入步骤记录下来，然后通过执行shell脚本程序就能再次复述原来记录的手工输入过程的一种技术。

（2）shell编辑完可以直接运行（不需编译）

*****

## 2.3、shell编程学习

### 2.3.1、shell中使用linux命令

（1）练习1：当前目录下创建文件a.txt

```bash
#!/bin/bash

touch a.txt
```

（2）练习2：当前目录下创建文件夹dir，dir下创建文件b.txt

```bash
#!/bin/bash

mkdir dir
cd dir
touch b.txt
cd ..
```

总结：以上2个练习的目的是让大家基本学会写脚本，明白脚本编程其实就是把以前在命令行下输入的命令挪到脚本程序中去然后一次执行。

### 2.3.2、shell中的变量定义和引用

（1）变量定义和初始化。shell是弱类型语言（语言中的变量如果有明确的类型则属于强类型语言；变量没有明确类型就是弱类型语言），和C语言不同。在shell编程中定义变量不需要制定类型，也没有类型这个概念。

```bash
#!/bin/bash

# 变量的定义
string="hello world"
echo $string

```

（2）变量定义时可以初始化，使用=进行初始化赋值。在shell中赋值的=两边是不能有空格的。
==注意==：shell对语法非常在意，非常严格。很多地方空格都是必须没有或者必须有，而且不能随意有没有空格。

（2）变量赋值，变量定义后可以再次赋值，新的赋值会覆盖老的赋值。shell中并不刻意区分变量的定义和赋值，反正每个变量就是一个符号，这个符号的值就是最后一个给他赋值时的值。

```bash
#!/bin/bash

# 变量的定义
string="hello world"
string="new string"
echo $string

# 运行结果为new string
```

（4）变量引用。shell中引用一个变量必须使用$符号，$符号就是变量解引用符号。

==注意==：$符号后面跟一个字符串，这个字符串就会被当作变量去解析。如果这个字符串本身没有定义，执行时并不会报错，而是把这个变量解析为空。也就是说在shell中没有被定义的变量其实就相当于是一个定义并赋值为空的变量。

==注意==：变量引用的时候可以$var，也可以${var}。这两种的区别是在某些情况下只能用${var}而不能简单的$var

```bash
#!/bin/bash

# 演示${}

var="hello"
echo "${val}you"
# 这种时候就必须加大括号，表示前面的是一个变量 
```

### 2.3.3、shell中无引用、单引号和双引号的区别

```bash
#!/bin/bash

echo new string
echo 'new st/'ring'
echo "new st/'ring"

# 输出结果是 
# new string
# new st/'ring
# new st'ring
```

（1）shell中使用字符串可以不加双引号，直接使用。而且有空格时也可以，但是缺陷是不能输出"或者其他转义字符。

（2）shell中也可以使用单引号来表示字符串，也是直接使用的，不能输出转义字符。

（2）单引号中：完全字面替换（不可包含单引号本身）

（3）双引号中：
	$加变量名可以取变量的值
	反引号仍表示命令替换
	\ $表示$的字面值			输出$符号
	\ ` 表示 `的字面值
	\ ` 表示  ‘ 的字面值
	\ \ 表示\的字面值
	除以上情况之外，在其它字符前面的\无特殊含义，只表示字面值。

### 2.3.4、shell中调用linux命令

（1）直接执行

（2）反引号括起来执行。有时候我们在shell中调用linux命令是为了得到这个命令的返回值（结果值），这时候就适合用一对反引号(键盘上ESC按键下面的那个按键，和~在一个按键上)来调用执行命令。

```bash
#!/bin/bash

PWD=`pwd`
echo $PWD

# 用反引号括起来的说明定义的linux中的命令
```

### 2.3.5、shell中的选择分支结构

（1）shell的if语言用法很多，在此只介绍常用的，其他感兴趣可以自己去学

（2）典型if语言格式

```bash
    if [表达式]; then
        xxx
        yyy
        zzz
    else
        xxx
        ddd
        uuu
    fi


```

（3）if的典型应用	

判断文件是否存在。（-f），注意[]里面前后都有空格，不能省略。

判断目录是否存在  （-d）

判断字符串是否相等（"str1" = "str2"），注意用一个等号而不是两个

判断数字是否相等（-eq）、大于（-gt）、小于（-lt）、大于等于（-ge）、小于等于（-le）回忆一下在ARM裸机中讲述ARM汇编条件执行时，曾经用过这些条件判断的缩写。（eq就是equal，gt就是greater than，lt就是less than，ge就是greater or equal，le就是less or equal）

判断字符串是否为空（-z）注意-z判断时如果变量本身没定义也是不成立（也就是说-z认为没定义不等于为空）

```bash
#!/bin/bash

# 判断为文件是否存在
if [ -f a.c ];then
	echo "yes"
else
	echo "no"
	touch a.c
fi

# 判断目录是否存在
if [ -d dir ];then
	echo "yes"
else
	echo "no"
	mkdir dir
fi

# 判断字符串是否相等
if [ "abd" = "abc" ];then
	echo "equal"
else
	echo "not equal"
fi

# 判断数字是否相等
if [ 12 -eq 12 ];then
	echo "equal"
else
	echo "not equal"
fi

# 判断字符串是否为空
str=""
if [ -z $str ];then
	echo "yes"
else
	echo "no"
fi
```

（4）if判断式中使用“-o”表示逻辑或
相当于C语言中在if后面的条件式中用逻辑与、逻辑或来连接2个式子，最终的if中是否成立取决于2个式子的逻辑运算结果。

```bash
#!/bin/bash

# 演示-o 进行逻辑或
if [ 12 -eq 12 -o "abcd" = "abcd" ];then
	echo "yes"
else
	echo "no"

```

（5）逻辑与&&和逻辑或||与简写的if表达式相结合

```bash
#!/bin/bash

# 简写的if表达式
str=""
[ -z $str ] || echo "非空"
# 意思是如果str为空就不会执行echo语句

str=""
[ -z $str ] && echo "空"
# 意思就是str如果为空就执行echo语句
```

*****

## 2.4、shell中的循环结构

### 2.4.1、for循环

（1）要求：能看懂、能改即可。不要求能够完全不参考写出来。因为毕竟嵌入式并不需要完全重新手写shell，系统管理员（服务器运维人员，应用层系统级管理开发的才需要完全掌握shell）

```bash
#!/bin/bash

# for循环
for i in 1 2 3 4 5
do
	echo $i
done
# 将1-5进行片选遍历打印

for i in `ls`
do
	echo $i
done
# 将当前文件夹下的文件挨个打印出来 
```



### 2.4.2、while循环

（1）和C语言的循环在逻辑上无差别

（2）要注意很多格式要求，譬如：while后面的[]两边都有空格，[]后面有分号分号（如果do放在一行的话），i++的写法中有两层括号。

```bash
#!/bin/bash

# while 循环 打印1-10
i=1
j=11
while [ $i -lt $j ]; do
	echo $i
	i=$(($i + 1))
done
```

### 2.4.3、echo的创建和追加输入文件

（1）在shell中可以直接使用echo指令新建一个文件，并且将一些内容传入这个文件中。创建文件并输入内容的关键就是>。

（2）还可以使用echo指令配合追加符号>> 向一个已经存在的文件末尾追加输入内容。

```bash
#!/bin/bash

# echo指令创建文件和直接写入文件
echo "text" > a.txt
# 在当前目录下面创建一个a.txt文件并且将text放到a.txt文件中

# echo指令向已经存在的文件中追加输入内容
echo "aaaa" >> a.txt
```

****

## 2.5、shell中其他值得关注的知识点

### 2.5.1、case语句

（1）shell中的case语句和C语言中的switch case语句作用一样，格式有差异

（2）shell中的case语句天生没有break，也不需要break，和C语言中的switch case不同。shell中的case默认就是匹配上哪个执行哪个，不会说执行完了还去执行后面的其他case（就好像shell中的case语言默认都带了break）。

```bash
#!/bin/bash

# case演示
val=2
case $val in
1) echo "1" ;;
2) echo "2" ;;
esac
```

### 2.5.2、调用shell程序的传参

（1）C语言中可以通过main函数的argc和argv给程序传参

（2）shell程序本身也可以在调用时传参给他。在shell程序内部使用传参也是使用的一些特定符号来表示的，包括：
$#表示调用该shell时传参的个数。（$#计数时只考虑真正的参数个数）
$0、$1、$2·····则依次表示传参的各个参数。

C语言：./a.out aa bb cc 	argc = 4, argv[0] = ./a.out, argv[1]是第一个有效参数····

shell：source a.sh aa bb cc  $# = 3, $0是执行这个shell程序的解析程序的名字，$1是第一个有效参数的值，$2是第2个有效参数的值·····

注意：shell中的很多语法特性和C语言中是相同的，也有很多是不同的。所以大家学的越多越容易混淆（本质原因还是用的不熟悉，用的少），解决方案是：做笔记、作总结、多写代码经常用

```bash
#!/bin/bash

# 演示使用$# $0传参
echo $# $0 $1 $2 $3

# cmdline 中输入bash a.sh aa bb cc
# 执行结果是：3 bash aa bb cc
```

### 2.5.3、while循环和case语言和传参结合

（1）shell中的break关键字和C语言中意义相同（都是跳出）但是用法不同。因为shell中case语句默认不用break的，因此在shell中break只用于循环跳出。所以当while中内嵌case语句时，case中的break是跳出外层的while循环的，不是用来跳出case语句的。

（2）shell中的$# $1等内置变量的值不是不可变的，而是可以被改变，被shift指令改变。shift指令有点像左移运算符，把我们给shell程序的传参左移了一个移出去了，原来的$2变成了新的$1，原来的$#少了1个。

```bash
#!/bin/bash

# 演示shift指令和 $# $1等关系
echo $# $1
shift;
echo $# $1
# 执行：bash a.sh aa bb cc
# 执行结果：3 aa  2 bb
```

*****

## 2.6、Makefile基础回顾

### 2.6.1、Makefile的作用和意义

（1）工程项目中c文件太多管理不方便，因此用Makefile来做项目管理，方便编译链接过程。

（2）uboot和linux kernel本质上都是C语言的项目，都由很多个文件组成，因此都需要通过Makefile来管理。所以要分析uboot必须对Makefile有所了解。

### 2.6.2、目标、依赖、命令

（1）目标就是我们要去make xxx的那个xxx，就是我们最终要生成的东西。

（2）依赖是用来生成目录的原材料

（3）命令就是加工方法，所以make xxx的过程其实就是使用命令将依赖加工成目标的过程。

### 2.6.3、通配符%和Makefile自动推导（规则）

（1）%是Makefile中的通配符，代表一个或几个字母。也就是说%.o就代表所有以.o为结尾的文件。

（2）所谓自动推导其实就是Makefile的规则。当Makefile需要某一个目标时，他会把这个目标去套规则说明，一旦套上了某个规则说明，则Makefile会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。

### 2.6.4、Makefile中定义和使用变量

（1）Makefile中定义和使用变量，和shell脚本中非常相似。相似是说：都没有变量类型，直接定义使用，引用变量时用$var

### 2.6.5、伪目标（.PHONY）

（1）伪目标意思是这个目标本身不代表一个文件，执行这个目标不是为了得到某个文件或东西，而是单纯为了执行这个目标下面的命令。

（2）伪目标一般都没有依赖，因为执行伪目标就是为了执行目标下面的命令。既然一定要执行命令了那就不必加依赖，因为不加依赖意思就是无条件执行。

（3）伪目标可以直接写，不影响使用；但是有时候为了明确声明这个目标是伪目标会在伪目标的前面用.PHONY来明确声明它是伪目标。

### 2.6.6、Makefile的文件名

（1）Makefile的文件名合法的一般有2个：Makefile或者makefile

### 2.6.7、Makfile中引用其他Makefile（include指令）

（1）有时候Makefile总体比较复杂，因此分成好几个Makefile来写。然后在主Makefile中引用其他的，用include指令来引用。引用的效果也是原地展开，和C语言中的头文件包含非常相似。

*****

## 2.7、Mafile补充学习

### 2.7.1、Makefile中的注释用#

（1）Makefile中注释使用#，和shell一样。

### 2.7.2、命令前面的@用来静默执行

（1）在makefile的命令行中前面的@表示静默执行。

（2）Makefile中默认情况下在执行一行命令前会先把这行命令给打印出来，然后再执行这行命令。

（3）如果你不想看到命令本身，只想看到命令执行就静默执行即可。

### 2.7.3、Makefile中几种变量赋值运算符

（1）=		最简单的赋值

（2）:=		一般也是赋值
以上这两个大部分情况下效果是一样的，但是有时候不一样。
用=赋值的变量，在被解析时他的值取决于最后一次赋值时的值，所以你看变量引用的值时不能只往前面看，还要往后面看。
用:=来赋值的，则是就地直接解析，只用往前看即可。

（3）?=	如果变量前面并没有赋值过则执行这条赋值，如果前面已经赋值过了则本行被忽略。（实验可以看出：所谓的没有赋值过其实就是这个变量没有被定义过）

（4）+=  	用来给一个已经赋值的变量接续赋值，意思就是把这次的值加到原来的值的后面，有点类似于strcat。（在shell makefile等文件中，可以认为所有变量都是字符串，+=就相当于给字符串stcat接续内容）（注意一个细节，+=续接的内容和原来的内容之间会自动加一个空格隔开）

注意：Makefile中并不要求赋值运算符两边一定要有空格或者无空格，这一点比shell的格式要求要松一些。

### 2.7.4、Makefile的环境变量

（1）makefile中用export导出的就是环境变量。一般情况下要求环境变量名用大写，普通变量名用小写。

（2）环境变量和普通变量不同，可以这样理解：环境变量类似于整个工程中所有Makefile之间可以共享的全局变量，而普通变量只是当前本Makefile中使用的局部变量。所以要注意：定义了一个环境变量会影响到工程中别的Makefile文件，因此要小心。

（3）Makefile中可能有一些环境变量可能是makefile本身自己定义的内部的环境变量或者是当前的执行环境提供的环境变量（譬如我们在make执行时给makefile传参。make CC=arm-linux-gcc，其实就是给当前Makefile传了一个环境变量CC，值是arm-linux-gcc。我们在make时给makefile传的环境变量值优先级最高的，可以覆盖makefile中的赋值）。这就好像C语言中编译器预定义的宏__ LINE__  __ FUNCTION__等一样。

### 2.7.5、Makefile中使用通配符

（1）*		若干个任意字符
（2）?		1个任意字符
（3）[]		将[]中的字符依次去和外面的结合匹配

还有个%，也是通配符，表示任意多个字符，和*很相似，但是%一般只用于规则描述中，又叫做规则通配符。

关于通配符，Makefile还有一些wildcard等比较复杂的通配符用法，具体参考《跟我一起学Makefile》即可。

```makefile
all : 1.c 2.c 12.c test.c 1.h
	echo *.c
	echo ?.c
	echo [12].c

# 执行结果 ：1.c 2.c 12.c test.c 1.h
# 执行结果 ：1.c 2.c
# 执行结果 ：1.c 2.c
```



### 2.7.6、Makefile的自动变量

（1）为什么使用自动变量。在有些情况下文件集合中文件非常多，描述的时候很麻烦，所以我们Makefile就用一些特殊的符号来替代符合某种条件的文件集，这就形成了自动变量。

（2）自动变量的含义：预定义的特殊意义的符号。就类似于C语言编译器中预制的那些宏__FILE__一样。

（3）常见自动变量：
$@		规则的目标文件名
$<		规则的依赖文件名
$^		依赖的文件集合

```makefile
all : 1.c 2.c 12.c test.c 1.h
	echo $@
	echo $<
	echo $^

# 执行结果 ：all
# 执行结果 ：1.c 
# 执行结果 ：1.c 2.c 12.c text.c 1.h
```



****

# 3、零距离体验uboot

## 3.1、X210官方uboot配置编译实践

### 3.1.1、找到官方移植好的uboot（BSP概念）

（1）源头的源代码是uboot官网下载的。这个下载的源代码可能没有你当前使用的开发板的移植，甚至找不到当前开发板使用的SoC对应的移植版本。

（2）SoC厂商在推出一款SoC后，厂商的工程师会去uboot官网下载一个uboot，根据自己的SoC进行第一步的移植，移植的目标是厂商推出的开发板。（譬如三星的S5PV210芯片厂商出的开发板就叫SMDKV210）.所以三星的工程师移植的uboot是根据他们自己的SMDKV210开发板移植的。

（3）具体的开发板供应商（譬如X210的生产商深圳市九鼎科技）首先购买三星的SMDKV210开发板，然后进行裁剪（把一些无用的接口功能裁剪去，配置降低一下，某些配置会被替换）。硬件替换和裁剪之后生成的新的开发板（譬如X210）和三星官方的SMDKV210有所不同，因此uboot也不同。但是因为SoC是相同的，所以相似度至少有60%以上。所以具体开发板供应商会以三星SMDKV210中移植的uboot为蓝本来移植得到自己的开发板的一个uboot移植。我们买X210开发板时厂商光盘中带的BSP中的uboot源码就是他移植过的。

总结：uboot可以有3种获取途径：uboot官方、SoC官方、具体开发板的官方。

### 3.1.2、在linux源生目录下配置编译

（1）X210移植过的uboot在开发板光盘的BSP中。

（2）BSP就是board support package(板级支持包，一般由开发板供应商提供)，里面的内容就是这个开发板的所有相关的源代码、文档、教程等。

（3）将整个BSP打包文件弄到linux的源生目录中去解压分析，不要在windows中的共享文件夹中解压开。（除非你的代码只在windows下去分析而不去编译，如果你想编译工程就一定不要在windows共享文件夹下，否则会出错）

（4）tar -jxvf qt_x210v3_130807.tar.bz2

（5）我们在linux下维持一份uboot，在windows下也维持一份uboot，在我们没有开始任何工作之前，这两份uboot内容一样的，都是九鼎官方的uboot 内容。我们这样做目的是：在linux中进行编译、在windwos下进行代码分析和观看。（windwos下有SourceInsight等很好的工具辅助我们看代码、编辑代码，在linux下编译和看代码都很麻烦·····）

### 3.1.3、配置

（1）uboot和linux kernel等复杂项目，都不能直接编译，都要先配置才能编译。

（2）uboot也要先配置，配置方法是：首先cd进入uboot源码的根目录，然后在根目录下执行：make x210_sd_config。执行配置命令后，如果出现：Configuring for x210_sd board...
说明配置好了，如果不是这个是别的说明配置出错了。

### 3.1.4、编译得到uboot.bin

（1）编译之前一定要注意检查arm-linux-gcc对不对，检查份2步：
第一步：检查当前编译环境中有没有安装合适的arm-linux-gcc。我们装的是arm-2009q3，因为这个是三星官方、九鼎官方开发uboot时使用的。
第二步：检查当前目录下（uboot根目录）的Makefile中编译器的设置是否正确。在工程的总Makefile中会设置交叉编译工具链的路径和名字，必须确保这个路径和名字和我们自己装的一致，否则编译会出错。

（2）确保了以上2点，即可进行编译。编译很简单，直接make即可。或者可以make -j4 (多线程编译，主机如果是多核心电脑，可以尝试多线程编译，会快一些)

****

## 3.2、uboot的源码目录分析

### 3.2.1、九鼎官方uboot和三星原版uboot对比

（1）以九鼎官方的uboot为蓝本来学习的，以三星官方的这份为对照。

（2）不同版本的uboot或者同一版本不同人移植的uboot，可能目录结构和文件内容都有所不同。将来大家懂了后也可以自己根据需要去添加/删除/更改目录结构。

（3）九鼎在以三星的uboot为原材料进行移植时，把三星版本的uboot中很多不必要的文件夹、文件给删除掉了。这个删除把很多完全用不到的文件清除出去，减少了整体的文件数量，便于工作。

### 3.2.2、各文件介绍

（1）.gitignore。git工具的文件，git是一个版本管理工具（类似的还有个svn），这个文件和git有关，和uboot本身无关的，不用去管。

（2）arm_config.mk。后缀是.mk，是一个Makefile文件，将来在某个Makefile中会去调用它。

（3）三个Changelog文件，修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上个版本修改的记录。正式的项目都有这些记录的。可以直接忽略，主要是给维护uboot的人用的。

（4）config.mk。和arm_config.mk差不多性质。

（5）COPYING。版权声明，uboot本身是GPL许可证的。

（6）CREDITS。鸣谢，里面记录了对uboot有贡献的人，感谢目录。

（7）image_split。一个脚本，看说明是用来分割uboot.bin到BL1的，暂时用不到，先不管。

（8）MAINTAINERS。维护者，就是当前在参与维护uboot源码的社区工作者。

（9）MAKEALL。一个脚本，应该是帮助编译uboot的。

（10）Makefile。这个很重要，是uboot源代码的主Makefile，将来整个uboot被编译时就是用这个Makefile管理编译的，所以我们在下个课程中研究uboot配置编译过程时就要分析这个Makefile。

（11）mk。快速编译的脚本，其实就是先清理然后配置然后编译而已。

（12）mkconfig。这个很重要，是uboot配置阶段的主要配置脚本。uboot的可移植性很大程度就是靠这个配置脚本在维护的。我们在下个课程中研究uboot配置编译过程时就要分析这个配置脚本。

（13）mkmovi。暂时不去管他，一个脚本，和iNand/SD卡启动有关

（14）README。所有的软件都有README，一般拿到一个东西要先读README，这个东西其实就是个简单的使用说明书。

（15）rules.mk。这个文件是我们uboot的Makefile使用的规则，本身非常重要，但是我们不去分析他，不去看他。

总结：以上这些文件中，对我们比较重要，需要认真看的有2个：mkconfig和Makefile。一个负责uboot的配置，一个负责编译。我们在第四部分的课程中会详细讲解分析这两个东西。

### 3.2.3、各文件夹介绍

（1）api.		硬件无关的功能函数的API。uboot移植时基本不用管，这些函数是uboot本身使用的。

（2）api_examples. API相关的测试事例代码。

（3）board。board是板的意思，板就是开发板。board文件夹下每一个文件都代表一个开发板，这个文件夹下面放的文件就是用来描述这一个开发板的信息的。board目录下有多少个文件夹，就表示当前这个uboot已经被移植到多少个开发板上了（当前的uboot支持多少个开发板）。

问题一：思考uboot如何支持多套开发板，如何具有可移植性

问题二：board下有这么多文件夹，究竟如何确定具体使用的是哪一个？uboot在配置阶段会有一些手段帮助我们来确定具体使用的是board目录下的哪一个文件夹。（想想为什么不能直接编译而要先配置）

问题三：开发板越来越多，board目录下文件夹越来越多不方便管控。于是乎uboot就新增了一种机制，可以在board目录下不直接放开发板目录，而是在board下放厂家目录（vendor目录，以具体芯片厂商名字命名），然后将这个IC厂商的所有芯片开发板都丢到这个vendor目录下面去。所以大家会发现我们X210对应的开发板目录在board/samsung/x210。多了这层目录会影响配置阶段，在uboot的配置阶段要注意配置时的路径深度和实际存放要对应，不然配置后编译时找不到文件编译就会失败。注意一个细节就是历史原因造成的兼容性麻烦。最开始时board目录下就是开发板名字，后来才改成厂商名字的。但是因为要向前兼容，同一个厂商原来还是外面的开发板并没有挪移到厂商目录下面去。这样就造成后来的人不知道原委的感到很奇怪，感觉很混乱。

注意：强调一下，uboot的配置阶段（其实就是根目录下面的mkconfig脚本和Makefile中配置有关的部分）主要解决的问题就是在可移植性领域能够帮助我们确定具体的文件夹的路径，然后编译时可以找到应该找到的文件，才能编译成功。因此board目录下的不同会造成配置时的不同。如果移植时没注意这里肯定要失败。

（4）common。common是普遍的普通的，这个文件夹下放的是一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验的。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的。

（5）cpu。这个目录是SoC相关的，里面存放的代码都是SoC相关初始化和控制代码（譬如CPU的、中断的、串口等SoC内部外设的，包括起始代码start.S也在这里）。里面很多子文件夹，每一个子文件夹就是一个SoC系列。
注意：这个问价是严格和硬件相关的，因此移植时也是要注意的。但是因为这个文件夹内都是SoC有关的，我们自己的开发板和三星的开发板虽然板子设计不同但是SoC都是同一个，因此实际移植时这个目录几乎不用动。

（6）disk。磁盘有关的，没研究过，没用过。

（7）doc。文档目录，里面存放了很多uboot相关文档，这些文档可以帮助我们理解uboot代码。但是因为是纯英文的，而且很杂乱，所以几乎没用。

（8）drivers。顾名思义，驱动。这里面放的就是从linux源代码中扣出来的原封不动的linux设备驱动，主要是开发板上必须用到的一些驱动，如网卡驱动、Inand/SD卡、NandFlash等的驱动。要知道：uboot中的驱动其实就是linux中的驱动，uboot在一定程度上移植了linux的驱动给自己用。但是linux是操作系统而uboot只是个裸机程序，因此这种移植会有不同，让我说：uboot中的驱动其实是linux中的驱动的一部分。

（9）examples。示例代码，没用过。

（10）fs。filesystem，文件系统。这个也是从linux源代码中移植过来的，用来管理Flash等资源。

（11）include。头文件目录。uboot和linux kernel在管理头文件时都采用了同一个思路，就是把所有的头文件全部集中存放在include目录下，而不是头文件跟着自己对应的c文件。所以在uboot中头文件包含时路径结构要在这里去找。

（12）lib_开头的一坨。（典型的lib_arm和lib_generic）架构相关的库文件。譬如lib_arm里面就是arm架构使用的一些库文件。lib_generic里是所有架构通用的库文件。这类文件夹中的内容移植时基本不用管。

（13）libfdt。设备树有关的。linux内核在3.4左右的版本的时候更改了启动传参的机制，改用设备树来进行启动传参，进行硬件信息的描述了。

（14）nand_spl。nand相关的，不讲。

（15）net。网络相关的代码，譬如uboot中的tftp nfs ping命令 都是在这里实现的。

（16）onenand开头的，是onenand相关的代码，是三星加的，标准uboot中应该是没有的。

（17）post。没关注过，不知道干嘛的。

（18）sd_fusing。这里面代码实现了烧录uboot镜像到SD卡的代码。后面要仔细研究的。

（19）tools。里面是一些工具类的代码。譬如mkimage。

总结：文件夹里面比较重要的，后面会分析涉及到的有：board、common、cpu、drivers、include、lib_arm、lib_generic、sd_fusing

*****

## 3.3、SourceInsight的基本使用

### 3.3.1、为什么要使用SourceInsight

（1）对于一个真正的一个项目，往往有几十几百甚至上万个c文件、h文件，代码量非常大，代码之间关联非常复杂，就带来一个问题，代码的分析、阅读越来越难。譬如这里引用了一个函数但是这个函数可能在另外一个目录下的一个文件夹中存放，这样情况下代码查找和阅读很困难，我们希望有一个好工具能够帮助。于是乎有了SourceInsight。

### 3.3.2、建立工程及添加文件

（1）要使用SI看代码，首先要创建一个工程。菜单栏：Project->new project。在弹出的对话框中上面输入工程名字（自己起名字，随便写，但是一般要和工程相对应免得时间长了忘记了），下面输入工程文件存放的位置。

（2）工程项目文件和工程中管理的源代码文件目录可以不同，但是我一般习惯放在一起。放在：C:\winshare\s5pv210\uboot\uboot-jiuding\SI_Proj
点确定，进入new project setting，直接点ok进入下一步。

（3）到了向项目中添加文件的步骤。
在左侧选择uboot-jiuding这个目录，然后点右侧边栏的add tree即可添加，发现添加了1054个文件进去。

（4）本来应该已经结束了，但是有遗留问题。因为SI软件有个特点，它只能发现自己识别了的文件类型，对于它未识别的文件类型它就看不到。譬如start.S文件就未包含在内，因为SI默认不认识.S后缀的文件。
解决方案：第一种是自己配置；第二种是加载我提供的AstonSICFG。

（5）解决了4中的问题然后再次添加文件。菜单栏　Project->Add and Remove Project Files  再次浏览到uboot-jiuding目录下，再次add tree，发现添加了额外的19个文件。

### 3.3.3、解析工程文件

（1）SI工作原理就是预先把所有源代码中的所有符号全部解析存储到数据库中，然后等我们进行符号查找时，SI不是查文件而是查数据库帮我们索引符号，因此SI查找速度非常快。

（2）因此我们使用SI查阅源码前应该预先进行源码解析。在菜单栏Project->Syneronize Files，选中上面2个，然后确定。

*****

# 4、uboot配置和编译过程详解

## 4.1、uboot主MakeFile分析

### 4.1.1、uboot version确定（Makefile的24-29行）

（1）uboot的版本号分3个级别：
	VERSION：主板本号
	PATCHLEVEL：次版本号
	SUBLEVEL：再次版本号
	EXTRAVERSION:另外附加的版本信息
	这4个用.分隔开共同构成了最终的版本号。

（2）Makefile中版本号最终生成了一个变量U_BOOT_VERSION，这个变量记录了Makefile中配置的版本号。

（3）include/version_autogenerated.h文件是编译过程中自动生成的一个文件，所以源目录中没有，但是编译过后的uboot中就有了。它里面的内容是一个宏定义，宏定义的值内容就是我们在Makefile中配置的uboot的版本号。

（4）验证方法：自己修改主Makefile中几个Version有关的变量，然后重新编译uboot，然后烧录到SD卡中，从SD卡启动，然后去看启动时uboot打印出来的版本信息，看看变化是不是和自己的分析一致。

### 4.1.2、HOSTARCH和HOSTOS

（1）直接在shell中执行uname -m得到i686，得到的值其实你当前执行这个命令的电脑的CPU的版本号。

（2）shell中的|叫做管道，管道的作用就是把管道前面一个运算式的输出作为后面一个的输入再去做处理，最终的输出才是我们整个式子的输出。

（3）HOSTARCH这个名字：HOST是主机，就是当前在做开发用的这台电脑就叫主机；ARCH是architecture(架构)的缩写，表示CPU的架构。所以HOSTARCH就表示主机的CPU的架构。

（4）这两个环境变量是主机的操作系统和主机的CPU架构，得出后保存备用，后面自然会用到。

### 4.1.3、静默编译（50-54行）

（1）平时默认编译时命令行会打印出来很多编译信息。但是有时候我们不希望看到这些编译信息，就后台编译即可。这就叫静默编译。

（2）使用方法就是编译时make -s，-s会作为MAKEFLAGS传给Makefile，在50-54行这段代码作用下XECHO变量就会被变成空（默认等于echo），于是实现了静默编译。

### 4.1.4、2种编译方法（原地编译和单独输出文件夹编译）

（1）编译复杂项目，Makefile提供2种编译管理方法。默认情况下是当前文件夹中的.c文件，编译出来的.o文件会放在同一文件夹下。这种方式叫原地编译。原地编译的好处就是处理起来简单。

（2）原地编译有一些坏处：第一，污染了源文件目录。第二的缺陷就是一套源代码只能按照一种配置和编译方法进行处理，无法同时维护2个或2个以上的配置编译方式。

（3）为了解决以上2种缺陷，uboot支持单独输出文件夹方式的编译（linux kernel也支持，而且uboot的这种技术就是从linux kernel学习来的）。基本思路就是在编译时另外指定一个输出目录，将来所有的编译生成的.o文件或生成的其他文件全部丢到那个输出目录下去。源代码目录不做任何污染，这样输出目录就承载了本次配置编译的所有结果。

（4）具体用法：默认的就是原地编译。如果需要指定具体的输出目录编译则有2种方式来指定输出目录。（具体参考Makefile 56-76行注释内容）
第一种：make O=输出目录	
第二种：export BUILD_DIR=输出目录 然后再make
如果两个都指定了（既有BUILD_DIR环境变量存在，又有O=xx），则O=xx具有更高优先级，听他的。

（5）两种编译的实现代码在Makefile的78-123行。

### 4.1.5、OBJTREE、SRCTREE、TOPDIR

（1）OBJTREE：编译出的.o文件存放的目录的根目录。在默认编译下，OBJTREE等于当前目录；在O=xx编译下，OBJTREE就等于我们设置的那个输出目录。

（2）SRCTREE: 源码目录，其实就是源代码的根目录，也就是当前目录。
总结：在默认编译下，OBJTREE和SRCTREE相等；在O=xx这种编译下OBJTREE和SRCTREE不相等。Makefile中定义这两个变量，其实就是为了记录编译后的.o文件往哪里放，就是为了实现O=xx的这种编译方式的。

### 4.1.6、MKCONFIG（Makefile的101行）

（1）Makefile中定义的一个变量（在这里定义，在后面使用），它的值就是我们源码根目录下面的mkconfig。这个mkconfig是一个脚本，这个脚本就是uboot配置阶段的配置脚本。后面要用至少3节课详细讲这个配置脚本的工作。

### 4.1.7、include $(obj)include/config.mk（133行）

（1）include/config.mk不是源码自带的（你在没有编译过的源码目录下是找不到这个文件的），要在配置过程（make x210_sd_config）中才会生成这个文件。因此这个文件的值和我们配置过程有关，是由配置过程根据我们的配置自动生成的。

（2）我们X210在iNand情况下配置生成的config.mk内容为：
ARCH   = arm
CPU    = s5pc11x
BOARD  = x210
VENDOR = samsung
SOC    = s5pc110

（3）我们在下一行（134行）export导出了这5个变量作为环境变量。所以着两行加起来其实就是为当前makefile定义了5个环境变量而已。之所以不直接给出这5个环境变量的值，是因为我们希望这5个值是可以被人很容易的、集中的配置的。

（4）这里的配置值来自于2589行那里的配置项。如果我们要更改这里的某个配置值要到2589行那里调用MKCONFIG脚本传参时的参数。

### 4.1.8、ARCH CROSS_COMPILE

（1）接下来有2个很重要的环境变量。一个是ARCH，上面导出的，值来自于我们的配置过程，它的值会影响后面的CROSS_COMPILE环境变量的值。ARCH的意义是定义当前编译的目标CPU的架构。

（2）CROSS_COMPILE是定义交叉编译工具链的前缀的。定义这些前缀是为了在后面用（用前缀加上后缀来定义编译过程中用到的各种工具链中的工具）。我们把前缀和后缀分开还有一个原因就是：在不同CPU架构上的交叉编译工具链，只是前缀不一样，后缀都是一样的。因此定义时把前缀和后缀分开，只需要在定义前缀时区分各种架构即可实现可移植性。

（3）CROSS_COMPILE在136-182行来确定。CROSS_COMPILE是被ARCH所确定的，只要配置了ARCH=arm，那么我们就只能在ARM的那个分支去设置CROSS_COMPILE的值。这个设置值只要能保证找到那个交叉编译工具链即可，不一定非得是全路径的，相对路径也可以。（如果已经将工具链导出到环境变量，并且设置了符号链接，这样CROSS_COMPILE = arm-linux-就可以）

（4）实际运用时，我们可以在Makefile中去更改设置CROSS_COMPILE的值，也可以在编译时用make CROSS_COMPILE=xxxx来设置，而且编译时传参的方法可以覆盖Makefile里面的设置。

### 4.1.9、config.mk分析

#### 4.1.9.1、$(TOPDIR)/config.mk（主Makefile的185行）

#### 4.1.9.2、编译工具定义（config.mk 94-107行）

#### 4.1.9.3、包含开发板配置项目（config.mk, 112行）

（1）autoconfig.mk文件不是源码提供的，是配置过程自动生成的。

（2）这个文件的作用就是用来指导整个uboot的编译过程。这个文件的内容其实就是很多CONFIG_开头的宏（可以理解为变量），这些宏/变量会影响我们uboot编译过程的走向（原理就是条件编译）。在uboot代码中有很多地方使用条件编译进行编写，这个条件编译是用来实现可移植性的。（可以说uboot的源代码在很大程度来说是拼凑起来的，同一个代码包含了各种不同开发板的适用代码，用条件编译进行区别。）

（3）这个文件不是凭空产生的，配置过程也是需要原材料来产生这个文件的。原材料在源码目录的inlcude/configs/xxx.h头文件。（X210开发板中为include/configs/x210_sd.h）。这个h头文件里面全都是宏定义，这些宏定义就是我们对当前开发板的移植。每一个开发板的移植都对应这个目录下的一个头文件，这个头文件里每一个宏定义都很重要，这些配置的宏定义就是我们移植uboot的关键所在。

#### 4.1.9.4、链接脚本（config.mk 142-149行）

（1）如果定义了CONFIG_NAND_U_BOOT宏，则链接脚本叫u-boot-nand.lds，如果未定义这个宏则链接脚本叫u-boot.lds。

（2）从字面意思分析，即可知：CONFIG_NAND_U_BOOT是在Nand版本情况下才使用的，我们使用的X210都是iNand版本的，因此这个宏没有的。

（3）实际在board\samsung\x210目录下有u-boot.lds，这个就是链接脚本。我们在分析uboot的编译链接过程时就要考虑这个链接脚本。

#### 4.1.9.5、TEXT_BASE（config.mk 156-158行）

（1）Makefile中在配置X210开发板时，在board/samsung/x210目录下生成了一个文件config.mk，其中的内容就是：TEXT_BASE = 0xc3e00000相当于定义了一个变量。

（2）TEXT_BASE是将来我们整个uboot链接时指定的链接地址。因为uboot中启用了虚拟地址映射，因此这个C3E00000地址就等于0x23E00000(也可能是33E00000具体地址要取决于uboot中做的虚拟地址映射关系)。

（3）回顾裸机中讲的链接地址的问题，再想想dnw方式先下载x210_usb.bin然后再下载uboot.bin时为什么第二个地址是23E00000.

#### 4.1.9.6、自动推导规则（config.mk 239-256行）

（1）我们在讲Makefile时提到过自动推导规则，具体理解可以参考《跟我一起学Makefile》

### 4.1.10、编译目标文件

（1）291行出现了整个主Makefile中第一个目标all（也就是默认目标，我们直接在uboot根目录下make其实就等于make all，就等于make这个目标）

（2）目标中有一些比较重要的。譬如：u-boot是最终编译链接生成的elf格式的可执行文件，

（3）unconfig字面意思来理解就是未配置。这个符号用来做为我们各个开发板配置目标的依赖。目标是当我们已经配置过一个开发板后再次去配置时还可以配置。

（4）我们配置开发板时使用：make x210_sd_config，因此分析x210_sd_config肯定是主Makefile中的一个目标。

****

## 4.2、uboot配置过程详解

### 4.2.1、mkconfig脚本的6个传参

（1）mkconfig脚本的6个参数
	$(@:_config=) arm s5pc11x x210 samsung s5pc110

​	x210_sd_config里的_config部分用空替换，得到：x210_sd，这就是第一个参数，所以：
​	$1:	x210_sd
​	$2:	arm
​	$3: s5pc11x
​	$4:	x210
​	$5: samsumg
​	$6:	s5pc110
​	所以，$# = 6

（2）第23行：其实就是看BOARD_NAME变量是否有值，如果有值就维持不变；如果无值就给他赋值为$1，实际分析结果：BOARD_NAME=x210_sd

（3）第25行：如果$#小于4，则exit 1（mkconfig脚本返回1）

（4）第26行：如果$#大于6，则也返回1.
所以：mkconfig脚本传参只能是4、5、6，如果大于6或者小于4都不行。

（5）从第33行到第118行，都是在创建符号链接。为什么要创建符号链接？这些符号链接文件的存在就是整个配置过程的核心，这些符号链接文件（文件夹）的主要作用是给头文件包含等过程提供指向性连接。根本目的是让uboot具有可移植性。

uboot可移植性的实现原理：在uboot中有很多彼此平行的代码，各自属于各自不同的架构/CPU/开发板，我们在具体到一个开发板的编译时用符号连接的方式提供一个具体的名字的文件夹供编译时使用。这样就可以在配置的过程中通过不同的配置使用不同的文件，就可以正确的包含正确的文件。

（6）创建的符号链接：
第一个：在include目录下创建asm文件，指向asm-arm。（46-48行）
第二个：在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc110
第三个：在include目录下创建regs.h文件，指向include/s5pc110.h
删除第二个。
第四个：在inlcude/asm-arm下创建一个arch文件，指向include/asm-arm/arch-s5pc11x
第五个：在include/asm-arm下创建一个proc文件，指向include/asm-arm/proc-armv

总结：一共创建了4个符号链接。这4个符号链接将来在写代码过程中，头文件包含时非常有用。譬如一个头文件包含可能是：#include <asm/xx.h>

### 4.2.2、给make创建合适的头文件

（1）创建include/config.mk文件（mkconfig文件123-129行）

（2）创建include/config.mk文件是为了让主Makefile在第133行去包含的（详解见2.4.3.3节）。

（3）思考：uboot的配置和编译过程的配合。编译的时候需要ARCH=arm、CPU=xx等这些变量来指导编译，配置的时候就是为编译阶段提供这些变量。那为什么不在Makefile中直接定义这些变量去使用，而要在mkconfig脚本中创建config.mk文件然后又在Makefile中include这些文件呢？

（4）理解这些脚本时，时刻要注意自己当前所处的路径。

（5）创建（默认情况）/追加（make -a时追加）include/config.h文件（mkconfig文件的134-141行）。

（6）这个文件里面的内容就一行#include <configs/x210_sd.h>，这个头文件是我们移植x210开发板时，对开发板的宏定义配置文件。这个文件是我们移植x210时最主要的文件。

（7）x210_sd.h文件会被用来生成一个autoconfig.mk文件，这个文件会被主Makefile引入，指导整个编译过程。这里面的这些宏定义会影响我们对uboot中大部分.c文件中一些条件编译的选择。从而实现最终的可移植性。

注意：uboot的整个配置过程，很多文件之间是有关联的（有时候这个文件是在那个文件中创建出来的；有时候这个文件被那个文件包含进去；有时候这个文件是由那个文件的内容生成的决定的）

注意：uboot中配置和编译过程，所有的文件或者全局变量都是字符串形式的（不是指的C语言字符串的概念，指的是都是字符组成的序列）。这意味着我们整个uboot的配置过程都是字符串匹配的，所以一定要细节，注意大小写，要注意不要输错字符，因为一旦错一个最后会出现一些莫名其妙的错误，很难排查，这个是uboot移植过程中新手来说最难的地方。

****

## 4.3、uboot的链接脚本

（1）uboot的链接脚本和我们之前裸机中的链接脚本并没有本质区别，只是复杂度高一些，文件多一些，使用到的技巧多一些。

（2）ENTRY(_start)用来指定整个程序的入口地址。所谓入口地址就是整个程序的开头地址，可以认为就是整个程序的第一句指令。有点像C语言中的main。

（3）之前在裸机中告诉大家，指定程序的链接地址有2种方法：一种是在Makefile中ld的flags用-Ttext 0x20000000来指定；第二种是在链接脚本的SECTIONS开头用.=0x20000000来指定。两种都可以实现相同效果。其实，这两种技巧是可以共同配合使用的，也就是说既在链接脚本中指定也在ld flags中用-Ttext来指定。两个都指定以后以-Ttext指定的为准。

（4）uboot的最终链接起始地址就是在Makefile中用-Ttext 来指定的，具体参见2.4.5.2节，注意TEXT_BASE变量。最终来源是Makefile中配置对应的命令中，在make xxx_config时得到的。

（5）在代码段中注意文件排列的顺序。指定必须放在前面部分的那些文件就是那些必须安排在前16KB内的文件，这些文件中的函数在前16KB会被调用。在后面第二部分（16KB之后）中调用的程序，前后顺序就无所谓了。

（6）链接脚本中除了.text  .data .rodata .bss段等编译工具自带的段之外，编译工具还允许我们自定义段。譬如uboot总的.u_boot_cmd段就是自定义段。自定义段很重要。

*****

# 5、uboot源码分析–启动第一阶段

## 5.1、start.S的引入

### 5.1.1、u-boot.lds中找到start.S入口

（1）在C语言中整个项目的入口就是main函数（这是C语言规定的），所以譬如说一个有10000个.c文件的项目，第一个要分析的文件就是包含了main函数的那个文件。

（2）在uboot中因为有汇编阶段参与，因此不能直接找main.c。整个程序的入口取决于链接脚本中ENTRY声明的地方。ENTRY(_start)因此_start符号所在的文件就是整个程序的起始文件，_start所在处的代码就是整个程序的起始代码。

### 5.1.2、SourceInsight中如何找到文件

（1）当前状况：我们知道在uboot中的1000多个文件中有一个符号叫_start，但是我们不知道这个符号在哪个文件中。这种情况下要查找一个符号在所有项目中文件中的引用，要使用SourceInsight的搜索功能。

（2）利用SI工具搜索到一共7个 _ start，然后分析搜索出来的7处，发现有2个是 api_example，2个是onenand相关的，都不是我们要找的。剩下3个都在uboot/cpu/s5pc11x/start.S文件中。

（3）然后进入start.S文件中，发现57行中就是_start标号的定义处，于是乎我们就找到了整个uboot的入口代码，就是第57行。

### 5.1.3、SI中找文件技巧

（1）以上，找到了start.S文件，下面我们就从start.S文件开始分析uboot第一阶段。

（2）在SI中，如果我们知道我们要找的文件的名字，但是我们又不知道他在哪个目录下，我们要怎样找到并打开这个文件？方法是在SI中先打开右边的工程项目管理栏目，然后点击最左边那个（这个是以文件为单位来浏览的），然后在上面输入栏中输入要找的文件的名字。我们在输入的时候，SI在不断帮我们进行匹配，即使你不记得文件的全名只是大概记得名字，也能帮助你找到你要找的文件。

******

## 5.2、start.S解析1

### 5.2.1、不简单的头文件包含

（1）#include <config.h>。config.h是在include目录下的，这个文件不是源码中本身存在的文件，而是配置过程中自动生成的文件。（详见mkconfig脚本）。这个文件的内容其实是包含了一个头文件：#include <configs/x210_sd.h>".

（2）经过分析后，发现start.S中包含的第一个头文件就是：include/configs/x210_sd.h，这个文件是整个uboot移植时的配置文件。这里面是好多宏。因此这个头文件包含将include/configs/x210_sd.h文件和start.S文件关联了起来。因此之后在分析start.S文件时，主要要考虑的就是x210_sd.h文件。

（3）#include <version.h>。include/version.h中包含了include/version_autogenerated.h，这个头文件就是配置过程中自动生成的。里面就一行内容：#define U_BOOT_VERSION "U-Boot 1.3.4"。这里面定义的宏U_BOOT_VERSION的值是一个字符串，字符串中的版本号信息来自于Makefile中的配置值。这个宏在程序中会被调用，在uboot启动过程中会串口打印出uboot的版本号，那个版本号信息就是从这来的。

（4）#include <asm/proc/domain.h>。asm目录不是uboot中的原生目录，uboot中本来是没有这个目录的。asm目录是配置时创建的一个符号链接，实际指向的是就是asm-arm（详解上一章节分析mkconfig脚本时）.

（5）经过分析后发现，实际文件是：include/asm-arm/proc-armv/domain.h

（6）从这里可以看出之前配置时创建的符号链接的作用，如果没有这些符号链接则编译时根本通不过，因为找不到头文件。（所以uboot不能在windows的共享文件夹下配置编译，因为windows中没有符号链接）

思考：为什么start.S不直接包含asm-arm/proc-armv/domain.h，而要用asm/proc/domain.h。这样的设计主要是为了可移植性。因为如果直接包含，则start
.S文件和CPU架构（和硬件）有关了，可移植性就差了。譬如我要把uboot移植到mips架构下，则start.S源代码中所有的头文件包含全部要修改。我们用了符号链接之后，则start.S中源代码不用改，只需要在具体的硬件移植时配置不同，创建的符号链接指向的不同，则可以具有可移植性。

### 5.2.2、启动代码的16字节头部

（1）裸机中讲过，在SD卡启动/Nand启动等整个镜像开头需要16字节的校验头。（mkv210image.c中就是为了计算这个校验头）。我们以前做裸机程序时根本没考虑这16字节校验头，因为：1、如果我们是usb启动直接下载的方式启动的则不需要16字节校验头（irom application note）；2、如果是SD卡启动mkv210image.c中会给原镜像前加16字节的校验头。

（2）uboot这里start.S中在开头位置放了16字节的填充占位，这个占位的16字节只是保证正式的image的头部确实有16字节，但是这16字节的内容是不对的，还是需要后面去计算校验和然后重新填充的。

### 5.2.3、异常向量表的构建

（1）异常向量表是硬件决定的，软件只是参照硬件的设计来实现它。

（2）异常向量表中每种异常都应该被处理，否则真遇到了这种异常就跑飞了。但是我们在uboot中并未非常细致的处理各种异常。

（3）复位异常处的代码是：b reset，因此在CPU复位后真正去执行的有效代码是reset处的代码，因此reset符号处才是真正的有意义的代码开始的地方。

### 5.2.4、有点意思的deadbeef

（1）.balignl 16,0xdeadbeef.	这一句指令是让当前地址对齐排布，如果当前地址不对齐则自动向后走地址直到对齐，并且向后走的那些内存要用0xdeadbeef来填充。

（3）0xdeadbeef这是一个十六进制的数字，这个数字很有意思，组成这个数字的十六进制数全是abcdef之中的字母，而且这8个字母刚好组成了英文的dead beef这两个单词，字面意思是坏牛肉。

（3）为什么要对齐访问？有时候是效率的要求，有时候是硬件的特殊要求。

### 5.2.5、TEXT_BASE等

（1）第100行这个TEXT_BASE就是上个课程中分析Makefile时讲到的那个配置阶段的TEXT_BASE，其实就是我们链接时指定的uboot的链接地址。（值就是c3e00000）

（2）源代码中和配置Makefile中很多变量是可以互相运送的。简单来说有些符号的值可以从Makefile中传递到源代码中。

类似的还有CFG_PHY_UBOOT_BASE 	33e00000	uboot在DDR中的物理地址

### 5.2.6、设置CPU为SVC模式

（1）msr	cpsr_c, #0xd3	将CPU设置为禁止FIQ IRQ，ARM状态，SVC模式。

（2）其实ARM CPU在复位时默认就会进入SVC模式，但是这里还是使用软件将其置为SVC模式。整个uboot工作时CPU一直处于SVC模式。

### 5.2.7、设置L2、L1cache和MMU

（1）bl	disable_l2cache		// 禁止L2 cache
（2）bl	set_l2cache_auxctrl_cycle	// l2 cache相关初始化
（3）bl	enable_l2cache		// 使能l2 cache
（4）刷新L1 cache的icache和dcache。
（5）关闭MMU
总结：上面这5步都是和CPU的cache和mmu有关的，不用去细看，大概知道即可。

### 5.2.8、识别并暂存启动介质选择

（1）从哪里启动是由SoC的OM5:OM0这6个引脚的高低电平决定的。

（2）实际上在210内部有一个寄存器（地址是0xE0000004），这个寄存器中的值是硬件根据OM引脚的设置而自动设置值的。这个值反映的就是OM引脚的接法（电平高低），也就是真正的启动介质是谁。

（3）我们代码中可以通过读取这个寄存器的值然后判断其值来确定当前选中的启动介质是Nand还是SD还是其他的。

（4）start.S的225-227行执行完后，在r2寄存器中存储了一个数字，这个数字等于某个特定值时就表示SD启动，等于另一个特定值时表示从Nand启动····

（5）260行中给r3中赋值#BOOT_MMCSD(0x03)，这个在SD启动时实际会被执行，因此执行完这一段代码后r3中存储了0x03，以后备用。

*****

## 5.3、start.S解析2-lowlevel_init

### 5.3.1、设置栈（SRAM中的栈）并调用lowlevel_init

（1）284-286行第一次设置栈。这次设置栈是在SRAM中设置的，因为当前整个代码还在SRAM中运行，此时DDR还未被初始化还不能用。栈地址0xd0036000是自己指定的，指定的原则就是这块空间只给栈用，不会被别人占用。

（2）在调用函数前初始化栈，主要原因是在被调用的函数内还有再次调用函数，而BL只会将返回地址存储到LR中，但是我们只有一个LR，所以在第二层调用函数前要先将LR入栈，否则函数返回时第一层的返回地址就丢了。

注意：（1）使用SourceInsight的Reference功能，找到lowlevel_init函数真正的地方，是在uboot/board/samsumg/x210/lowlevel_init.S中。

### 5.3.2、检查复位状态

（1）复杂CPU允许多种复位情况。譬如直接冷上电、热启动、睡眠(低功耗)状态下的唤醒等，这些情况都属于复位。所以我们在复位代码中要去检测复位状态，来判断到底是哪种情况。

（2）判断哪种复位的意义在于：冷上电时DDR是需要初始化才能用的；而热启动或者低功耗状态下的复位则不需要再次初始化DDR。

### 5.2.11、一些SRAM SROM相关GPIO设置

（1）与主线启动代码无关，不用管

### 5.3.3、供电锁存

（1）lowlevel_init.S的第100-104行，开发板供电锁存。
总结：在前100行，lowlevel_init.S中并没有做太多有意义的事情（除了关看门狗、供电锁存外），然后下面从110行才开始进行有意义的操作。

### 5.3.4、判断当前代码执行位置

（1）lowlevel_init.S的110-115行。

（2）这几行代码的作用就是判定当前代码执行的位置在SRAM中还是在DDR中。为什么要做这个判定？原因1：BL1（uboot的前一部分）在SRAM中有一份，在DDR中也有一份，因此如果是冷启动那么当前代码应该是在SRAM中运行的BL1，如果是低功耗状态的复位这时候应该就是在DDR中运行的。原因2：我们判定当前运行代码的地址是有用的，可以指导后面代码的运行。譬如在lowlevel_init.S中判定当前代码的运行地址，就是为了确定要不要执行时钟初始化和初始化DDR的代码。如果当前代码是在SRAM中，说明冷启动，那么时钟和DDR都需要初始化；如果当前代码是在DDR中，那么说明是热启动则时钟和DDR都不用再次初始化。

（3）bic	r1, pc, r0	这句代码的意义是：将pc的值中的某些bit位清0，剩下一些特殊的bit位赋值给r1（r0中为1的那些位清零）相等于：r1 = pc & ~(ff000fff)
ldr	r2, _TEXT_BASE	加载链接地址到r2，然后将r2的相应位清0剩下特定位。

（4）最后比较r1和r2.
总结：这一段代码是通过读取当前运行地址和链接地址，然后处理两个地址后对比是否相等，来判定当前运行是在SRAM中（不相等）还是DDR中（相等）。从而决定是否跳过下面的时钟和DDR初始化。

### 5.3.5、system_clock_init

（1）使用SI搜索功能，确定这个函数就在当前文件的205行，一直到第385行。这个初始化时钟的过程和裸机中初始化的过程一样的，只是更加完整而且是用汇编代码写的。

（2）在x210_sd.h中300行到428行，都是和时钟相关的配置值。这些宏定义就决定了210的时钟配置是多少。也就是说代码在lowlevel_init.S中都写好了，但是代码的设置值都被宏定义在x210_sd.h中了。因此，如果移植时需要更改CPU的时钟设置，根本不需要动代码，只需要在x210_sd.h中更改配置值即可。

### 5.3.6、mem_ctrl_asm_init

（1）该函数用来初始化DDR

（2）函数位置在uboot/cpu/s5pc11x/s5pc110/cpu_init.S文件中。

（3）该函数和裸机中初始化DDR代码是一样的。实际上裸机中初始化DDR的代码就是从这里抄的。配置值也可以从这里抄，但是当时我自己根据理解+抄袭整出来的一份。

（4）配置值中其他配置值参考裸机中的解释即可明白，有一个和裸机中讲的不一样。DMC0_MEMCONFIG_0，在裸机中配置值为0x20E01323；在uboot中配置为0x30F01313.这个配置不同就导致结果不同。
在 裸机中DMC0的256MB内存地址范围是0x20000000-0x2FFFFFFF; 
在uboot中DMC0的256MB内存地址范围为0x30000000-0x3FFFFFFF。

（5）之前在裸机中时配置为2开头的地址，当时并没有说可以配置为3开头。从分析九鼎移植的uboot可以看出：DMC0上允许的地址范围是20000000-3FFFFFFF（一共是512MB），而我们实际只接了256MB物理内存，SoC允许我们给这256MB挑选地址范围。

（6）总结一下：在uboot中，可用的物理地址范围为：0x30000000-0x4FFFFFFF。一共512MB，其中30000000-3FFFFFFF为DMC0，40000000-4FFFFFFF为DMC1。

（7）我们需要的内存配置值在x210_sd.h的438行到468行之间。分析的时候要注意条件编译的条件，配置头文件中考虑了不同时钟配置下的内存配置值，这个的主要目的是让不同时钟需求的客户都能找到合适自己的内存配置值。

（8）在uboot中DMC0和DMC1都工作了，所以在裸机中只要把uboot中的配置值和配置代码全部移植过去，应该是能够让DMC0和DMC1都工作的。

### 5.3.7、uart_asm_init

（1）这个函数用来初始化串口

（2）初始化完了后通过串口发送了一个'O'

### 5.3.8、tzpc_init

（1）trust zone初始化，没搞过，不管

### 5.3.9、pop {pc}以返回

（1）返回前通过串口打印'K'

分析；lowlevel_init.S执行完如果没错那么就会串口打印出"OK"字样。这应该是我们uboot中看到的最早的输出信息。

总结回顾：lowlevel_init.S中总共做了哪些事情：
检查复位状态、IO恢复、关看门狗、开发板供电锁存、时钟初始化、DDR初始化、串口初始化并打印'O'、tzpc初始化、打印'K'。
其中值得关注的：关看门狗、开发板供电锁存、时钟初始化、DDR初始化、打印"OK"

*****

## 5.4、start.S解析3

### 5.4.1、再次设置栈（DDR中的栈）

（1）再次开发板供电锁存。第一，做2次是不会错的；第二，做2次则第2次无意义；做代码移植时有一个古怪谨慎保守策略就是尽量添加代码而不要删除代码。

（2）之前在调用lowlevel_init程序前设置过1次栈（start.S 284-287行），那时候因为DDR尚未初始化，因此程序执行都是在SRAM中，所以在SRAM中分配了一部分内存作为栈。本次因为DDR已经被初始化了，因此要把栈挪移到DDR中，所以要重新设置栈，这是第二次（start.S 297-299行）；这里实际设置的栈的地址是33E00000，刚好在uboot的代码段的下面紧挨着。

（3）为什么要再次设置栈？DDR已经初始化了，已经有大片内存可以用了，没必要再把栈放在SRAM中可怜兮兮的了；原来SRAM中内存大小空间有限，栈放在那里要注意不能使用过多的栈否则栈会溢出，我们及时将栈迁移到DDR中也是为了尽可能避免栈使用时候的小心翼翼。
感慨：uboot的启动阶段主要技巧就在于小范围内有限条件下的辗转腾挪。

### 5.4.2、再次判断当前地址以决定是否重定位

（1）再次用相同的代码判断运行地址是在SRAM中还是DDR中，不过本次判断的目的不同（上次判断是为了决定是否要执行初始化时钟和DDR的代码）这次判断是为了决定是否进行uboot的relocate。

（2）冷启动时当前情况是uboot的前一部分（16kb或者8kb）开机自动从SD卡加载到SRAM中正在运行，uboot的第二部分（其实第二部分是整个uboot）还躺在SD卡的某个扇区开头的N个扇区中。此时uboot的第一阶段已经即将结束了（第一阶段该做的事基本做完了），结束之前要把第二部分加载到DDR中链接地址处（33e00000），这个加载过程就叫重定位。

### 5.4.3、uboot重定位详解

（1）D0037488这个内存地址在SRAM中，这个地址中的值是被硬件自动设置的。硬件根据我们实际电路中SD卡在哪个通道中，会将这个地址中的值设置为相应的数字。譬如我们从SD0通道启动时，这个值为EB000000；从SD2通道启动时，这个值为EB200000

（2）我们在start.S的260行确定了从MMCSD启动，然后又在278行将#BOOT_MMCSD写入了INF_REG3寄存器中存储着。然后又在322行读出来，再和#BOOT_MMCSD去比较，确定是从MMCSD启动。最终跳转到mmcsd_boot函数中去执行重定位动作。

（3）真正的重定位是通过调用movi_bl2_copy函数完成的，在uboot/cpu/s5pc11x/movi.c中。是一个C语言的函数

（4）copy_bl2(2, MOVI_BL2_POS, MOVI_BL2_BLKCNT,
			CFG_PHY_UBOOT_BASE, 0);

分析参数：2表示通道2；MOVI_BL2_POS是uboot的第二部分在SD卡中的开始扇区，这个扇区数字必须和烧录uboot时烧录的位置相同；MOVI_BL2_BLKCNT是uboot的长度占用的扇区数；CFG_PHY_UBOOT_BASE是重定位时将uboot的第二部分复制到DDR中的起始地址（33E00000）.

*****

## 5.5、start.S解析4–虚拟地址映射

参考博客：https://blog.csdn.net/qq_34127958/article/details/72634164

### 5.5.1、什么是虚拟地址、物理地址

（1）物理地址就是物理设备设计生产时赋予的地址。像裸机中使用的寄存器的地址就是CPU设计时指定的，这个就是物理地址。物理地址是硬件编码的，是设计生产时确定好的，一旦确定了就不能改了。

（2）一个事实就是：寄存器的物理地址是无法通过编程修改的，是多少就是多少，只能通过查询数据手册获得并操作。坏处就是不够灵活。一个解决方案就是使用虚拟地址。

（3）虚拟地址意思就是在我们软件操作和硬件被操作之间增加一个层次，叫做虚拟地址映射层。有了虚拟地址映射后，软件操作只需要给虚拟地址，硬件操作还是用原来的物理地址，映射层建立一个虚拟地址到物理地址的映射表。当我们软件运行的时候，软件中使用的虚拟地址在映射表中查询得到对应的物理地址再发给硬件去执行（虚拟地址到物理地址的映射是不可能通过软件来实现的）。

### 5.5.2、MMU单元的作用

（1）MMU就是memory management unit，内存管理单元。MMU实际上是SOC中一个硬件单元，它的主要功能就是实现虚拟地址到物理地址的映射。

（2）MMU单片在CP15协处理器中进行控制，也就是说要操控MMU进行虚拟地址映射，方法就是对cp15协处理器的寄存器进行编程。

### 5.5.3、地址映射的额外收益1：访问控制

（1）访问控制就是：在管理上对内存进行分块，然后每块进行独立的虚拟地址映射，然后在每一块的映射关系中同时还实现了访问控制（对该块可读、可写、只读、只写、不可访问等控制）

（2）回想在C语言中编程中经常会出现一个错误：Segmentation fault。实际上这个段错误就和MMU实现的访问控制有关。当前程序只能操作自己有权操作的地址范围（若干个内存块），如果当前程序指针出错访问了不该访问的内存块则就会触发段错误。

### 5.5.4、地址映射的额外收益2：cache

（1）cache的工作和虚拟地址映射有关系。

（2）cache是快速缓存，意思就是比CPU慢但是比DDR块。CPU嫌DDR太慢了，于是乎把一些DDR中常用的内容事先读取缓存在cache中，然后CPU每次需要找东西时先在cache中找。如果cache中有就直接用cache中的；如果cache中没有才会去DDR中寻找。

### 5.5.5、使能域访问（cp15的c3寄存器）

（1）cp15协处理器内部有c0到c15共16个寄存器，这些寄存器每一个都有自己的作用。我们通过mrc和mcr指令来访问这些寄存器。所谓的操作cp协处理器其实就是操作cp15的这些寄存器。

（2）c3寄存器在mmu中的作用是控制域访问。域访问是和MMU的访问控制有关的。

### 5.5.6、设置TTB（cp15的c2寄存器）

（1）TTB就是translation table base，转换表基地址。首先要明白什么是TT（translation table转换表），TTB其实就是转换表的基地址。

（2）转换表是建立一套虚拟地址映射的关键。转换表分2部分，表索引和表项。表索引对应虚拟地址，表项对应物理地址。一对表索引和表项构成一个转换表单元，能够对一个内存块进行虚拟地址转换。（映射中基本规定中规定了内存映射和管理是以块为单位的，至于块有多大，要看你的MMU的支持和你自己的选择。在ARM中支持3种块大小，细表1KB、粗表4KB、段1MB）。真正的转换表就是由若干个转换表单元构成的，每个单元负责1个内存块，总体的转换表负责整个内存空间（0-4G）的映射。

（3）整个建立虚拟地址映射的主要工作就是建立这张转换表

（4）转换表放置在内存中的，放置时要求起始地址在内存中要xx位对齐。转换表不需要软件去干涉使用，而是将基地址TTB设置到cp15的c2寄存器中，然后MMU工作时会自动去查转换表。

### 5.5.7、使能MMU单元（cp15的c1寄存器）

（1）cp15的c1寄存器的bit0控制MMU的开关。只要将这一个bit置1即可开启MMU。开启MMU之后上层软件层的地址就必须经过TT的转换才能发给下层物理层去执行。

### 5.5.8、找到映射表待分析

（1）通过符号查找，确定转换表在lowlevel_init.S文件的593行。

*****

## 5.6、start.S解析5–建立虚拟映射表

### 5.6.1、宏FL_SECTION_ENTRY

### 5.6.2、页表项各bit位含义

### 5.6.3、段式页表详解

### 5.6.4、实验操作验证

### 5.6.5、总结：关于MMU和虚拟地址映射的学习

```assembly
@ 虚拟映射汇编函数

.macro FL_SECTION_ENTRY base,ap,d,c,b
	.word (\base << 20) | (\ap << 10) | \
	      (\d << 5) | (1<<4) | (\c << 3) | (\b << 2) | (1<<1)
.endm
.section .mmudata, "a"
	.align 14
	// the following alignment creates the mmu table at address 0x4000.
	.globl mmu_table
mmu_table:
	.set __base,0
	// Access for iRAM
	.rept 0x100
	FL_SECTION_ENTRY __base,3,0,0,0
	.set __base,__base+1
	.endr

	// Not Allowed
	.rept 0x200 - 0x100
	.word 0x00000000
	.endr

	.set __base,0x200
	// should be accessed
	.rept 0x600 - 0x200
	FL_SECTION_ENTRY __base,3,0,1,1
	.set __base,__base+1
	.endr

	.rept 0x800 - 0x600
	.word 0x00000000
	.endr

	.set __base,0x800
	// should be accessed
	.rept 0xb00 - 0x800
	FL_SECTION_ENTRY __base,3,0,0,0
	.set __base,__base+1
	.endr

/*	.rept 0xc00 - 0xb00
	.word 0x00000000
	.endr */

	.set __base,0xB00
	.rept 0xc00 - 0xb00
	FL_SECTION_ENTRY __base,3,0,0,0
	.set __base,__base+1
	.endr

	// 0xC000_0000映射到0x2000_0000
	.set __base,0x300
	//.set __base,0x200
	// 256MB for SDRAM with cacheable
	.rept 0xD00 - 0xC00
	FL_SECTION_ENTRY __base,3,0,1,1
	.set __base,__base+1
	.endr

	// access is not allowed.
	@.rept 0xD00 - 0xC80
	@.word 0x00000000
	@.endr

	.set __base,0xD00
	// 1:1 mapping for debugging with non-cacheable
	.rept 0x1000 - 0xD00
	FL_SECTION_ENTRY __base,3,0,0,0
	.set __base,__base+1
	.endr	
	
```

> 映射表：
>
> VA								PA									length
> 0-10000000				  0-10000000					256MB
> 10000000-20000000	0									 256MB
> 20000000-60000000	20000000-60000000	  1GB		512-1.5G
> 60000000-80000000	0									 512MB	1.5G-2G
> 80000000-b0000000	80000000-b0000000	  768MB	2G-2.75G
> b0000000-c0000000	b0000000-c0000000	  256MB	2.75G-3G
> c0000000-d0000000	30000000-40000000	  256MB	3G-3.25G
> d-完							   d-完								768MB	3.25G-4G
>
> 
>
> DRAM有效范围：
> DMC0: 	0x30000000-0x3FFFFFFF
> DMC1:	0x40000000-0x4FFFFFFF
>
> 结论：虚拟地址映射只是把虚拟地址的c0000000开头的256MB映射到了DMC0的30000000开头的256MB物理内存上去了。其他的虚拟地址空间根本没动，还是原样映射的。
>
> 思考：为什么配置时将链接地址设置为c3e00000，因为这个地址将来会被映射到33e00000这个物理地址。

宏观上理解转换表：整个转换表可以看作是一个int类型的数组，数组中的一个元素就是一个表索引和表项的单元。数组中的元素值就是表项，这个元素的数组下标就是表索引。

ARM的段式映射中长度为1MB，因此一个映射单元只能管1MB内存，那我们整个4G范围内需要4G/1MB=4096个映射单元，也就是说这个数组的元素个数是4096.实际上我们做的时候并没有依次单个处理这4096个单元，而是把4096个分成几部分，然后每部分用for循环做相同的处理。

### 5.6.7、再次设置栈

（1）第三次设置栈。这次设置栈还是在DDR中，之前虽然已经在DDR中设置过一次栈了，但是本次设置栈的目的是将栈放在比较合适（安全，紧凑而不浪费内存）的地方。

（2）我们实际将栈设置在uboot起始地址上方2MB处，这样安全的栈空间是：2MB-uboot大小-0x1000=1.8MB左右。这个空间既没有太浪费内存，又足够安全。

### 5.6.8、清理bss

（1）清理bss段代码和裸机中讲的一样。注意表示bss段的开头和结尾地址的符号是从链接脚本u-boot.lds得来的。

### 5.6.9、ldr	pc, _start_armboot

（1）start_armboot是uboot/lib_arm/board.c中，这是一个C语言实现的函数。这个函数就是uboot的第二阶段。这句代码的作用就是将uboot第二阶段执行的函数的地址传给pc，实际上就是使用一个远跳转直接跳转到DDR中的第二阶段开始地址处。

（2）远跳转的含义就是这句话加载的地址和当前运行地址无关，而和链接地址有关。因此这个远跳转可以实现从SRAM中的第一阶段跳转到DDR中的第二阶段。

（3）这里这个远跳转就是uboot第一阶段和第二阶段的分界线。

### 5.6.10、总结：uboot的第一阶段做了哪些工作

（1）构建异常向量表
（2）设置CPU为SVC模式
（3）关看门狗
（4）开发板供电置锁
（5）时钟初始化
（6）DDR初始化
（7）串口初始化并打印"OK"
（8）重定位
（9）建立映射表并开启MMU
（10）跳转到第二阶段

******

# 6、uboot源码分析–启动第二阶段

## 6.1、start_armboot函数简介

### 6.1.1、一个很长的函数

（1）这个函数在uboot/lib_arm/board.c的第444行开始到908行结束。

（2）450行还不是全部，因为里面还调用了别的函数。

（3）为什么这么长的函数，怎么不分成两三个函数？主要因为这个函数整个构成了uboot启动的第二阶段。

### 6.1.2、一个函数组成uboot第二阶段

### 6.1.3、宏观分析：uboot第二阶段应该做什么

（1）概括来讲uboot第一阶段主要就是初始化了SoC内部的一些部件（譬如看门狗、时钟），然后初始化DDR并且完成重定位。

（2）由宏观分析来讲，uboot的第二阶段就是要初始化剩下的还没被初始化的硬件。主要是SoC外部硬件（譬如iNand、网卡芯片····）、uboot本身的一些东西（uboot的命令、环境变量等····）。然后最终初始化完必要的东西后进入uboot的命令行准备接受命令。

### 6.1.4、思考：uboot第二阶段完结于何处？

（1）uboot启动后自动运行打印出很多信息（这些信息就是uboot在第一和第二阶段不断进行初始化时，打印出来的信息）。然后uboot进入了倒数bootdelay秒然后执行bootcmd对应的启动命令。

（2）如果用户没有干涉则会执行bootcmd进入自动启动内核流程（uboot就死掉了）；此时用户可以按下回车键打断uboot的自动启动进入uboot的命令行下。然后uboot就一直工作在命令行下。

（3）uboot的命令行就是一个死循环，循环体内不断重复：接收命令、解析命令、执行命令。这就是uboot最终的归宿。

*****

## 6.2、start_armboot解析1

### 6.2.1、init_fnc_t

（1）typedef int (init_fnc_t) (void);	这是一个函数类型

（2）init_fnc_ptr是一个二重函数指针，回顾高级C语言中讲过：二重指针的作用有2个（其中一个是用来指向一重指针），一个是用来指向指针数组。因此这里的init_fuc_ptr可以用来指向一个函数指针数组。

### 6.2.2、DECLARE_GLOBAL_DATA_PTR

（1）#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")定义了一个全局变量名字叫gd,这个全局变量是一个指针类型，占4字节。用volatile修饰表示可变的，用register修饰表示这个变量要尽量放到寄存器中，后面的asm("r8")是gcc支持的一种语法，意思就是要把gd放到寄存器r8中。

（2）综合分析，DECLARE_GLOBAL_DATA_PTR就是定义了一个要放在寄存器r8中的全局变量，名字叫gd，类型是一个指向gd_t类型变量的指针。

（3）为什么要定义为register？因为这个全局变量gd（global data的简称）是uboot中很重要的一个全局变量（准确的说这个全局变量是一个结构体，里面有很多内容，这些内容加起来构成的结构体就是uboot中常用的所有的全局变量），这个gd在程序中经常被访问，因此放在register中提升效率。因此纯粹是运行效率方面考虑，和功能要求无关。并不是必须的。

（4）gd_t定义在include/asm-arm/global_data.h中。gd_t中定义了很多全局变量，都是整个uboot使用的；其中有一个bd_t类型的指针，指向一个bd_t类型的变量，这个bd是开发板的板级信息的结构体，里面有不少硬件相关的参数，譬如波特率、IP地址、机器码、DDR内存分布。

```c
typedef	struct	global_data {
	bd_t		*bd;		//存放的是我们开发板板相关的信息的
	unsigned long	flags;	 //用来存储标志位的
	unsigned long	baudrate;//波特率的全局变量
	unsigned long	have_console;//bool类型，表示当前控制台是否有没有建立起来
	unsigned long	reloc_off;	//重定位时候的偏移量
	unsigned long	env_addr;	//环境变量相关的地址
	unsigned long	env_valid;	//bool类型，在内存中的环境变量在当前是否可用
	unsigned long	fb_base;	//frame buffer/缓存 的基地址
#ifdef CONFIG_VFD
	unsigned char	vfd_type;	/* display type */
#endif
#if 0
	unsigned long	cpu_clk;	/* CPU clock in Hz!		*/
	unsigned long	bus_clk;
	phys_size_t	ram_size;	/* RAM size */
	unsigned long	reset_status;	/* reset status register at boot */
#endif
	void		**jt;		/* jump table */
} gd_t;

```



###  6.2.3、内存使用排布

#### 6.2.3.1、为什么要分配内存

（1）DECLARE_GLOBAL_DATA_PTR只能定义了一个指针，也就是说gd里的这些全局变量并没有被分配内存，我们在使用gd之前要给他分配内存，否则gd也只是一个野指针而已。

（2）gd和bd需要内存，内存当前没有被人管理（因为没有操作系统统一管理内存），大片的DDR内存散放着可以随意使用（只要使用内存地址直接去访问内存即可）。但是因为uboot中后续很多操作还需要大片的连着内存块，因此这里使用内存要本着够用就好，紧凑排布的原则。所以我们在uboot中需要有一个整体规划。

#### 6.2.3.2、内存排布

`gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t);`

（1）uboot区	CFG_UBOOT_BASE-xx（长度为uboot的实际长度）
（2）堆区		长度为CFG_MALLOC_LEN，实际为912KB
（3）栈区		长度为CFG_STACK_SIZE，实际为512KB
（4）gd		长度为sizeof(gd_t)，实际36字节
（5）bd		长度为sizeof(bd_t)，实际为44字节左右
（6）内存间隔	`__ asm__ __ volatile__("": : :"memory");`为了防止高版本的gcc的优化造成错误。

### 6.2.4、for循环执行init_sequence

（1）init_sequence是一个函数指针数组，数组中存储了很多个函数指针，这些指向指向的函数都是init_fnc_t类型（特征是接收参数是void类型，返回值是int）。

（2）init_sequence在定义时就同时给了初始化，初始化的函数指针都是一些函数名。（C语言高级专题中讲过：函数名的实质）

（3）init_fnc_ptr是一个二重函数指针，可以指向init_sequence这个函数指针数组。

（4）用for循环肯定是想要去遍历这个函数指针数组（遍历的目的也是去依次执行这个函数指针数组中的所有函数）。思考：如何遍历一个函数指针数组？有2种方法：第一种也是最常用的一种，用下标去遍历，用数组元素个数来截至。第二种不常用，但是也可以。就是在数组的有效元素末尾放一个标志，依次遍历到标准处即可截至（有点类似字符串的思路）。
我们这里使用了第二种思路。因为数组中存的全是函数指针，因此我们选用了NULL来作为标志。我们遍历时从开头依次进行，直到看到NULL标志截至。这种方法的优势是不用事先统计数组有多少个元素。

（5）init_fnc_t的这些函数的返回值定义方式一样的，都是：函数执行正确时返回0，不正确时返回-1.所以我们在遍历时去检查函数返回值，如果遍历中有一个函数返回值不等于0则hang()挂起。从分析hang函数可知：uboot启动过程中初始化板级硬件时不能出任何错误，只要有一个错误整个启动就终止，除了重启开发板没有任何办法。

（6）init_sequence中的这些函数，都是board级别的各种硬件初始化。

### 6.2.5、cpu_init

（1）看名字这个函数应该是cpu内部的初始化，所以这里是空的。

### 6.2.6、board_init

（1）board_init在uboot/board/samsung/x210/x210.c中，这个看名字就知道是x210开发板相关的初始化。

（2）DECLARE_GLOBAL_DATA_PTR在这里声明是为了后面使用gd方便。可以看出把gd的声明定义成一个宏的原因就是我们要到处去使用gd，因此就要到处声明，定义成宏比较方便。

（3）网卡初始化。CONFIG_DRIVER_DM9000这个宏是x210_sd.h中定义的，这个宏用来配置开发板的网卡的。dm9000_pre_init函数就是对应的DM9000网卡的初始化函数。开发板移植uboot时，如果要移植网卡，主要的工作就在这里。

（4）这个函数中主要是网卡的GPIO和端口的配置，而不是驱动。因为网卡的驱动都是现成的正确的，移植的时候驱动是不需要改动的，关键是这里的基本初始化。因为这些基本初始化是硬件相关的。

### 6.2.7、gd->bd->bi_arch_number

（1）bi_arch_number是board_info中的一个元素，含义是：开发板的机器码。所谓机器码就是uboot给这个开发板定义的一个唯一编号。

（2）机器码的主要作用就是在uboot和linux内核之间进行比对和适配。

（3）嵌入式设备中每一个设备的硬件都是定制化的，不能通用。嵌入式设备的高度定制化导致硬件和软件不能随便适配使用。这就告诉我们：这个开发板移植的内核镜像绝对不能下载到另一个开发板去，否则也不能启动，就算启动也不能正常工作，有很多隐患。因此linux做了个设置：给每个开发板做个唯一编号（机器码），然后在uboot、linux内核中都有一个软件维护的机器码编号。然后开发板、uboot、linux三者去比对机器码，如果机器码对上了就启动，否则就不启动（因为软件认为我和这个硬件不适配）。

（4）MACH_TYPE在x210_sd.h中定义，值是2456，并没有特殊含义，只是当前开发板对应的编号。这个编号就代表了x210这个开发板的机器码，将来这个开发板上面移植的linux内核中的机器码也必须是2456，否则就启动不起来。

（5）uboot中配置的这个机器码，会作为uboot给linux内核的传参的一部分传给linux内核，内核启动过程中会比对这个接收到的机器码，和自己本身的机器码相对比，如果相等就启动，如果不想等就不启动。

（6）理论上来说，一个开发板的机器码不能自己随便定。理论来说有权利去发放这个机器码的只有uboot官方，所以我们做好一个开发板并且移植了uboot之后，理论上应该提交给uboot官方审核并发放机器码（好像是免费的）。但是国内的开发板基本都没有申请（主要是因为国内开发者英文都不行，和国外开源社区接触比较少），都是自己随便编号的。随便编号的问题就是有可能和别人的编号冲突，但是只要保证uboot和kernel中的编号是一致的，就不影响自己的开发板启动。

### 6.2.8、gd->bd->bi_boot_params

（1）bd_info中另一个主要元素，bi_boot_params表示uboot给linux kernel启动时的传参的内存地址。也就是说uboot给linux内核传参的时候是这么传的：uboot事先将准备好的传参（字符串，就是bootargs）放在内存的一个地址处（就是bi_boot_params），然后uboot就启动了内核（uboot在启动内核时真正是通过寄存器r0 r1 r2来直接传递参数的，其中有一个寄存器中就是bi_boot_params）。内核启动后从寄存器中读取bi_boot_params就知道了uboot给我传递的参数到底在内存的哪里。然后自己去内存的那个地方去找bootargs。

（2）经过计算得知：X210中bi_boot_params的值为0x30000100，这个内存地址就被分配用来做内核传参了。所以在uboot的其他地方使用内存时要注意，千万不敢把这里给淹没了。

背景：关于DDR的配置：

（1）board_init中除了网卡的初始化之外，剩下的2行用来初始化DDR。

（2）注意：这里的初始化DDR和汇编阶段lowlevel_init中初始化DDR是不同的。当时是硬件的初始化，目的是让DDR可以开始工作。现在是软件结构中一些DDR相关的属性配置、地址设置的初始化，是纯软件层面的。

（3）软件层次初始化DDR的原因：对于uboot来说，他怎么知道开发板上到底有几片DDR内存，每一片的起始地址、长度这些信息呢？在uboot的设计中采用了一种简单直接有效的方式：程序员在移植uboot到一个开发板时，程序员自己在x210_sd.h中使用宏定义去配置出来板子上DDR内存的信息，然后uboot只要读取这些信息即可。（实际上还有另外一条思路：就是uboot通过代码读取硬件信息来知道DDR配置，但是uboot没有这样。实际上PC的BIOS采用的是这种）

（4）x210_sd.h的496行到501行中使用了标准的宏定义来配置DDR相关的参数。主要配置了这么几个信息：有几片DDR内存、每一片DDR的起始地址、长度。这里的配置信息我们在uboot代码中使用到内存时就可以从这里提取使用（想象uboot中使用到内存的地方都不是直接用地址数字的，都是用宏定义的）

***

## 6.3、start_armboot解析2-interrupt_init

### 6.3.1、interrupt_init

（1）看名字函数是和中断初始化有关的，但是实际上不是，实际上这个函数是用来初始化定时器的（实际使用的是Timer4）。

（2）裸机中讲过：210共有5个PWM定时器。其中Timer0-timer3都有一个对应的PWM信号输出的引脚。而Timer4没有引脚，无法输出PWM波形。Timer4在设计的时候就不是用来输出PWM波形的（没有引脚，没有TCMPB寄存器），这个定时器被设计用来做计时。

（3）Timer4用来做计时时要使用到2个寄存器：TCNTB4、TCNTO4。TCNTB中存了一个数，这个数就是定时次数（每一次时间是由时钟决定的，其实就是由2级时钟分频器决定的）。我们定时时只需要把定时时间/基准时间=数，将这个数放入TCNTB中即可；我们通过TCNTO寄存器即可读取时间有没有减到0，读取到0后就知道定的时间已经到了。

（4）使用Timer4来定时，因为没有中断支持，所以CPU不能做其他事情同时定时，CPU只能使用轮询方式来不断查看TCNTO寄存器才能知道定时时间到了没。因为Timer4的定时是不能实现微观上的并行。uboot中定时就是通过Timer4来实现定时的。所以uboot中定时时不能做其他事（考虑下，典型的就是bootdelay，bootdelay中实现定时并且检查用户输入是用轮询方式实现的，原理参考裸机中按键章节中的轮询方式处理按键）

（5）interrupt_init函数将timer4设置为定时10ms。关键部位就是get_PCLK函数获取系统设置的PCLK_PSYS时钟频率，然后设置TCFG0和TCFG1进行分频，然后计算出设置为10ms时需要向TCNTB中写入的值，将其写入TCNTB，然后设置为auto reload模式，然后开定时器开始计时就没了。
总结：在学习这个函数时，注意标准代码和之前裸机代码中的区别，重点学会：通过定义结构体的方式来访问寄存器，通过函数来自动计算设置值以设置定时器。

### 6.3.2、env_init

（1）env_init，看名字就知道是和环境变量有关的初始化。

（2）为什么有很多env_init函数，主要原因是uboot支持各种不同的启动介质（譬如norflash、nandflash、inand、sd卡·····），我们一般从哪里启动就会把环境变量env放到哪里。而各种介质存取操作env的方法都是不一样的。因此uboot支持了各种不同介质中env的操作方法。所以有好多个env_xx开头的c文件。实际使用的是哪一个要根据自己开发板使用的存储介质来定（这些env_xx.c同时只有1个会起作用，其他是不能进去的，通过x210_sd.h中配置的宏来决定谁被包含的），对于x210来说，我们应该看env_movi.c中的函数。

（3）经过基本分析，这个函数只是对内存里维护的那一份uboot的env做了基本的初始化或者说是判定（判定里面有没有能用的环境变量）。当前因为我们还没进行环境变量从SD卡到DDR中的relocate，因此当前环境变量是不能用的。

（4）在start_armboot函数中（776行）调用env_relocate才进行环境变量从SD卡中到DDR中的重定位。重定位之后需要环境变量时才可以从DDR中去取，重定位之前如果要使用环境变量只能从SD卡中去读取。

### 6.3.3、init_baudrate

（1）init_baudrate看名字就是初始化串口通信的波特率的。

（2）getenv_r函数用来读取环境变量的值。用getenv函数读取环境变量中“baudrate”的值（注意读取到的不是int型而是字符串类型），然后用simple_strtoul函数将字符串转成数字格式的波特率。

（3）baudrate初始化时的规则是：先去环境变量中读取"baudrate"这个环境变量的值。如果读取成功则使用这个值作为环境变量，记录在gd->baudrate和gd->bd->bi_baudrate中；如果读取不成功则使用x210_sd.h中的的CONFIG_BAUDRATE的值作为波特率。从这可以看出：环境变量的优先级是很高的。

### 6.3.4、serial_init

（1）serial_init看名字是初始化串口的。（疑问：start.S中调用的lowlevel_init.S中已经使用汇编初始化过串口了，这里怎么又初始化？这两个初始化是重复的还是各自有不同？）

（2）SI中可以看出uboot中有很多个serial_init函数，我们使用的是uboot/cpu/s5pc11x/serial.c中的serial_init函数。

（3）进来后发现serial_init函数其实什么都没做。因为在汇编阶段串口已经被初始化过了，因此这里就不再进行硬件寄存器的初始化了。

### 6.3.5、console_init_f

（1）console_init_f是console（控制台）的第一阶段初始化。_f表示是第一阶段初始化，_r表示第二阶段初始化。有时候初始化函数不能一次一起完成，中间必须要夹杂一些代码，因此将完整的一个模块的初始化分成了2个阶段。（我们的uboot中start_armboot的826行进行了console_init_r的初始化）

（2）console_init_f在uboot/common/console.c中，仅仅是对gd->have_console设置为1而已，其他事情都没做。

### 6.3.6、display_banner

（1）display_banner用来串口输出显示uboot的logo

（2）display_banner中使用printf函数向串口输出了version_string这个字符串。那么上面的分析表示console_init_f并没有初始化好console怎么就可以printf了呢？

（3）通过追踪printf的实现，发现printf->puts，而puts函数中会判断当前uboot中console有没有被初始化好。如果console初始化好了则调用fputs完成串口发送（这条线才是控制台）；如果console尚未初始化好则会调用serial_puts(再调用serial_putc直接操作串口寄存器进行内容发送)。

（4）控制台也是通过串口输出，非控制台也是通过串口输出。究竟什么是控制台？和不用控制台的区别？实际上分析代码会发现，控制台就是一个用软件虚拟出来的设备，这个设备有一套专用的通信函数（发送、接收···），控制台的通信函数最终会映射到硬件的通信函数中来实现。uboot中实际上控制台的通信函数是直接映射到硬件串口的通信函数中的，也就是说uboot中用没用控制器其实并没有本质差别。

（5）但是在别的体系中，控制台的通信函数映射到硬件通信函数时可以用软件来做一些中间优化，譬如说缓冲机制。（操作系统中的控制台都使用了缓冲机制，所以有时候我们printf了内容但是屏幕上并没有看到输出信息，就是因为被缓冲了。我们输出的信息只是到了console的buffer中，buffer还没有被刷新到硬件输出设备上，尤其是在输出设备是LCD屏幕时）

（6）U_BOOT_VERSION在uboot源代码中找不到定义，这个变量实际上是在makefile中定义的，然后在编译时生成的include/version_autogenerated.h中用一个宏定义来实现的。

### 6.3.7、print_cpuinfo

（1）uboot启动过程中：
CPU:  S5PV210@1000MHz(OK)
        APLL = 1000MHz, HclkMsys = 200MHz, PclkMsys = 100MHz
        MPLL = 667MHz, EPLL = 96MHz
                       HclkDsys = 166MHz, PclkDsys = 83MHz
                       HclkPsys = 133MHz, PclkPsys = 66MHz
                       SCLKA2M  = 200MHz
Serial = CLKUART 
这些信息都是print_cpuinfo打印出来的。

### 6.3.8、checkboard

（1）checkboard看名字是检查、确认开发板的意思。这个函数的作用就是检查当前开发板是哪个开发板并且打印出开发板的名字。

### 6.3.9、init_func_i2c

（1）这个函数实际没有被执行，X210的uboot中并没有使用I2C。如果将来我们的开发板要扩展I2C来接外接硬件，则在x210_sd.h中配置相应的宏即可开启。

### 6.3.10、uboot学习实践

（1）对uboot源代码进行完修改（修改内容根据自己的理解和分析来修改）
（2）make distclean然后make x210_sd_config然后make
（3）编译完成得到u-boot.bin，然后去烧录。烧录方法按照裸机第三部分讲的linux下使用dd命令来烧写的方法来烧写。
（4）烧写过程：
第一步：进入sd_fusing目录下
第二步：make clean
第三步：make
第四步：插入sd卡，ls /dev/sd*得到SD卡在ubuntu中的设备号（一般是/dev/sdb，注意SD卡要连接到虚拟机ubuntu中，不要接到windows中）
第五步：./sd_fusing.sh /dev/sdb完成烧录（注意不是sd_fusing2.sh）
（5）总结：uboot就是个庞大点复杂点的裸机程序而已，我们完全可以对他进行调试。调试的方法就是按照上面步骤，根据自己对代码的分析和理解对代码进行更改，然后重新编译烧录运行，根据运行结果来学习。

### 6.3.11、dram_init

（1）dram_init看名字是关于DDR的初始化。疑问：在汇编阶段已经初始化过DDR了否则也无法relocate到第二部分运行，怎么在这里又初始化DDR？

（2）dram_init都是在给gd->bd里面关于DDR配置部分的全局变量赋值，让gd->bd数据记录下当前开发板的DDR的配置信息，以便uboot中使用内存。

（3）从代码来看，其实就是初始化gd->bd->bi_dram这个结构体数组。

### 6.3.12、display_dram_config

（1）看名字意思就是打印显示dram的配置信息。
（2）启动信息中的：（DRAM:    512 MB）就是在这个函数中打印出来的。
（3）思考：如何在uboot运行中得知uboot的DDR配置信息？uboot中有一个命令叫bdinfo，这个命令可以打印出gd->bd中记录的所有硬件相关的全局变量的值，因此可以得知DDR的配置信息。
DRAM bank   = 0x00000000
-> start    = 0x30000000
-> size     = 0x10000000
DRAM bank   = 0x00000001
-> start    = 0x40000000
-> size     = 0x10000000

### 6.3.13、init_sequence总结

（1）都是板级硬件的初始化以及gd、gd->bd中的数据结构的初始化。譬如：
网卡初始化、机器码（gd->bd->bi_arch_number）、内核传参DDR地址（gd->bd->bi_boot_params）、Timer4初始化为10ms一次、波特率设置（gd->bd->bi_baudrate和gd->baudrate）、console第一阶段初始化（gd->have_console设置为1）、打印uboot的启动信息、打印cpu相关设置信息、检查并打印当前开发板名字、DDR配置信息初始化（gd->bd->bi_dram）、打印DDR总容量。

*****

## 6.4、start_armboot解析3

### 6.4.1、CFG_NO_FLASH

（1）虽然NandFlash和NorFlash都是Flash，但是一般NandFlash会简称为Nand而不是Flash，一般讲Flash都是指的Norflash。这里2行代码是Norflash相关的。

（2）flash_init执行的是开发板中对应的NorFlash的初始化、display_flash_config打印的也是NorFlash的配置信息（Flash:   8 MB就是这里打印出来的）。但是实际上X210中是没有Norflash的。所以着两行代码是可以去掉的（我也不知道为什么没去掉？猜测原因有可能是去掉着两行代码会导致别的地方工作不正常，需要花时间去移植调试，然后移植的人就懒得弄。实际上不去掉除了显示有8MB Flash实际没用之外也没有别的影响）

CONFIG_VFD和CONFIG_LCD是显示相关的，这个是uboot中自带的LCD显示的软件架构。但是实际上我们用LCD而没有使用uboot中设置的这套软件架构，我们自己在后面自己添加了一个LCD显示的部分。

### 6.4.2、mem_malloc_init

（1）mem_malloc_init函数用来初始化uboot的堆管理器。

（2）uboot中自己维护了一段堆内存，肯定自己就有一套代码来管理这个堆内存。有了这些东西uboot中你也可以malloc、free这套机制来申请内存和释放内存。我们在DDR内存中给堆预留了896KB的内存。

### 6.4.3、代码实践，去掉Flash看会不会出错。

结论：加上CONFIG_NOFLASH宏之后编译出错，说明代码移植的不好，那个文件的包含没有被这个宏控制。于是乎移植的人就直接放这没管。

### 6.4.4、开发板独有初始化：mmc初始化

（1）从536到768行为开发板独有的初始化。意思是三星用一套uboot同时满足了好多个系列型号的开发板，然后在这里把不同开发板自己独有的一些初始化写到了这里。用#if条件编译配合CONFIG_xxx宏来选定特定的开发板。

（2）X210相关的配置在599行到632行。

（3）mmc_initialize看名字就应该是MMC相关的一些基础的初始化，其实就是用来初始化SoC内部的SD/MMC控制器的。函数在uboot/drivers/mmc/mmc.c里。

（4）uboot中对硬件的操作（譬如网卡、SD卡···）都是借用的linux内核中的驱动来实现的，uboot根目录底下有个drivers文件夹，这里面放的全都是从linux内核中移植过来的各种驱动源文件。

（5）mmc_initialize是具体硬件架构无关的一个MMC初始化函数，所有的使用了这套架构的代码都掉用这个函数来完成MMC的初始化。mmc_initialize中再调用board_mmc_init和cpu_mmc_init来完成具体的硬件的MMC控制器初始化工作。

（6）cpu_mmc_init在uboot/cpu/s5pc11x/cpu.c中，这里面又间接的调用了drivers/mmc/s3c_mmcxxx.c中的驱动代码来初始化硬件MMC控制器。这里面分层很多，分层的思想一定要有，否则完全就糊涂了。

### 6.4.5、env_relocate

（1）env_relocate是环境变量的重定位，完成从SD卡中将环境变量读取到DDR中的任务。

（2）环境变量到底从哪里来？SD卡中有一些（8个）独立的扇区作为环境变量存储区域的。但是我们烧录/部署系统时，我们只是烧录了uboot分区、kernel分区和rootfs分区，根本不曾烧录env分区。所以当我们烧录完系统第一次启动时ENV分区是空的，本次启动uboot尝试去SD卡的ENV分区读取环境变量时失败（读取回来后进行CRC校验时失败），我们uboot选择从uboot内部代码中设置的一套默认的环境变量出发来使用（这就是默认环境变量）；这套默认的环境变量在本次运行时会被读取到DDR中的环境变量中，然后被写入（也可能是你saveenv时写入，也可能是uboot设计了第一次读取默认环境变量后就写入）SD卡的ENV分区。然后下次再次开机时uboot就会从SD卡的ENV分区读取环境变量到DDR中，这次读取就不会失败了。

（3）真正的从SD卡到DDR中重定位ENV的代码是在env_relocate_spec内部的movi_read_env完成的。

### 6.4.6、IP地址、MAC地址的确定

（1）开发板的IP地址是在gd->bd中维护的，来源于环境变量ipaddr。getenv函数用来获取字符串格式的IP地址，然后用string_to_ip将字符串格式的IP地址转成字符串格式的点分十进制格式。

（2）IP地址由4个0-255之间的数字组成，因此一个IP地址在程序中最简单的存储方法就是一个unsigend int。但是人类容易看懂的并不是这种类型，而是点分十进制类型（192.168.1.2）。这两种类型可以互相转换。

### 6.4.7、devices_init

（1）devices_init看名字就是设备的初始化。这里的设备指的就是开发板上的硬件设备。放在这里初始化的设备都是驱动设备，这个函数本来就是从驱动框架中衍生出来的。uboot中很多设备的驱动是直接移植linux内核的（譬如网卡、SD卡），linux内核中的驱动都有相应的设备初始化函数。linux内核在启动过程中就有一个devices_init(名字不一定完全对，但是差不多)，作用就是集中执行各种硬件驱动的init函数。

（2）uboot的这个函数其实就是从linux内核中移植过来的，它的作用也是去执行所有的从linux内核中继承来的那些硬件驱动的初始化函数。

### 6.4.8、jumptable_init

（1）jumptable跳转表，本身是一个函数指针数组，里面记录了很多函数的函数名。看这阵势是要实现一个函数指针到具体函数的映射关系，将来通过跳转表中的函数指针就可以执行具体的函数。这个其实就是在用C语言实现面向对象编程。在linux内核中有很多这种技巧。

（2）通过分析发现跳转表只是被赋值从未被引用，因此跳转表在uboot中根本就没使用。

### 6.4.9、console_init_r

（1）console_init_f是控制台的第一阶段初始化，console_init_r是第二阶段初始化。实际上第一阶段初始化并没有实质性工作，第二阶段初始化才进行了实质性工作。

（2）uboot中有很多同名函数，使用SI工具去索引时经常索引到不对的函数处（回忆下当时start.S中找lowlevel_init.S时，自动索引找到的是错误的，真正的反而根本没找到。）

（3）console_init_r就是console的纯软件架构方面的初始化（说白了就是去给console相关的数据结构中填充相应的值），所以属于纯软件配置类型的初始化。

（4）uboot的console实际上并没有干有意义的转化，它就是直接调用的串口通信的函数。所以用不用console实际并没有什么分别。（在linux内console就可以提供缓冲机制等不用console不能实现的东西）。

### 6.4.10、enable_interrupts

（1）看名字应该是中断初始化代码。这里指的是CPSR中总中断标志位的使能。

（2）因为我们uboot中没有使用中断，因此没有定义CONFIG_USE_IRQ宏，因此我们这里这个函数是个空壳子。

（3）uboot中经常出现一种情况就是根据一个宏是否定义了来条件编译决定是否调用一个函数内部的代码。uboot中有2种解决方案来处理这种情况：方案一：在调用函数处使用条件编译，然后函数体实际完全提供代码。方案二：在调用函数处直接调用，然后在函数体处提供2个函数体，一个是有实体的一个是空壳子，用宏定义条件编译来决定实际编译时编译哪个函数进去。

### 6.4.11、loadaddr、bootfile两个环境变量

（1）这两个环境变量都是内核启动有关的，在启动linux内核时会参考这两个环境变量的值。

### 6.4.12、board_late_init

（1）看名字这个函数就是开发板级别的一些初始化里比较晚的了，就是晚期初始化。所以晚期就是前面该初始化的都初始化过了，剩下的一些必须放在后面初始化的就在这里了。侧面说明了开发板级别的硬件软件初始化告一段落了。

（2）对于X210来说，这个函数是空的。

### 6.4.13、eth_initialize

（1）看名字应该是网卡相关的初始化。这里不是SoC与网卡芯片连接时SoC这边的初始化，而是网卡芯片本身的一些初始化。

（2）对于X210（DM9000）来说，这个函数是空的。X210的网卡初始化在board_init函数中，网卡芯片的初始化在驱动中。

### 6.4.14、x210_preboot_init（LCD和logo显示）

（1）x210开发板在启动起来之前的一些初始化，以及LCD屏幕上的logo显示。

### 6.4.15、check menukey to update from sd

（1）uboot启动的最后阶段设计了一个自动更新的功能。就是：我们可以将要升级的镜像放到SD卡的固定目录中，然后开机时在uboot启动的最后阶段检查升级标志（是一个按键。按键中标志为"LEFT"的那个按键，这个按键如果按下则表示update mode，如果启动时未按下则表示boot mode）。如果进入update mode则uboot会自动从SD卡中读取镜像文件然后烧录到iNand中；如果进入boot mode则uboot不执行update，直接启动正常运行。

（2）这种机制能够帮助我们快速烧录系统，常用于量产时用SD卡进行系统烧录部署。

### 6.4.16、死循环

（1）解析器

（2）开机倒数自动执行

（3）命令补全

******

## 6.5、uboot启动2阶段总结

### 6.5.1、启动流程回顾、重点函数标出

（1）第二阶段主要是对开发板级别的硬件、软件数据结构进行初始化。

（2）第二阶段主要的初始化函数

> init_sequence
> 		cpu_init	空的
> 		board_init	网卡、机器码、内存传参地址
> 			dm9000_pre_init			网卡
> 			gd->bd->bi_arch_number	机器码
> 			gd->bd->bi_boot_params	内存传参地址
> 		interrupt_init	定时器
> 		env_init
> 		init_baudrate	gd数据结构中波特率
> 		serial_init		空的
> 		console_init_f	空的
> 		display_banner	打印启动信息
> 		print_cpuinfo	打印CPU时钟设置信息
> 		checkboard		检验开发板名字
> 		dram_init		gd数据结构中DDR信息
> 		display_dram_config	打印DDR配置信息表
> 	mem_malloc_init		初始化uboot自己维护的堆管理器的内存
> 	mmc_initialize		inand/SD卡的SoC控制器和卡的初始化
> 	env_relocate		环境变量重定位
> 	gd->bd->bi_ip_addr	gd数据结构赋值
> 	gd->bd->bi_enetaddr	gd数据结构赋值
> 	devices_init		空的
> 	jumptable_init		不用关注的
> 	console_init_r		真正的控制台初始化
> 	enable_interrupts	空的
> 	loadaddr、bootfile 	环境变量读出初始化全局变量
> 	board_late_init		空的
> 	eth_initialize		空的
> 	x210_preboot_init	LCD初始化和显示logo
> 	check_menu_update_from_sd	检查自动更新
> 	main_loop			主循环

	### 6.5.2、启动过程特征总结

（1）第一阶段为汇编阶段、第二阶段为C阶段
（2）第一阶段在SRAM中、第二阶段在DRAM中
（3）第一阶段注重SoC内部、第二阶段注重SoC外部Board内部

### 6.5.3、移植时的注意点

（1）x210_sd.h头文件中的宏定义
（2）特定硬件的初始化函数位置（譬如网卡）

*****

# 7、uboot源码分析–uboot如何启动内核

## 7.1、uboot和内核是什么

### 7.1.1、uboot是一个裸机程序

（1）uboot的本质就是一个复杂点的裸机程序。和我们在ARM裸机全集中学习的每一个裸机程序并没有本质区别。

（2）ARM裸机第十六部分写了个简单的shell，这东西其实就是个mini型的uboot。

### 7.1.2、内核本身也是一个"裸机程序"

（1）操作系统内核本身就是一个裸机程序，和uboot、和其他裸机程序并没有本质区别。

（2）区别就是操作系统运行起来后在软件上分为内核层和应用层，分层后两层的权限不同，内存访问和设备操作的管理上更加精细（内核可以随便访问各种硬件，而应用程序只能被限制的访问硬件和内存地址）。

直观来看：uboot的镜像是u-boot.bin，linux系统的镜像是zImage，这两个东西其实都是两个裸机程序镜像。从系统的启动角度来讲，内核其实就是一个大的复杂点裸机程序。

### 7.1.3、部署在SD卡中特定分区内

（1）一个完整的软件+硬件的嵌入式系统，静止时（未上电时）bootloader、kernel、rootfs等必须的软件都以镜像的形式存储在启动介质中（X210中是iNand/SD卡）；运行时都是在DDR内存中运行的，与存储介质无关。上面2个状态都是稳定状态，第3个状态是动态过程，即从静止态到运行态的过程，也就是启动过程。

（2）动态启动过程就是一个从SD卡逐步搬移到DDR内存，并且运行启动代码进行相关的硬件初始化和软件架构的建立，最终达到运行时稳定状态。

（3）静止时u-boot.bin zImage rootfs都在SD卡中，他们不可能随意存在SD卡的任意位置，因此需要对SD卡进行一个分区，然后将各种镜像各自存在各自的分区中，这样在启动过程中uboot、内核等就知道到哪里去找谁。（uboot和kernel中的分区表必须一致，同时和SD卡的实际使用的分区要一致）

### 7.1.4、运行时必须先加载到DDR中链接地址处

（1）uboot在第一阶段中进行重定位时将第二阶段（整个uboot镜像）加载到DDR的0xc3e00000地址处，这个地址就是uboot的链接地址。

（2）内核也有类似要求，uboot启动内核时将内存从SD卡读取放到DDR中（其实就是个重定位的过程），不能随意放置，必须放在内核的链接地址处，否则启动不起来。譬如我们使用的内核链接地址是0x30008000。

### 7.1.5、内核启动需要必要的启动参数

（1）uboot是无条件启动的，从零开始启动的。

（2）内核是不能开机自动完全从零开始启动的，内核启动要别人帮忙。uboot要帮助内核实现重定位（从SD卡到DDR），uboot还要给内核提供启动参数。

*****

## 7.2、启动内核第一步：加载内核到DDR中

（1）uboot要启动内核，分为2个步骤：第一步是将内核镜像从启动介质中加载到DDR中，第二步是去DDR中启动内核镜像。（内核代码根本就没考虑重定位，因为内核知道会有uboot之类的把自己加载到DDR中链接地址处的，所以内核直接就是从链接地址处开始运行的）

### 7.2.1、静态内核镜像在哪里

（1）SD卡/iNand/Nand/NorFlash等：raw分区
常规启动时各种镜像都在SD卡中，因此uboot只需要从SD卡的kernel分区去读取内核镜像到DDR中即可。读取要使用uboot的命令来读取（譬如X210的iNand版本是movi命令，X210的Nand版本就是Nand命令）

（2）这种启动方式来加载ddr，使用命令：movi read kernel 30008000。其中kernel指的是uboot中的kernel分区（就是uboot中规定的SD卡中的一个区域范围，这个区域范围被设计来存放kernel镜像，就是所谓的kernel分区）

 （3）tftp、nfs等网络下载方式从远端服务器获取镜像

uboot还支持远程启动，也就是内核镜像不烧录到开发板的SD卡中，而是放在主机的服务器中，然后需要启动时uboot通过网络从服务器中下载镜像到开发板的DDR中。

分析总结：最终结果要的是内核镜像到DDR中特定地址即可，不管内核镜像是怎么到DDR中的。以上2种方式各有优劣。产品出厂时会设置为从SD卡中启动（客户不会还要搭建tftp服务器才能用···）；tftp下载远程启动这种方式一般用来开发。

### 7.2.3、镜像要放在DDR的什么地址

（1）内核一定要放在链接地址处，链接地址去内核源代码的链接脚本或者Makefile中去查找。X210中是0x30008000。

****

## 7.3、zImage和uImage的区别联系

### 7.3.1、bootm命令对应do_bootm函数

（1）命令名前加do_即可构成这个命令对应的函数，因此当我们bootm命令执行时，uboot实际执行的函数叫do_bootm函数，在cmd_bootm.c。

（2）do_bootm刚开始定义了一些变量，然后用宏来条件编译执行了secureboot的一些代码（主要进行签名认证），先不管他；然后进行了一些一些细节部分操作，也不管他。然后到了CONFIG_ZIMAGE_BOOT，用这个宏来控制进行条件编译一段代码，这段代码是用来支持zImage格式的内核启动的。

### 7.3.2、vmlinuz和zImage和uImage

（1）uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是可以直接执行的。但是这种格式不能用来烧录下载。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。

（2）linux内核经过编译后也会生成一个elf格式的可执行程序，叫vmlinux或vmlinuz，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫Image（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。

（3）原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。

（4）uboot为了启动linux内核，还发明了一种内核格式叫uImage。uImage是由zImage加工得到的，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。

（5）原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是所有的uboot肯定都支持uImage启动。

### 7.3.3、编译内核得到uImage去启动

（1）如果直接在kernel底下去make uImage会提供mkimage command not found。解决方案是去uboot/tools下cp mkimage /usr/local/bin/，复制mkimage工具到系统目录下。再去make uImage即可。

******

## 7.4、zImage启动细节

（1）do_bootm函数中一直到397行的after_header_check这个符号处，都是在进行镜像的头部信息校验。校验时就要根据不同种类的image类型进行不同的校验。所以do_bootm函数的核心就是去分辨传进来的image到底是什么类型，然后按照这种类型的头信息格式去校验。校验通过则进入下一步准备启动内核；如果校验失败则认为镜像有问题，所以不能启动。

### 7.4.1、LINUX_ZIMAGE_MAGIC

（1）这个是一个定义的魔数，这个数等于0x016f2818，表示这个镜像是一个zImage。也就是说zImage格式的镜像中在头部的一个固定位置存放了这个数作为格式标记。如果我们拿到了一个image，去他的那个位置去取4字节判断它是否等于LINUX_ZIMAGE_MAGIC，则可以知道这个镜像是不是一个zImage。

（2）命令 bootm 0x30008000，所以do_boom的argc=2，argv[0]=bootm  argv[1]=0x30008000。但是实际bootm命令还可以不带参数执行。如果不带参数直接bootm，则会从CFG_LOAD_ADDR地址去执行（定义在x210_sd.h中）。

（3）zImage头部开始的第37-40字节处存放着zImage标志魔数，从这个位置取出然后对比LINUX_ZIMAGE_MAGIC。可以用二进制阅读软件来打开zImage查看，就可以证明。很多软件都可以打开二进制文件，如winhex、UltraEditor。

### 7.4.2、image_header_t

（1）这个数据结构是我们uboot启动内核使用的一个标准启动数据结构，zImage头信息也是一个image_header_t，但是在实际启动之前需要进行一些改造。hdr->ih_os = IH_OS_LINUX;
		hdr->ih_ep = ntohl(addr);这两句就是在进行改造。

（2）images全局变量是do_bootm函数中使用，用来完成启动过程的。zImage的校验过程其实就是先确认是不是zImage，确认后再修改zImage的头信息到合适，修改后用头信息去初始化images这个全局变量，然后就完成了校验。

*****

## 7.5、uImage启动

### 7.5.1、uImage启动

（1）LEGACY(遗留的)，在do_bootm函数中，这种方式指的就是uImage的方式。

（2）uImage方式是uboot本身发明的支持linux启动的镜像格式，但是后来这种方式被一种新的方式替代，这个新的方式就是设备树方式（在do_bootm方式中叫FIT）

（3）uImage的启动校验主要在boot_get_kernel函数中，主要任务就是校验uImage的头信息，并且得到真正的kernel的起始位置去启动。

### 7.5.2、总结

总结1：uboot本身设计时只支持uImage启动，原来uboot的代码也是这样写的。后来有了fdt方式之后，就把uImage方式命令为LEGACY方式，fdt方式命令为FIT方式，于是乎多了写#if #endif添加的代码。后来移植的人又为了省事添加了zImage启动的方式，又为了省事把zImage启动方式直接写在了uImage和fdt启动方式之前，于是乎又有了一对#if  #endif。于是乎整天的代码看起来很恶心。
总结2：第二阶段校验头信息结束，下面进入第三阶段，第三阶段主要任务是启动linux内核，调用do_bootm_linux函数来完成。

*****

## 7.6、do_bootm_linux函数

### 7.6.1、找到do_bootm_linux函数

（1）函数在uboot/lib_arm/bootm.c中。

（2）SI找不到（是黑色的）不代表就没有，要搜索一下才能确定；搜索不到也不能代表就没有，因为我们在向SI工程中添加文件时，SI只会添加它能识别的文件格式的文件，有一些像Makefile、xx.conf等Makefile不识别的文件是没有被添加的。所以如果要搜索的关键字在makefile中或者脚本中，可能就是搜索不到的。（譬如TEXT_BASE）

### 7.6.2、镜像的entrypoint

（1）ep就是entrypoint的缩写，就是程序入口。一个镜像文件的起始执行部分不是在镜像的开头（镜像开头有n个字节的头信息），真正的镜像文件执行时第一句代码在镜像的中部某个字节处，相当于头是有一定的偏移量的。这个偏移量记录在头信息中。

（2）一般执行一个镜像都是：第一步先读取头信息，然后在头信息的特定地址找MAGIC_NUM，由此来确定镜像种类；第二步对镜像进行校验；第三步再次读取头信息，由特定地址知道这个镜像的各种信息（镜像长度、镜像种类、入口地址）；第四步就去entrypoint处开始执行镜像。

（3）theKernel = (void (*)(int, int, uint))ep;将ep赋值给theKernel，则这个函数指向就指向了内存中加载的OS镜像的真正入口地址（就是操作系统的第一句执行的代码）。

### 7.6.3、机器码的再次确定

（1）uboot在启动内核时，机器码要传给内核。uboot传给内核的机器码是怎么确定的？第一顺序备选是环境变量machid，第二顺序备选是gd->bd->bi_arch_num（x210_sd.h中硬编码配置的）

### 7.6.4、传参并启动概述

（1）从110行到144行就是uboot在给linux内核准备传递的参数处理。

（2）Starting kernel ...  这个是uboot中最后一句打印出来的东西。这句如果能出现，说明uboot整个是成功的，也成功的加载了内核镜像，也校验通过了，也找到入口地址了，也试图去执行了。如果这句后串口就没输出了，说明内核并没有被成功执行。原因一般是：传参（80%）、内核在DDR中的加载地址·······

****

## 7.7、传参详解

### 7.7.1、tag方式传参

（1）struct tag，tag是一个数据结构，在uboot和linux kernel中都有定义tag数据机构，而且定义是一样的。

（2）tag_header和tag_xxx。tag_header中有这个tag的size和类型编码，kernel拿到一个tag后先分析tag_header得到tag的类型和大小，然后将tag中剩余部分当作一个tag_xxx来处理。

（3）tag_start与tag_end。kernel接收到的传参是若干个tag构成的，这些tag由tag_start起始，到tag_end结束。

（4）tag传参的方式是由linux kernel发明的，kernel定义了这种向我传参的方式，uboot只是实现了这种传参方式从而可以支持给kernel传参。

```c
struct tag {
        struct tag_header hdr;
        union { 
                struct tag_core         core;
                struct tag_mem32        mem;
                struct tag_videotext    videotext;
                struct tag_ramdisk      ramdisk;
                struct tag_initrd       initrd;
                struct tag_serialnr     serialnr;
                struct tag_revision     revision;
                struct tag_videolfb     videolfb;
                struct tag_cmdline      cmdline;
                
                /*
                * Acorn specific
                */
                struct tag_acorn        acorn;
                
                /*
                 * DC21285 specific
                 */
                struct tag_memclk       memclk;
                
                struct tag_mtdpart      mtdpart_info;
        } u;
};
```



### 7.7.2、x210_sd.h中配置传参宏

（1）CONFIG_SETUP_MEMORY_TAGS，tag_mem，传参内容是内存配置信息。

（2）CONFIG_CMDLINE_TAG，tag_cmdline，传参内容是启动命令行参数，也就是uboot环境变量的bootargs.

（3）CONFIG_INITRD_TAG

（4）CONFIG_MTDPARTITION，传参内容是iNand/SD卡的分区表。

（5）起始tag是ATAG_CORE、结束tag是ATAG_NONE，其他的ATAG_XXX都是有效信息tag。

思考：内核如何拿到这些tag？
uboot最终是调用theKernel函数来执行linux内核的，uboot调用这个函数（其实就是linux内核）时传递了3个参数。这3个参数就是uboot直接传递给linux内核的3个参数，通过寄存器来实现传参的。（第1个参数就放在r0中，第二个参数放在r1中，第3个参数放在r2中）第1个参数固定为0，第2个参数是机器码，第3个参数传递的就是大片传参tag的首地址。

### 7.7.3、移植时注意事项

（1）uboot移植时一般只需要配置相应的宏即可

（2）kernel启动不成功，注意传参是否成功。传参不成功首先看uboot中bootargs设置是否正确，其次看uboot是否开启了相应宏以支持传参。

*****

## 7.8、uboot启动内核的总结

### 7.8.1、启动4步骤

第一步：将内核搬移到DDR中
第二步：校验内核格式、CRC等
第三步：准备传参
第四步：跳转执行内核

（1）涉及到的主要函数是：do_boom和do_bootm_linux

（2）uboot能启动的内核格式：zImage uImage fdt方式

（3）跳转与函数指针的方式运行内核

******

# 8、uboot源码分析–uboot的命令体系

## 8.1、uboot命令体系基础

### 8.1.1、使用uboot命令

（1）uboot启动后进入命令行环境下，在此输入命令按回车结束，uboot会收取这个命令然后解析，然后执行。

### 8.1.2、uboot命令体系实现代码在哪里

（1）uboot命令体系的实现代码在uboot/common/cmd_xxx.c中。有若干个.c文件和命令体系有关。（还有command.c  main.c也是和命令有关的）

### 8.1.3、每个命令对应一个函数

（1）每一个uboot的命令背后都对应一个函数。这就是uboot实现命令体系的一种思路和方法。这个东西和我们在裸机第十六部分shell中实现shell命令的方法是一样的。

（2）我们要找到每一个命令背后所对应的那个函数，而且要分析这个函数和这个命令是怎样对应起来的。

### 8.1.4、命令参数以argc&argv传给函数

（1）有些uboot的命令还支持传递参数。也就是说命令背后对应的函数接收的参数列表中有argc和argv，然后命令体系会把我们执行命令时的命令+参数（md 30000000 10）以argc（3）和argv（argv[0]=md, argv[1]=30000000 argv[2]=10）的方式传递给执行命令的函数。

举例分析，以help命令为例：
help命令背后对应的函数名叫：do_help。在uboot/common/command.c的236行。int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])

****

## 8.2、uboot命令解析和执行过程分析

### 8.2.1、从main_loop说起

（1）uboot启动的第二阶段，在初始化了所有该初始化的东西后，进入了一个死循环，死循环的循环体就是main_loop。

（2）main_loop函数执行一遍，就是一个获取命令、解析命令、执行命令的过程。

（3）run_command函数就是用来执行命令的函数。

### 8.2.2、run_command函数详解

（1）控制台命令获取 
（2）命令解析。parse_line函数把"md 30000000 10"解析成argv[0]=md, argv[1]=30000000 argv[2]=10;
（3）命令集中查找命令。find_cmd(argv[0])函数去uboot的命令集合当中搜索有没有argv[0]这个命令，
（4）执行命令。最后用函数指针的方式调用执行了对应函数。

思考：关键点就在于find_cmd函数如何查找到这个命令是不是uboot的合法支持的命令？这取决于uboot的命令体系机制（uboot是如何完成命令的这一套设计的，命令如何去注册、存储、管理、索引。）。

****

## 8.3、uboot如何处理命令集

### 8.3.1、可能的管理方式

（1）数组。结构体数组，数组中每一个结构体成员就是一个命令的所有信息。

（2）链表。链表的每个节点data段就是一个命令结构体，所有的命令都放在一条链表上。这样就解决了数组方式的不灵活。坏处是需要额外的内存开销，然后各种算法（遍历、插入、删除等）需要一定复杂度的代码执行。

（2）有第三种吗？uboot没有使用数组或者链表，而是使用了一种新的方式来实现这个功能。

### 8.3.2、命令结构体cmd_tbl_t

```c
struct cmd_tbl_s {
	char		*name;		/* Command Name			*/
	int		maxargs;	/* maximum number of arguments	*/
	int		repeatable;	/* autorepeat allowed?		*/
					/* Implementation function	*/
	int		(*cmd)(struct cmd_tbl_s *, int, int, char *[]);
	char		*usage;		/* Usage message	(short)	*/
#ifdef	CFG_LONGHELP
	char		*help;		/* Help  message	(long)	*/
#endif
#ifdef CONFIG_AUTO_COMPLETE
	/* do auto completion on the arguments */
	int		(*complete)(int argc, char *argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
typedef struct cmd_tbl_s	cmd_tbl_t;

```

（1）name：命令名称，字符串格式。
（2）maxargs：命令最多可以接收多少个参数
（3）repeatable：指示这个命令是否可重复执行。重复执行是uboot命令行的一种工作机制，就是直接按回车则执行上一条执行的命令。
（4）cmd：函数指针，命令对应的函数的函数指针，将来执行这个命令的函数时使用这个函数指针来调用。
（5）usage：命令的短帮助信息。对命令的简单描述。
（6）help：命令的长帮助信息。细节的帮助信息。
（7）complete：函数指针，指向这个命令的自动补全的函数。
总结：uboot的命令体系在工作时，一个命令对应一个cmd_tbl_t结构体的一个实例，然后uboot支持多少个命令，就需要多少个结构体实例。uboot的命令体系把这些结构体实例管理起来，当用户输入了一个命令时，uboot会去这些结构体实例中查找（查找方法和存储管理的方法有关）。如果找到则执行命令，如果未找到则提示命令未知。

### 8.3.3、uboot实现命令管理的思路

（1）填充1个结构体实例构成一个命令

（2）给命令结构体实例附加特定段属性（用户自定义段），链接时将带有该段属性的内容链接在一起排列（挨着的，不会夹杂其他东西，也不会丢掉一个带有这种段属性的，但是顺序是乱序的）。

（3）uboot重定位时将该段整体加载到DDR中。加载到DDR中的uboot镜像中带有特定段属性的这一段其实就是命令结构体的集合，有点像一个命令结构体数组。

（4）段起始地址和结束地址（链接地址、定义在u-boot.lds中）决定了这些命令集的开始和结束地址。

### 8.3.4、uboot命令定义具体实现分析

（1）U_BOOT_CMD宏基本分析
这个宏定义在uboot/common/command.h中。
U_BOOT_CMD(
	version,	1,		1,	do_version,
	"version - print monitor version\n",
	NULL
);
这个宏替换后变成：
cmd_tbl_t __ u_boot_cmd_version __ attribute__ ((unused,section (".u_boot_cmd"))) = {#name, maxargs, rep, cmd, usage, help}

__ attribute__ ((unused,section (".u_boot_cmd")))：意思就是将我们定义的变量赋予一个段属性，贴上了一个.u_boot_cmd段里 

#name：将#号后面的变量转换为字符串

总结：这个U_BOOT_CMD宏的理解，关键在于结构体变量的名字和段属性。名字使用##作为连字符，附加了用户自定义段属性，以保证链接时将这些数据结构链接在一起排布。
(2)链接脚本。

### 8.3.5、find_cmd函数详解

（1）find_cmd函数的任务是从当前uboot的命令集中查找是否有某个命令。如果找到则返回这个命令结构体的指针，如果未找到返回NULL。

（2）函数的实现思路很简单，如果不考虑命令带点的情况（md.b md.w这种）就更简单了。查找命令的思路其实就是for循环遍历数组的思路，不同的是数组的起始地址和结束地址是用地址值来给定的，数组中的元素个数是结构体变量类型。

### 8.3.6、U_BOOT_CMD宏详解

（1）这个宏其实就是定义了一个命令对应的结构体变量，这个变量名和宏的第一个参数有关，因此只要宏调用时传参的第一个参数不同则定义的结构体变量不会重名。

****

## 8.4、uboot中增加自定义命令

### 8.4.1、在已有的c文件中直接添加命令

（1）在uboot/common/command.c中添加一个命令，叫：mycmd

（2）在已有的.c文件中添加命令比较简单，直接使用U_BOOT_CMD宏即可添加命令，给命令提供一个do_xxx的对应的函数这个命令就齐活了。

（3）添加完成后要重新编译工程（make distclean; make x210_sd_config; make），然后烧录新的uboot去运行即可体验新命令。

（4）还可以在函数中使用argc和argv来验证传参。

```c
//参考源代码中命令的添加方式
int
do_version (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	extern char version_string[];
	printf ("\n%s\n", version_string);
	return 0;
}

U_BOOT_CMD(			//向定义一个宏来指点添加的命令的信息和函数
	version,	1,		1,	do_version,
	"version - print monitor version\n",
	NULL
);
```

```c
//自己添加一个简单命令
int
do_mycmd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	printf ("\n%s\n", "this is a test for add cmd to uboot");
	return 0;
}

U_BOOT_CMD(
	mycmd,	1,		1,	mycmd,
	"mycmd - usage of my cmd\n",		//短描述
	"long help of mycmd\n"				//长描述
);
```

### 8.4.2、自建一个c文件并添加命令

（1）在uboot/common目录下新建一个命令文件，叫cmd_aston.c（对应的命令名就叫aston，对应的函数就叫do_aston函数），然后在c文件中添加命令对应的U_BOOT_CMD宏和函数。注意头文件包含不要漏掉。

（2）在uboot/common/Makefile中添加上aston.o，目的是让Make在编译时能否把cmd_aston.c编译链接进去。

（3）重新编译烧录。重新编译步骤是：make distclean; make x210_sd_config; make

```c
#include <common.h>
#include <command.h>

int
do_mycmd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	printf ("\n%s\n", "this is a test for add cmd to uboot");
	return 0;
}

U_BOOT_CMD(
	mycmd,	1,		1,	mycmd,
	"mycmd - usage of my cmd\n",		//短描述
	"long help of mycmd\n"				//长描述
);
```



### 8.4.3、体会：uboot命令体系的优点

（1）uboot的命令体系本身稍微复杂，但是他写好之后就不用动了。我们后面在移植uboot时也不会去动uboot的命令体系。我们最多就是向uboot中去添加命令，就像本节课所做的这样。

（2）向uboot中添加命令非常简单。

******

# 9、uboot源码分析–uboot的环境变量

## 9.1、uboot的环境变量基础

### 9.1.1、环境变量的作用

（1）让我们可以不用修改uboot的源代码，而是通过修改环境变量来影响uboot运行时的一些数据和特性。譬如说通过修改bootdelay环境变量就可以更改系统开机自动启动时倒数的秒数。

### 9.1.2、环境变量的优先级

（1）uboot代码当中有一个值，环境变量中也有一个值。uboot程序实际运行时规则是：如果环境变量为空则使用代码中的值；如果环境变量不为空则优先使用环境变量对应的值。

（2）譬如machid（机器码）。uboot中在x210_sd.h中定义了一个机器码2456，写死在程序中的不能更改。如果要修改uboot中配置的机器码，可以修改x210_sd.h中的机器码，但是修改源代码后需要重新编译烧录，很麻烦；比较简单的方法就是使用环境变量machid。set machid 0x998类似这样，有了machid环境变量后，系统启动时会优先使用machid对应的环境变量，这就是优先级问题。

### 9.1.3、环境变量在uboot中工作方式

（1）默认环境变量，在uboot/common/env_common.c中default_environment，这东西本质是一个字符数组，大小为CFG_ENV_SIZE（16kb），里面内容就是很多个环境变量连续分布组成的，每个环境变量最末端以'\0'结束。

（2）SD卡中环境变量分区，在uboot的raw分区中。SD卡中其实就是给了个分区，专门用来存储而已。存储时其实是把DDR中的环境变量整体的写入SD卡中分区里。所以当我们saveenv时其实整个所有的环境变量都被保存了一遍，而不是只保存更改了的。

（3）DDR中环境变量，在default_environment中，实质是字符数组。在uboot中其实是一个全局变量，链接时在数据段，重定位时default_environment就被重定位到DDR中一个内存地址处了。这个地址处这个全局字符数组就是我们uboot运行时的DDR中的环境变量了。

总结：刚烧录的系统中环境变量分区是空白的，uboot第一次运行时加载的是uboot代码中自带的一份环境变量，叫默认环境变量。我们在saveenv时DDR中的环境变量会被更新到SD卡中的环境变量中，就可以被保存下来，下次开机会在环境变量relocate时会SD卡中的环境变量会被加载到DDR中去。

default_environment中的内容虽然被uboot源代码初始化为一定的值（这个值就是我们的默认环境变量），但是在uboot启动的第二阶段，env_relocate时代码会去判断SD卡中的env分区的crc是否通过。如果crc校验通过说明SD卡中有正确的环境变量存储，则relocate函数会从SD卡中读取环境变量来覆盖default_environment字符数组，从而每次开机可以保持上一次更改过的环境变量。

****

## 9.2、环境变量相关命令源码解析

### 9.2.1、printenv

（1）找到printenv命令所对应的函数。通过printenv的help可以看出，这个命令有2种使用方法。第一种直接使用不加参数则打印所有的环境变量；第二种是printenv name则只打印出name这个环境变量的值。

（2）分析do_printenv函数。

（3）do_printenv函数首先区分argc=1还是不等于1的情况，若argc=1那么就循环打印所有的环境变量出来；如果argc不等于1，则后面的参数就是要打印的环境变量，给哪个就打印哪个。

（4）argc=1时用双重for循环来依次处理所有的环境变量的打印。第一重for循环就是处理各个环境变量。所以有多少个环境变量则第一重就执行循环多少圈。

（5）这个函数要看懂，首先要明白整个环境变量在内存中如何存储的问题。

（6）关键点：第一要明白环境变量在内存中存储的方式；第二要C语言处理字符串的功底要好。

```c
for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
    for (nxt=i; env_get_char(nxt) != '\0'; ++nxt);//将nxt指向第一个'\0'
    for (k=i; k<nxt; ++k)
        putc(env_get_char(k));
    putc  ('\n');

    if (ctrlc()) {
        puts ("\n ** Abort\n");
        return 1;
    }
}
```



### 9.2.2、setenv

（1）命令定义和对应的函数在uboot/common/cmd_nvedit.c中，对应的函数为do_setenv。

（2）setenv的思路就是：先去DDR中的环境变量处寻找原来有没有这个环境变量，如果原来就有则需要覆盖原来的环境变量，如果原来没有则在最后新增一个环境变量即可。
第1步：遍历DDR中环境变量的数组，找到原来就有的那个环境变量对应的地址。168-174行。
第2步：擦除原来的环境变量，259-265行
第3步：写入新的环境变量，266-273行。

（3）本来setenv做完上面的就完了，但是还要考虑一些附加的问题。
问题一：环境变量太多超出DDR中的字符数组，溢出的解决方法。
问题二：有些环境变量如baudrate、ipaddr等，在gd中有对应的全局变量。这种环境变量在set更新的时候要同时去更新对应的全局变量，否则就会出现在本次运行中环境变量和全局变量不一致的情况。

### 9.2.3、saveenv

（1）在uboot/common/cmd_nvedit.c中，对应函数为do_saveenv

（2）从uboot实际执行saveenv命令的输出，和x210_sd.h中的配置（#define CFG_ENV_IS_IN_AUTO）可以分析出：我们实际使用的是env_auto.c中相关的内容。没有一种芯片叫auto的，env_auto.c中是使用宏定义的方式去条件编译了各种常见的flash芯片（如movinand、norflash、nand等）。然后在程序中读取INF_REG（OMpin内部对应的寄存器）从而知道我们的启动介质，然后调用这种启动介质对应的操作函数来操作。

（3）do_saveenv内部调用env_auto.c中的saveenv函数来执行实际的环境变量保存操作。

（4）寄存器地址：E010F000+0C=E010_F00C，含义是用户自定义数据。我们在start.S中判断启动介质后将#BOOT_MMCSD（就是3，定义在x210_sd.h）写入了这个寄存器，所以这里读出的肯定是3，经过判断就是movinand。所以实际执行的函数是：saveenv_movinand

（5）真正执行保存环境变量操作的是：cpu/s5pc11x/movi.c中的movi_write_env函数，这个函数肯定是写sd卡，将DDR中的环境变量数组（其实就是default_environment这个数组，大小16kb，刚好32个扇区）写入iNand中的ENV分区中。

（6）raw_area_control是uboot中规划iNnad/SD卡的原始分区表，这个里面记录了我们对iNand的分区，env分区也在这里，下标是2.追到这一层就够了，再里面就是调用驱动部分的写SD卡/iNand的底层函数了。

*****

## 9.3、uboot内部获取环境变量

### 9.3.1、getenv

（1）应该是不可重入的。

（2）实现方式就是去遍历default_environment数组，挨个拿出所有的环境变量比对name，找到相等的直接返回这个环境变量的首地址即可。

### 9.3.2、getenv_r

（1）可重入版本。（可自行搜索补充可重入函数的概念）

（2）getenv函数是直接返回这个找到的环境变量在DDR中环境变量处的地址，而getenv_r函数的做法是找到了DDR中环境变量地址后，将这个环境变量复制一份到提供的buf中，而不动原来DDR中环境变量。
所以差别就是：getenv中返回的地址只能读不能随便乱写，而getenv_r中返回的环境变量是在自己提供的buf中，是可以随便改写加工的。

### 9.3.3、总结

（1）功能是一样的，但是可重入版本会比较安全一些，建议使用。

（2）有关于环境变量的所有操作，主要理解了环境变量在DDR中的存储方法，理解了环境变量和gd全局变量的关联和优先级，理解了环境变量在存储介质中的存储方式（专用raw分区），整个环境变量相关的都清楚了。

****

# 10、uboot源码分析–uboot的硬件驱动部分

## 10.1、uboot与linux驱动

### 10.1.1、uboot本身是裸机程序

（1）裸机本来是没有驱动的概念的（狭义的驱动的概念就是操作系统中用来具体操控硬件的那部分代码叫驱动）

（2）裸机程序中是直接操控硬件的，操作系统中必须通过驱动来操控硬件。这两个有什么区别？本质区别就是分层。

### 10.1.2、uboot的虚拟地址对硬件操作的影响

（1）操作系统（指的是linux）下MMU肯定是开启的，也就是说linux驱动中肯定都使用的是虚拟地址。而纯裸机程序中根本不会开MMU，全部使用的是物理地址。这是裸机下和驱动中操控硬件的一个重要区别。

（2）uboot早期也是纯物理地址工作的，但是现在的uboot开启了MMU做了虚拟地址映射，这个东西驱动也必须考虑。查uboot中的虚拟地址映射表，发现除了0x30000000-0x3FFFFFFF映射到了0xC0000000-0xCFFFFFFF之外，其余的虚拟地址空间全是原样映射的。而我们驱动中主要是操控硬件寄存器，而S5PV210的SFR都在0xExxxxxx地址空间，因此驱动中不必考虑虚拟地址。

### 10.1.3、uboot借用（移植）了linux驱动

（1）linux驱动本身做了模块化设计。linux驱动本身和linux内核不是强耦合的，这是linux驱动可以被uboot借用（移植）的关键。

（2）uboot移植了linux驱动源代码。uboot是从源代码级别去移植linux驱动的，这就是linux系统的开源性。

（3）uboot中的硬件驱动比linux简单。linux驱动本身有更复杂的框架，需要实现更多的附带功能，而uboot本质上只是个裸机程序，uboot移植linux驱动时只是借用了linux驱动的一部分而已。

****

## 10.2、iNand/SD驱动解析1

### 10.2.1、从start_armboot开始

（1）驱动整体比较庞大，涉及很多个文件夹下的很多文件，函数更多，贸然插入根本不知道看哪里。学习时必须有顺序。

### 10.2.2、mmc_initialize

（1）函数位于：uboot/drivers/mmc/mmc.c。

（2）从名字可以看出，这个函数的作用就是初始化开发板上MMC系统。MMC系统的初始化应该包含这么几部分：SoC里的MMC控制器初始化（MMC系统时钟的初始化、SFR初始化）、SoC里MMC相关的GPIO的初始化、SD卡/iNand芯片的初始化。

（3）mmc_devices链表全局变量，用来记录系统中所有已经注册的SD/iNand设备。所以向系统中插入一个SD卡/iNand设备，则系统驱动就会向mmc_devices链表中插入一个数据结构表示这个设备。

### 10.2.3、cpu_mmc_init

（1）函数位于：uboot/cpu/s5pc11x/cpu.c中。实质是通过调用3个函数来完成的。

（2）setup_hsmmc_clock，在uboot/cpu/s5pc11x/setup_hsmmc.c中。看名字函数是用来初始化SoC中MMC控制器中的时钟部分的。

（3）setup_hsmmc_cfg_gpio，在uboot/cpu/s5pc11x/setup_hsmmc.c中。看名字函数是用来配置SoC中MMC控制器相关的GPIO的。

### 10.2.4、smdk_s3c_hsmmc_init

（1）函数位于：uboot/drivers/mmc/s3c_hsmmc.c中。

（2）函数内部通过宏定义USE_MMCx来决定是否调用s3c_hsmmc_initialize来进行具体的初始化操作。

### 10.2.5、s3c_hsmmc_initialize

（1）函数位于：uboot/drivers/mmc/s3c_hsmmc.c中。

（2）定义并且实例化一个struct mmc类型的对象（定义了一个指针，并且给指针指向有意义的内存，或者说给指针分配内存），然后填充它的各种成员，最后调用mmc_register函数来向驱动框架注册这个mmc设备驱动。

（3）mmc_register功能是进行mmc设备的注册，注册方法其实就是将当前这个struct mmc使用链表连接到mmc_devices这个全局变量中去。

（4）我们在X210中定义了USE_MMC0和USE_MMC2，因此在我们的uboot初始化时会调用2次s3c_hsmmc_initialize函数，传递参数分别是0和2，因此完成之后系统中会注册上2个mmc设备，表示当前系统中有2个mmc通道在工作。

（5）至此cpu_mmc_init函数分析完成。

### 10.2.6、find_mmc_device

（1）这个函数位于：uboot/drivers/mmc/mmc.c中。

（2）这个函数其实就是通过mmc设备编号来在系统中查找对应的mmc设备（struct mmc的对象，根据上面分析系统中有2个，编号分别是0和2）。

（3）函数工作原理就是通过遍历mmc_devices链表，去依次寻找系统中注册的mmc设备，然后对比其设备编号和我们当前要查找的设备编号，如果相同则就找到了要找的设备。找到了后调用mmc_init函数来初始化它。

### 10.2.7、mmc_init

（1）函数位于：drivers/mmc/mmc.c中。

（2）分析猜测这个函数应该要进行mmc卡的初始化了（前面已经进行了SoC端控制器的初始化）

（3）函数的调用关系为：
mmc_init
	mmc_go_idle
		mmc_send_cmd
	mmc_send_if_cond
		mmc_send_cmd
	······
具体分析可以看出，mmc_init函数内部就是依次通过向mmc卡发送命令码（CMD0、CMD2那些）来初始化SD卡/iNand内部的控制器，以达到初始化SD卡的目的。

### 10.2.8、总结

（1）至此整个MMC系统初始化结束。

（2）整个MMC系统初始化分为2大部分：SoC这一端的MMC控制器的初始化，SD卡这一端卡本身的初始化。前一步主要是在cpu_mmc_init函数中完成，后一部分主要是在mmc_init函数中完成。

（3）整个初始化完成后去使用sd卡/iNand时，操作方法和mmc_init函数中初始化SD卡的操作一样的方式。读写sd卡时也是通过总线向SD卡发送命令、读取/写入数据来完成的。

（4）顺着操作追下去，到了mmc_send_cmd函数处就断了，真正的向SD卡发送命令的硬件操作的函数找不到。这就是学习驱动的麻烦之处。

（5）struct mmc结构体是关键。两部分初始化之间用mmc结构体来链接的，初始化完了后对mmc卡的常规读写操作也是通过mmc结构体来链接的。

*****

## 10.3、iNand/SD驱动详解2

### 10.3.1、struct mmc

（1）驱动的设计中有一个关键数据结构。譬如MMC驱动的结构体就是struct mmc这些结构体中包含一些变量和一些函数指针，变量用来记录驱动相关的一些属性，函数指针用来记录驱动相关的操作方法。这些变量和函数指针加起来就构成了驱动。驱动就被抽象为这个结构体。

（2）一个驱动工作时主要就分几部分：驱动构建（构建一个struct mmc然后填充它）、驱动运行时（调用这些函数指针指向的函数和变量）

### 10.3.2、分离思想

（1）分离思想就是说在驱动中将操作方法和数据分开。

（2）操作方法就是函数，数据就是变量。所谓操作方法和数据分离的意思就是：在不同的地方来存储和管理驱动的操作方法和变量，这样的优势就是驱动便于移植。

### 10.3.3、分层思想

（1）分层思想是指一个整个的驱动分为好多个层次。简单理解就是驱动分为很多个源文件，放在很多个文件夹中。譬如本课程讲的mmc的驱动涉及到drivers/mmc下面的2个文件和cpu/s5pc11x下的好几个文件。

（2）以mmc驱动为例来分析各个文件的作用：
uboot/drivers/mmc/mmc.c：本文件的主要内容是和MMC卡操作有关的方法，譬如MMC卡设置空闲状态的、卡读写数据等。但是本文件中并没有具体的硬件操作函数，操作最终指向的是struct mmc结构体中的函数指针，这些函数指针是在驱动构建的时候和真正硬件操作的函数挂接的（真正的硬件操作的函数在别的文件中）。
uboot/drivers/mmc/s3c_hsmmc.c:本文件中是SoC内部MMC控制器的硬件操作的方法，譬如向SD卡发送命令的函数（s3c_hsmmc_send_command），譬如和SD卡读写数据的函数（s3c_hsmmc_set_ios），这些函数就是具体操作硬件的函数，也就是mmc.c中需要的那些硬件操作函数。这些函数在mmc驱动初始化构建时（s3c_hsmmc_initialize函数中）和struct mmc挂接起来备用。

分析：mmc.c和s3c_hsmmc.c构成了一个分层，mmc.c中调用了s3c_hsmmc.中的函数，所以mmc.c在上层，s3c_hsmmc.c在下层。这两个分层后我们发现mmc.c中不涉及具体硬件的操作，s3c_hsmmc.c中不涉及驱动工程时的时序操作。因此移植的时候就有好处：譬如我们要把这一套mmc驱动移植到别的SoC上mmc.c就不用动，s3c_hsmmc.c动就可以了；譬如SoC没变但是SD卡升级了，这时候只需要更换mmc.c，不需要更换s3c_hsmmc.即可。

（3）cpu/s5pc11x/下面还有一个setup_hsmmc.c，也和MMC驱动有关。但是这些代码为什么不能放到drivers目录下去，而要放到cpu目录下去？因为这里面的2个函数（setup_hsmmc_clock和setup_hsmmc_cfg_gpio）都是和SoC有关的初始化函数，这两个函数不能放到drivers目录下去。实际上如果非把这两个函数放在uboot/drivers/mmc/s3c_hsmmc.c文件中也凑活能说过去。

*****

# 11、uboot的移植：从三星官方uboot开始移植

## 11.1、移植前的准备工作

### 11.1.1、三星移植过的uboot源代码准备

（1）三星对于S5PV210的官方开发板为SMDKV210，对应的移植过的uboot是：网盘/2.uboot和linux内核移植（努力更新中）\资源下载\三星官方为210移植过的uboot和kernel/android_uboot_smdkv210.tar.bz2

（2）这个源代码网上是下载不到的，三星官方是不会把这些东西放在官网上下载的。这些东西都是随着官方的开发板一起流出的。

### 11.1.2、SourceInsight准备

（1）移植的时候最重要的工作就是看代码、改代码然后编译运行测试。

（2）编译代码必须在linux中（windows共享文件夹中配置uboot不行的），那么看代码和改代码可以在linux中（vim、gedit）也可以在windows中（Sourceinsight）。

（3）我一般习惯的方式是：在windows中解压一份uboot源代码，在linux中也解压一份，注意这两份代码原始情况是一模一样的。然后移植的时候是在windows中这一份中去看代码、改代码；在linux中这一份去编译烧写。这种做法需要在windows中和linux中2份代码之间保持同步（直白点说就是windows中改过了后要把改过的源代码复制到linux中那一份去覆盖linux中那一份里面的同目录同文件）。

（4）问题来了，怎么在windows中和linux中同步代码？通过共享文件夹在linux中进行复制（cp /mnt/hgfs/winshare/xxx.c ./）；通过一些专用工具，譬如sshsecureshell。

### 11.1.3、便捷的文件传输工具sshsecureshell

（1）windows中安装sshsecureshell客户端。

（2）虚拟机上网。不同的ubuntu版本中网卡重启的命令不同，在ubuntu10.04中网卡重启使用：/etc/init.d/networking restart 或者 service network restart就可以；但是在ubuntu14.04中这两个都不行了，要重启网卡需要使用：ifdown eth0 然后ifup eth0即可。

****

## 11.2、ubuntu14.04上网及安装openssh

### 11.2.1、ubuntu14.04上网问题

（1）虚拟机上网有2种模式，NAT和桥接。

（2）虚拟机上网配置要注意这几个地方：第一个要注意选择NAT还是桥接模式；第二个要注意ubuntu中网络配置文件/etc/network/interfaces，这个文件中是配置网卡信息的（譬如静态ip还是dhcp，静态ip地址是多少等）；第三个如果是桥接模式要注意桥接到哪个网卡上（一般笔记本都有2个网卡，一个是有线网卡一个是无线网卡），如果是NAT模式没关系。

（3）ubuntu14.04中重启网卡的命令变了。

（4）演示：NAT方式下上网配置过程。
前提是主机windows通过无线wifi上网了（或者windows通过有线上网也可以）。然后在虚拟机中配置2点：第一选择NAT方式，第二配置/etc/network/inerfaces文件中使用dhcp方式；然后重启网卡，确认ip地址得到后即可上网。

（5）演示：桥接方式上网配置过程。
前提是主机windows通过无线wifi上网了(主机通过有线网卡上网的配置方式有不同)。然后虚拟机中配置注意三点：第一选择桥接方式，第二配置桥接到无线网卡（如果主机windows是通过有线上网的，则桥接到有线网卡）；第三配置/etc/network/inerfaces文件中使用dhcp方式；然后重启网卡，确认ip地址得到后即可上网。

（6）演示：虚拟机要ping通开发板的配置过程。
前提是开发板和电脑之间通过网线连接好。然后虚拟机中配置注意三点：第一选择桥接方式，第二配置桥接到有线网卡（如果配置为自动或者配置桥接到无线网卡则肯定无法ping通开发板）；第三配置/etc/network/inerfaces文件中使用static方式，ip地址配置保证和主机windows、开发板三者处于同一网段；然后重启网卡，确认ip地址得到后即可ping通开发板。

（7）windows系统中有一个bug，如果windows没有检测到有线网卡连接了外部网络则windows中本地连接是不工作的，网卡不工作。解决方案是用网线随便连接一个有联网能力的东西即可，譬如网线连接你的电脑到旁边兄弟的电脑上，譬如插上你的开发板（开发板中运行了linux系统），譬如插上路由器端口。

### 11.2.2、搭建openssh环境

(1)安装ssh-server。(sudo apt-get install openssh-server)如果报错提示依赖错误，可以参考：http://www.cnblogs.com/mliudong/p/4094519.html

(2)securecrt登录
(3)sshsecureshell登录
ssh登录不上，要修改/etc/ssh/sshd_config，参考：http://blog.sina.com.cn/s/blog_5f435c130102v6pv.html。		修改完重启时如果/etc/init.d/ssh restart不起作用，可以使用：ps -e | grep ssh，看sshd的进程号，然后kill -9 进程号杀死ssh进程以达到重启的目的，或者直接重启ubuntu系统

****

## 11.3、移植初体验

### 11.3.1、直接编译三星移植版uboot尝试运行

（1）复制到linux的源生目录下，然后解压开。

（2）检查Makefile中的交叉编译工具链

（3）配置时使用：make smdkv210single_config，对应include/configs/smdkv210single.h头文件。

（4）配置完成后直接make编译，编译完成后就进入烧录步骤。

（5）uboot/sd_fusing目录下有sd_fusing.sh脚本，用来烧录。

### 11.3.2、代码分析&问题查找

运行结果是：第一，串口无输出；第二，开发板供电锁存成功（成功的原因是发现按下电源键之后发现虽然串口工具没有显示但是松开按钮之后底板的灯都还是亮的，说明开发板供电锁存成功）

分析运行结果：uboot中串口最早的输出在"OK"，在lowlevel_init.S中初始化串口时打印出来的；串口无输出"O"说明在打印"O"之前代码已经死掉了；开发板供电锁存在lowlevel_init.S中，开发板供电锁存成功说明这个代码之前的部分是没问题的。两个结合起来得到结论：错误在开发板供电锁存代码和串口初始化打印"O"代码之间。

（1）Windows下建立SourceInsight工程

（2）顺藤摸瓜去找可能出问题的地方

整个程序运行是从start.S开始的，看代码也从这里开始。
实际上只要屏蔽掉bl PMIC_InitIp	这一行代码，然后重新编译，整个uboot就启动起来了。但是很多配置信息是有问题的，很多功能应该也是不能用的，都要去一一查验。

****

## 11.4、时钟和DDR的配置移植

更改CONFIG_IDENT_STRING为"  for ASTON210"，然后同步到ubuntu中的一份代码，然后 make distclean; make smdkv210single_config，然后make，然后烧录运行，检查打印出来的banner信息是否如我们改动的那样。

### 11.4.1、确认时钟部分的配置

（1）时钟部分的运行结果本来就是对的，时钟部分的代码在lowlevel_init.S中的bl system_clock_init调用的这个函数中。函数的代码部分是没任何问题的，根本不需要改动，要改动的是寄存器写入的值，这些值都在配置头文件（smdkv210single.h）中用宏定义定义出来了。如果时钟部分要更改，关键是去更改头文件中的宏定义。

（2）三星移植时已经把210常用的各种时钟配置全都计算好用宏开关来控制了。只要打开相应的宏开关就能将系统配置为各种不同的频率。

### 11.4.2、DDR配置信息的更改

（1）从运行信息以及bdinfo命令看到的结果，显示DRAM bank0和1的size值都设置错了。

（2）使用md和mw命令测试内存，发现20000000和40000000开头的内存都是可以用的，说明代码中DDR初始化部分是正确的，只是size错了。

（3）内存部分配置成：
#define CONFIG_NR_DRAM_BANKS    2          /* we have 2 bank of DRAM */
//#define SDRAM_BANK_SIZE         0x20000000    /* 512 MB */
#define SDRAM_BANK_SIZE         0x10000000    /* 256 MB */

#define PHYS_SDRAM_1            MEMORY_BASE_ADDRESS /* SDRAM Bank #1 */
#define PHYS_SDRAM_1_SIZE       SDRAM_BANK_SIZE
//#define PHYS_SDRAM_2            (MEMORY_BASE_ADDRESS + SDRAM_BANK_SIZE) /* SDRAM Bank #2 */
#define PHYS_SDRAM_2  			0x40000000
#define PHYS_SDRAM_2_SIZE       SDRAM_BANK_SIZE

***

## 11.5、DDR地址另外配置

### 11.5.1、目标：将DDR端口0地址配置为30000000开头

（1）更改有2个目的：第一是让大家体验内存配置的更改过程；第二是3开头的地址和DRAM bank1上40000000开头的地址就连起来了。这样我们就得到了地址连续的512MB内存，而原来我们得到的512MB内存地址是断续的。

### 11.5.2、DDR初始化参数更改

（1）根据裸机中讲DDR初始化部分的课程，和uboot前面分析uboot中DDR初始化部分的代码的课程，得出结论就是：DDR的初始化代码部分是在lowlevel_init.S中写的，是不动的。代码部分就是对相应寄存器做相应值的初始化；要动的是值，而uboot为了具有可移植性把值都宏定义在include/configs/xxx.h中了。因此我们只需要去这个配置头文件中更改配置值即可。

（2）更改内容是：#define DMC0_MEMCONFIG_0	0x20E01323改为：
#define DMC0_MEMCONFIG_0	0x30E01323		注意20改为30了。

### 11.5.3、smdkv210single.h中相关宏定义修改

（1）寄存器的值改了后相当于是硬件配置部分做了更改。但是uboot中DDR相关的一些软件配置值还没更改，还在原来位置，所以要去更改。

（2）#define MEMORY_BASE_ADDRESS	0x20000000改为：
#define MEMORY_BASE_ADDRESS	0x30000000

### 11.5.4、虚拟地址映射表中相应修改

（1）uboot中开启了MMU对内存进行了段式映射，有一张内存映射表。之前课程中分析过，分析方法是一样的。

（2）经过实际分析，发现这个内存映射只是把20000000开始的256MB映射到C0000000开头的256MB。我们更改方法是将2改成3.

（3）为了安全起见，再去配置头文件smdkv210single.h中查一遍，看看有没有其他的宏定义值和内存配置有关联的。

重新配置编译，烧录运行查看结果。

### 11.5.5、修改DMC0的配置参数

（1）修改DDR中DMC0的memconfig_0寄存器的配置值，将
#define DMC0_MEMCONFIG_0	0x30E01323 改为：
#define DMC0_MEMCONFIG_0	0x30F01323

（2）然后重新同步、编译烧写运行，发现uboot第二阶段运行了，但是整个uboot还是不成功。

（3）分析问题，寻找解决方案。分析方法有2种：第一种靠经验、靠发现能力、靠直觉去找；第二种就是在整个代码中先基本定位错误地方，然后通过在源代码中添加打印信息来精确定位出错的代码，然后找到精确的出错位置后再去分析错误原因，从而找到解决方案。

### 11.5.6、修改修改虚拟地址到物理地址的映射函数

（1）修改uboot/board/samsung/smdkc110/smdkc110.c中的virt_to_phy_smdkc110，将其中的20000000改为30000000即可。

（2）同步代码，然后重新编译烧录运行。

****

## 11.6、inand驱动问题的解决

### 11.6.1、先从现象出发定位问题

（1）解决问题的第一步，是定位问题。所谓定位问题就是找到源代码当中导致这个问题的那一句或者那几句代码。有时候解决这个问题需要修改的代码和直接导致这个问题的代码是不同的。我们这里说的定位问题指的是定位到出问题的代码处，也就是运行了这一句代码时发生了这个错误。

（2）定位了问题之后，实际修改程序解决问题不一定改的是这一句代码。但是肯定和这一句代码有关联，我们要通过自己分析来找到这种关联，从而从定位的错误点找到真正需要修改的点，然后去修改他。

（3）实战方法：从打印出来的错误休息中挑选一个关键词，然后去源代码中搜索这个关键字，通过这种搜索的方法定位问题。通过搜索将问题定位在drivers/mmc/mmc.c的818行。

（4）然后就是解决问题了。

### 11.6.2、网络搜索解决方案

（1）初步的解决方案是自己先浏览一遍这个问题点周边代码上下文。通过浏览代码上下文，发现这个函数是在读取SD/iNand的ext_csd寄存器的值。通过浏览代码结合出错地方，可以判断出：从卡端读取ext_csd寄存器是成功的，并且从读取结果中拿到了卡的版本号信息。然后代码对版本号进行了判断，并且如果版本号大于5就会报错并且函数错误退出。这就是问题所正。

（2）问题就是：我们使用的iNand卡的版本号大于5，而uboot代码本身不处理版本号大于5的卡，因此出错了。

（3）怎么解决？第一可能，换卡；第二可能，软件修复。

（4）网络搜索错误关键字，然后逐个去查阅，看看哪个可以给我们提供解决问题的思路和方法。http://blog.csdn.net/wang_shuai_ww/article/details/22308853

### 11.6.3、尝试修改代码解决问题

（1）解决方法就是修改uboot中的代码，把判断的5改成更大的数字。譬如8，然后跳过这个错误。

### 11.6.4、推测和实验验证（SD卡和iNand的区别）

（1）当前板子上有一个iNand接在SD0上，有一个外置SD卡接在SD2上。那uboot中初始化的这个是iNand而不是SD卡。也就是说uboot中实际用的是SD0而不是SD2.

（2）大家可以尝试，使用外置SD卡时，这个版本号的问题不会出现。从这里可以推测出SD卡和iNand的区别，至少从一个角度可以看出：SD卡版本低，iNand的版本比较高。

*****

## 11.7、一些小问题的修补

### 11.7.1、控制台串口更换为串口0

（1）uboot中默认使用串口2来做控制台输入输出的。

（2）SOC中一共有4个串口（串口0、1、2、3），开发板X210上用DB9接口引出了2个串口，分别是串口2和串口0.（靠边的是串口2，靠里那个是串口0）。

（3）三星公司推荐使用串口2来作为调试串口，所以在三星移植的uboot和内核版本中都是以串口2默认为控制台串口的。

（4）有时候项目需要将调试串口修改为另外的串口（譬如串口0），这时候需要修改uboot的代码，做移植让uboot工作在串口0的控制台下。

（5）uboot中真正去硬件初始化串口控制器的代码在lowlevel_init.S中的uart_asm_init中，其中初始化串口的寄存器用ELFIN_UART_CONSOLE_BASE宏作为串口n的寄存器的基地址，结合偏移量对寄存器进行寻址初始化。所以uart_asm_init中到底初始化的是串口几（从0到3）？取决于ELFIN_UART_CONSOLE_BASE宏。这个宏的值又由CONFIG_SERIALn（n是从1到4）来决定

（6）同步代码、编译烧录运行，发现串口线插在串口2上，crt上只打印：SD checksum error.（这个是内部iROM打印出来的，内部iNand校验失败的信息）；然后将串口线改插到串口0上，启动，所有的信息出现。实验成功。

### 11.7.2、修改默认网络地址设置

（1）修改配置头文件smdkv210single.h中的CONFIG_IPADDR等宏，则可以修改uboot的默认环境变量。

（2）更改完成后如果环境变量还是原来的，正常。因为原来uboot执行过saveenv，因此环境变量已经被保存到iNand中的ENV分区中去了。uboot启动后校验时iNand的ENV分区中的环境变量是正确的，因此会优先加载。我们在uboot源代码中修改的只是默认的环境变量。解决方案是擦除掉iNand中的那一份环境变量，然后迫使uboot启动时使用uboot代码中自带的默认的这一份环境变量，就可以看到了。

（3）可以使用mmc write 0 30000000 11# 32（表示将DDR的0x30000000开头的一段内存中的内容写入iNand中的第17个扇区开始的32个扇区内，写入长度是32个扇区长度（16KB））

### 11.7.3、修改行提示符

（1）#define CFG_PROMPT              "ASTON210 # " 

### 11.7.4、总结

（1）结论就是对uboot的整体结构和过程了解之后，移植非常简单。

*****

## 11.8、网卡驱动移植

### 11.8.1、网卡芯片与开发板的连接方式

（1）SoC的SROM bank和网卡芯片的CS引脚（SROM就是SRAM/ROM）。SoC的SROMController其实就是SoC提供的对外总线式连接SRAM/ROM的接口。如果SoC要外部外接一些SRAM/ROM类的存储芯片（或者伪装成SROM接口的芯片，譬如网卡芯片）就要通过SROM Controller来连接。网卡接在SROM中好处就是网卡芯片好像一个存储芯片一样被扩展在SoC的一个地址空间中，主机SoC可以直接用一个地址来访问网卡芯片内部寄存器。

（2）网卡芯片内部寄存器使用相对地址访问。网卡芯片内部很多寄存器有一个地址，这个地址是从00开始的，但是实际上我们SoC不能用0地址去访问这个网卡的芯片内部寄存器。SoC访问网卡芯片00寄存器时的地址应该是：起始地址+00这里的起始地址就是网卡芯片对应接在SROM bankn中的bankn对应的基地址。

（3）主机SoC上网，其实就是通过操控网卡芯片内部的寄存器、缓冲区等资源来上网的。也就是说其实SoC是通过网卡芯片来间接上网的。

（4）总结：实际上也是一种总线式连接方式。优势是SoC内部不需要内置网卡控制器，所有的SFR全都在外部网卡芯片中，而且还可以通过地址直接访问（IO与内存统一编址），不用像Nand/SD接口一样使用时序来访问。

（5）从逻辑上来看，网卡更像是串口，而不像是SD/Nand。

### 11.8.2、原理图浏览

（1）210的SROM控制器允许8/16bit的接口，我们实际使用的是16位接口。

（2）网线有8根线，但是实际只有4根有效通信线，另外4根都是GND，用来抗干扰的。4根通信线中管发送的有2根（Tx-和Tx+），管接收的有2根（Rx+和Rx-）。因为网线上传输的是差分信号。

（3）网卡芯片有个CS引脚，（CS就是chip select，片选信号，主机向CS发送有效信号则从机芯片工作，主机向CS发送无效信号则从机芯片不工作。），这个引脚要接主机SoC的片选信号引脚，主机S5PV210的每一个SROM bank中有一个片选信号CSn(n=0-5)，从原理图可以看出，我们X210上将DM9000的CS引脚接到了CSn1上，对应SROM bank1（推断出DM9000的总线地址基地址是0x88000000）。

（4）DM9000的CMD引脚接到了S5PV210的ADDR2引脚上。DM9000为了减少芯片引脚数，数据线和地址线是复用的（DATA0到DATA15这16根线是有时候做数据线传输数据，有时候做地址线传输地址的。什么时候做什么用就由CMD引脚决定。）通过查询数据手册知道：当CMD为高电平时对应传输是DATA，当CMD为低电平时对应传输为INDEX（offset，寄存器地址）。

注明：这些引脚上的电平变化都是控制器自动的，不需要程序员手工干预。程序员所需要做的就是在配置寄存器值时充分考虑到硬件电路的接法，然后给相应寄存器配置正确的数值即可。

### 11.8.3、网卡驱动文件介绍

（1）uboot中本来就提供了很多网卡芯片的驱动程序，在uboot/drivers/net/dm9000x.c和dm9000x.h。这个驱动来自于linux kernel源代码。所以我们uboot中是移植而不是编写。

（2）要想彻底看懂这个驱动，必须对linux的驱动模型中网络设备驱动有一定的理解才可以。因为我们还没学驱动，因此这个源代码就不用看了。

（3）这个驱动是linux内核中做好的，根本不用动可以在uboot中直接使用的。而且因为linux驱动设计的很合理（数据和代码是分开的，这里驱动主要是代码，数据是由硬件开发板中的接法决定的，数据由一定的数据结构来提供。），所以驱动本身具有可移植性。这个就决定了我们移植DM9000驱动时这个驱动文件dm9000x.c和h不用动，要动的是数据。

### 11.8.4、网卡移植的关键：初始化

（1）uboot在第二阶段init_sequences中进行了一系列的初始化，其中就有网卡芯片的初始化。这个初始化就是关键，在这里的初始化中只要将网卡芯片正确的初始化了，则网卡芯片就能工作（意思是网卡驱动dm9000x.c和dm9000x.h依赖于这里的初始化而工作）。

（2）网卡初始化代码地方在：
start_armboot
	init_sequence
		board_init
			dm9000_pre_init		这个函数就是移植的关键

（3）dm9000_pre_init函数主要功能就是初始化DM9000网卡。这个初始化过程和我们开发板上DM9000网卡芯片的硬件连接方式有关。必须要结合开发板原理图来分析，然后决定这个函数怎么编程。

（4）原来的代码是三星的工程师根据三星的开发板SMDKV210的硬件接法来写的程序，我们要根据自己的开发板的硬件接法去修改这个程序，让网卡在我们的开发板上能工作。

（5）#define DM9000_16BIT_DATA这个宏用来表示DM9000工作在16位总线模式下。根据上节课的硬件原理图的分析，可以看到我们开发板上DM9000确实工作在16位模式下。

（6）从三星版本的代码中可以看出，它操作的是bit20-bit23，对照数据手册中寄存器定义，可以看出三星的开发板DM9000是接在Bank5上的。而我们接在bank1上的，因此我们需要操作的bit位是bit4-bit7

（7）总结：三个寄存器的修改。主要是三星的开发板DM9000接在bank5，我们接在了bank1上，因此要做一些修改。

### 11.8.5、基地址的配置等

（1）之前说过，驱动分为2部分：代码和数据。代码不用动，数据要修改。

（2）CONFIG_DM9000_BASE是DM9000网卡通过SROM bank映射到SoC中地址空间中的地址。这个地址的值取决于硬件接到了哪个bank，这个bank的基地址是SoC自己定义好的。譬如我们这里接到了bank1上，bank1的基地址是0x88000000.

（3）DM9000_IO表示访问芯片IO的基地址，直接就是CONFIG_DM9000_BASE；DM9000_DATA表示我们访问数据时的基地址，因为DM9000芯片的CMD引脚接到了ADDR2，因此这里要+4（0b100，对应ADDR2）

（4）本来这样配置就完了，重新编译运行网卡就应该工作了。但是实际测试发现不工作，要怎么样修改呢？修改方式是将CONFIG_DM9000_BASE改成0x88000300就工作了。
问题？这个0x300从哪里来的？我得出的感觉最靠谱的解释是：跟DM9000网卡芯片型号版本有关，我认为这个0x300是DM9000网卡本身的问题，他本身的内部寄存器就有一个0x300的一个偏移量。

*****

## 11.9、网卡驱动如何工作

### 11.9.1、网卡移植代码实践

（1）经过实践，网卡驱动移植成功。

（2）其实还可以做一些实验。譬如说对网卡驱动初始化部分寄存器的设置，还有网卡CONFIG_DM9000_BASE也可以配成0x88000000再去试一试。

### 11.9.2、linux系统中网卡驱动的典型工作方式简介

（1）在linux系统中，网卡算是一个设备，这个设备驱动工作后会生成一个设备名叫ethn（n是0、1、2、····）（无线网卡名字一般叫wlan0、wlan1····）。然后linux系统用一些专用命令来操作网卡，譬如ifconfig命令。

（2）linux下的应用程序如何使用网卡驱动来进行网络通信？最通用的方法就是socket接口。linux系统中有一系列的API和库函数，提供了一个socket编程接口，linux下的应用程序都是通过socket来实现上网的，socket内部就是间接调用的网卡驱动实现网络通信的。

（3）linux设计是非常完备的，应用层和驱动层是严格分离的。也就是说写网络编程应用层的人根本不用管驱动，只要会用socket接口即可；写底层驱动的人根本不用管应用层，只要面向linux的网络驱动框架模型即可。

### 11.9.3、uboot中网卡驱动的工作方式简介

（1）一定要记住：uboot本身是一个裸机程序，是一个整体，没有分层。所以uboot中根本没有驱动和应用的概念。

（2）按照逻辑来说，ping这样的命令实现的代码就是网络应用的应用程序，像dm9000x.c和dm9000x.h这样的代码属于驱动程序。所以在uboot中这些东西是揉在一起的，应用是直接调用驱动实现的。也就是说ping命令内部是直接调用了dm9000的网卡驱动中的函数来实现自己的。

### 11.9.4、以ping命令为例查找代码验证分析

（1）ping命令是uboot的众多命令之一，ping命令实现的函数叫do_ping

（2）函数的调用关系：
do_ping
	NetLoop
		PingStart
			PingSend
				ArpRequest
					eth_send（dm9000x.c中）

（3）验证了2.11.11.3中说的uboot中应用程序（ping）调用驱动程序（dm9000x.c）的方式。这就是一种直接调用的方式。

注：lcd驱动与logo显示，在2.13.uboot杂记-logo显示和fastboot原理等中详解

****

## 11.10、使用自己移植的uboot启动内核

### 11.10.1、问题：当前uboot不能启动内核

（1）用同样的方法（使用tftp 0x30008000 zImage-qt; 然后bootm 0x30008000），分别使用我们自己移植的uboot和使用九鼎移植版本的uboot去启动内核，发现九鼎移植版本的可以启动，但是我们自己移植的不可以启动。到此我们就断定我们的uboot有问题，不能启动内核。

（2）做基本检查：首先怀疑是机器码不对。经过和九鼎移植版本的uboot对比发现machid都是2456，说明机器码没错。

（3）想到一个问题，我们之前做实验时将串口改为了串口0，而内核zImage-qt的串口输出在串口2.怀疑可能的问题是uboot使用了串口0而内核使用了串口2所以在uboot后看不到内核的启动信息。

### 11.10.2、解决第一步：将串口改回串口2

（1）在smdkv210single.h中修改串口编号即可。

### 11.10.3、根据现象分析，定位问题并试图解决

（1）如果已经启动了内核，那没什么好说的了。应该是可以直接启动了。

（2）如何内核没有启动，是smdkv210single.h中没有定义bootm传参需要的那几个宏造成的。

****

# 12、uboot的移植-从uboot官方标准uboot开始移植

## 12.1、选择合适的官方原版uboot

### 12.1.1、官方原版uboot的版本

（1）版本号。刚开始是1.3.4，后来变成2009.08

（2）新版和旧版的差别。uboot的架构很早就定下来了，然后里面普遍公用的东西（common目录下、drivers目录下、fs目录下等···）在各个版本之间几乎是完全一样的。差别最大的是board和cpu目录，这两个目录正是单板（开发板）相关的。越新的uboot版本支持越多的开发板（CPU），所以越新的uboot越庞大。

（3）并不是越新的版本就越好。越新的uboot中会多出更多的开发板的支持代码，如果我们的开发板并不是很新，就没必要去用很新版本的uboot。因为多出来的代码自己也用不到而且还会成为累赘。

### 12.1.2、官方原版uboot的来源

（1）从uboot官方网站ftp下载

（2）从一些镜像网站下载

### 12.1.3、新版uboot配置体系的改变

（1）在最新的uboot版本（准确的说是2013.10到2014.10中的某个版本）中，uboot的文件体系发生了一个很大的变化。这个变化就是uboot引入了linux kernel的配置体系（Kbuild、Kconfig、menuconfig），从而让我们可以在图形界面下，像配置内核一样配置uboot。

（2）所以新版本的uboot配置时和我们之前的课程讲的就不同了。我们移植时不能选择这种配置方式更改之后的uboot版本。我们要选择更改之前的。

（3）新版本的配置方式本质上和linux kernel一样的，所以在学完linux kernel移植后自己就能看懂，因此不用担心。

### 12.1.4、结论：选择合适的官方原版uboot进行移植

（1）结合以上，选择2013.10版本进行实验移植是比较合理的。

### 12.1.5、注意：实践工作中一般是从SoC厂商的uboot出发移植的

（1）在工作中一般是不需要从uboot官方版本出发去做移植的，而是从SoC厂商提供的开发板配套的uboot去做移植的。

****

## 12.2、初步浏览官方原版uboot

### 12.2.1、文件夹结构浏览

（1）文件夹结构分析、主要文件检视
总的来说，文件夹结构和以前基本一样。不同的主要是lib，以前是lib_arm和lib_generic，现在是arch和lib。arch目录下放的是和cpu架构有关的东西。
总的来说，2013.10版本的uboot在结构上和1.3.4版本的uboot还是有所不同的。

（2）参照物开发板的选择
我们开发板使用的CPU是S5PV210，所以要找uboot中针对S5PV210或者S5PC110进行移植的作为参考。
根据规律，我们应该参考include/configs/s5p_goni.h，对应的board在uboot/board/samsung/goni这个目录。

（3）删除无关文件和文件夹
其实不删除也可以，但是删除更好。

### 12.2.2、主Makefile浏览及boards.cfg文件

（1）2013.10版本的uboot的Makefile中使用了boards.cfg文件，因此在配置uboot时make xxx_config，这个xxx要到boards.cfg文件中查找。

（2）其实就相当于把以前的版本的uboot中各种开发板的配置部分规则抽离出来写到了Makefile中，然后把配置信息部分写到了一个独立文件boards.cfg。

### 12.2.3、结论：

（1）参照物开发板为：s5p_goni

（2）配置对应的cpu、board文件夹分别为：
cpu:	u-boot-2013.10\arch\arm\cpu\armv7
board:	u-boot-2013.10\board\samsung\goni

****

## 12.3、mkconfig脚本分析

### 12.3.1、脚本功能浏览

（1）首先我们在命令行配置uboot时，是：make s5p_goni_config，对应Makefile中的一个目标。

（2）新版本的Makefile中：
%_ config::	unconfig
	@$(MKCONFIG) -A $(@:_config=)
从这里分析得出结论，实际配置时是调用mkconfig脚本，然后传参2个：-A和s5p_goni

（3）到了mkconfig脚本中了。在24到35行中使用awk正则表达式将boards.cfg中与刚才$1（s5p_goni）能够匹配上的那一行截取出来赋值给变量line，然后将line的内容以空格为间隔依次分开，分别赋值给$1、$2···$8。
(4)注意在解析完boards.cfg之后，$1到$8就有了新的值。
$1 = Active
$2 = arm
$3 = armv7
$4 = s5pc1xx
$5 = samsung
$6 = goni
$7 = s5p_goni
$8 = - 

### 12.3.2、几个传参和其含义
（1）几个很重要的变量
arch=arm   
cpu=armv7
vendor=samsung
soc=s5pc1xx

### 12.3.3、符号链接

（1）include/asm  -> arch/arm/include/asm
（2）include/asm/arch -> include/asm/arch-s5pc1xx
（3）include/asm/proc -> include/asm/proc-armv

最后创建了include/config.h文件。

### 12.3.4、Makefile中添加交叉编译工具链

（1）官方原版的uboot中CROSS_COMPLIE是没有定义的，需要自己去定义。如果没定义就直接去编译，就会用gcc编译。

（2）添加一行：
CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

### 12.3.5、配置编译测试

（1）编译过程：
make distclean
make s5p_goni_config
make

（2）结果：得到u-boot.bin即可

******

## 12.4、先解决官方版本uboot的烧录运行

### 12.4.1、如何烧录uboot

（1）烧录u-boot.bin到SD卡中有2种方法：windows下用烧录软件；linux下用dd命令烧录脚本来烧录。因为windows下的工具不开源，出了问题没法调试，所以不推荐。推荐linux下用烧录脚本来烧录（实质是dd命令进行sd卡扇区写入）

（2）移植原来的版本的uboot中的sd_fusing文件夹到官方uboot版本中，使用这个文件夹中的sd_fusing.sh脚本来进行烧录。

### 12.4.2、分析：为什么烧录运行不正确？

（1）串口接串口2，串口有输出。但是这个串口输出不是uboot输出的，而是内部iROM中的BL0运行时输出的。

（2）输出错误信息分析：
第一个SD checksum Error：是第一顺序启动设备SD0（iNand）启动时校验和失败打印出来的；
第二个SD checksum Error：是第二顺序启动设备SD2（外部SD卡）启动时校验和失败打印出来的；
剩下的是串口启动和usb启动的东西，可以不管。
总结：从两个SD checksum Error，可以看出：外部SD卡校验和失败了。
分析：SD卡烧录出错了，导致SD卡校验和会失败。

### 12.4.3、解决方案分析

（1）为什么SD卡烧录会出错？可能原因：烧录方法错误、烧录原材料错误。

（2）经过分析，sd_fusing这个文件夹下的mkbl1这个程序肯定没错，上一层目录下的u-boot.bin是存在的，校验和失败不失败和u-boot.bin无关。

（3）经过分析和查找，发现是mkbl1程序和start.S中前16个字节校验和的处理上面不匹配造成的，解决方法是在start.S最前面加上16个字节的占位。

### 12.4.4、代码实践

（1）重新编译烧录运行，发现结果只显示一个SD checksum Error。这一个就是内部SD0通道的inand启动校验和失败打印出来的。剩下的没有了说明外部SD卡校验和成功了，只是SD卡上的uboot是错误的，没有串口输出内容，所以没有输出了。

****

## 12.5、start.S文件分析与移植

### 12.5.1、start.S流程分析

（1）#define CONFIG_SYS_TEXT_BASE		0x34800000  可以看出我们的uboot的连接地址是在0x34800000位置。

（2）save_boot_params是个空函数，里面直接返回的。

（3）cpu_init_cp15这个函数功能是设置MMU、cache等。这个版本的uboot中未使用虚拟地址，因此MMU在这里直接关掉。

（4）cpu_init_crit，这个函数里只有一句跳转指令，短跳转到lowlevel_init函数。
注意：uboot中有2个lowlevel_init.S文件（文件中还都有lowlevel_init函数），凭一般分析无法断定2个中哪个才是我们想要的。通过分析两个文件所在文件夹下面的Makefile可以判定board/samsung/goni目录下的才是真正包含进来的，arch/arm/cpu/armv7目录下的并没有被包含进来。
还可以通过实践验证的方法来辅助判断。通过查看之前已经编译过的uboot源码目录，看哪个被编程为.o文件了，就知道哪个是真正被使用的了。

（5）lowlevel_init函数在board/samsung/goni目录下，主要作用是时钟设置、串口设置、复位状态判断···这个函数是S5PC100和S5PC110两个CPU共用的。

（6）经过浏览，发现lowlevel_init函数中做的有意义的事情有：关看门狗、调用uart_asm_init来初始化串口、并没有做时钟初始化（下面有时钟初始化的函数，但是实际没调用。如果uboot中没有初始化时钟，那么时钟就是iROM中初始化的那种配置）

### 12.5.2、添加开发板制锁和串口打印字符"O"

（1）我们为了调试uboot的第一阶段，就要看到现象。为了看到现象，我们向lowlevel_init函数中添加2个代码，一个是开发板制锁，一个是串口打印"O"

（2）这两段代码可以直接从ARM裸机全集课程中的代码中来。其实也可以从三星移植版本的uboot中来，但是因为三星移植版本中用到了很多寄存器定义，涉及到头文件的，所以移植过来不方便。

（3）实践添加。

### 12.5.3、实践结果及分析

（1）实验结果是：没看到开发板制锁，串口也没有输出任何东西。实验失败。

（2）结论：因为开发板制锁没有成功，所以我们判定，在开发板制锁代码运行之前uboot就已经挂掉了。下面就是去跟踪代码运行，然后判定问题点再去解决。

### 12.5.4、添加LED点亮代码跟踪程序运行

（1）在基础代码阶段，串口还没有运行，串口调试工具还无法使用时，使用LED点亮的方式来调试程序就是一个有力的手段。

（2）有些情况下可以用Jlink等调试工具来调试这种基础代码。

（3）从程序的基本运行路径端出发，隔一段给他添加一个LED点亮代码，然后运行时根据现象来观察，判定哪里执行了哪里没执行。从而去定位问题。

（4）从以前的裸机代码中组织出一个标准的LED点亮然后延时一段的一个标准代码段：

```assembly
ldr r0, =0x11111111
	ldr r1, =0xE0200240
	str r0, [r1]
	ldr r0, =((1<<3) | (0<<4) | (1<<5))	// 1是灭，0是亮
	ldr r1, =0xE0200244
	str r0, [r1]
	

	ldr r2, =9000000
	ldr r3, =0x0

delay_loop:	
	sub r2, r2, #1	
	cmp r2, r3			
	bne delay_loop
```


（5）之前做实验时发现一个现象：我们的uboot运行时按住电源开关时所有4颗LED都是亮的。所以我们做实验时给LED点亮是看不到现象的，所以我们的代码关键是要熄灭某些LED来判断。

（6）我们将熄灭LED的函数在start.S中隔一段的关键部位放上1个，然后运行时通过观察LED的点亮熄灭状态，就知道程序运行到哪里了。

（7）经过判断我们发现：start.S中工作一切正常，但是函数一旦放到lowlevel_init.S中就完全不工作了。通过分析得出结论：b lowlevel_init这句代码出了问题。

### 12.5.5、修改u-boot.lds将lowlevel_init.S放到前部

（1）问题分析：跳转代码出了问题。分析问题出在代码的连接上。

（2）三星S5PV210要求BL1大小为8KB，因此uboot第一阶段代码必须在整个uboot镜像的前8KB内，否则跳转不到。

（3）对比三星移植版本的uboot的u-boot.lds和官方版本uboot的连接脚本u-boot.lds（注意这两个版本的uboot的连接脚本的位置是不同的），就发现lowlevel_init.S的代码段没有被放在前面。

（4）在u-boot.lds中start.o后面添加board/samsung/goni/lowlevel_init.o (.text*)，这个就保证了lowlevel_init函数被连接到前面8kb中去。

（5）报错，lowlevel_init重复定义了。

### 12.5.6、修改board/samsung/goni/Makefile解决编译问题

（1）问题分析：为什么会重复定义。因为lowlevel_init这个函数被连接时连接了2次。一次是board/samsung/goni这个目录下生成libgoni.o时连接了1次，第2次是连接脚本最终在连接生成u-boot时又连接了一次，所以重复定义了。

（2）这个错误如何解决？思路是在libgoni.o中不要让他连接进lowlevel_init，让他只在最终连接u-boot时用1次，就可以避免重复定义。

（3）参考当前版本的uboot的start.S文件的处理技巧，解决了这个问题。

### 12.5.7、实践验证。

结果是开发板制锁和串口输出'O'都成功了。

****

## 12.6、添加DDR初始化

### 12.6.1、分析下一步移植路线

（1）cpu_init_crit函数成功初始化串口、时钟后，转入_ main函数，函数在arch/arm/lib/crt0.S文件中。

（2）在crt0.S中首先设置栈，将sp指向DDR中的栈地址；然后调用board_init_f函数进行板级初始化。函数在arch/arm/lib/board.c中。

（3）在这个版本的uboot中，把以前uboot的第二阶段start_armboot函数分成了2部分：board_init_f和board_init_r。所以在这里就和以前版本的uboot接轨上了，推测board_init_f中肯定是做了板级初始化，board_init_r中进入了uboot的命令行。

（4）分析到这里，在uboot2013.10版本中思路已经很清晰了：uboot的第二阶段就在crt0.S文件中，第二阶段的入口就是_main函数。第一阶段工作主要就是cpu_init_crit函数，所以我们要在cpu_init_crit函数中添加DDR初始化和uboot的重定位。

（5）分析到这里，下一步工作方向就确定了。我们要先在cpu_init_crit函数中添加DDR初始化，然后在start.S中bl _main之前添加uboot的重定位，然后将bl _main改成ldr pc, __ main(__main: .word _main)长跳转。然后在crt0.S中board_init_f后删除那些重定位代码，至此uboot的第二阶段就应该能启动起来了。后续的移植就是第二阶段了。

### 12.6.2、分析DDR初始化代码移植思路

（1）如果本来uboot中有DDR初始化代码，那我们可以就着这些代码来修改。但是问题是这个uboot2013.10中根本没有DDR初始化，所以我们需要完全从头去另外添加DDR初始化代码。

（2）我们的思路就是从三星版本的uboot中直接移植DDR初始化代码过来即可。三星版本的uboot中DDR初始化函数在cpu/s5pc11x/s5pc110/cpu_init.S文件中，直接将这个文件移植过来即可。

### 12.6.3、动手移植

（1）添加cpu_init.S文件到uboot2013.10中。注意，这里的代码必须保证在前8kb内，所以必须和lowlevel_init.S文件一样的链接处理。主要是在board/samsung/goni/Makefile中和arch/arm/cpu/u-boot.lds文件中做修改添加。

（2）添加头文件s5pc110.h到include目录下。

（3）对cpu_init.S文件代码进行修整，把一些无用的代码去掉，把一些相关的条件编译人工处理一下。

（4）在SourceInsigt工程中添加入这两个文件。然后重新解析一遍。然后对新添加的代码进行分析修整，把里面一些明显的宏定义缺失给补上。

### 12.6.4、移植必要的宏定义

（1）DDR配置参数，从三星版本的smdkv210single.h中复制到s5p_goni.h中。

（2）s5pc110.h中进行修整。

### 12.6.5、代码同步、编译、再修整

### 12.6.6、添加调试信息，验证DDR初始化完成。

（1）调试信息有LED点亮和串口输出两种。优先选用串口调试的方法。

（2）在DDR初始化完成后，添加串口输出字符"K"，这样启动时如果看到了"OK"就说明DDR已经被成功初始化了。

（3）结果：看到了"OK"标志，说明DDR添加实验成功。

*****

## 12.7、添加uboot第二阶段重定位

### 12.7.1、在重定位代码前加调试信息定位

（1）逻辑上来说，重定位部分代码应该在DDR初始化之后和uboot第二阶段来临前之间。

（2）uboot的第一阶段和第二阶段的划分并不是绝对的，唯一必须遵循的原则就是第一阶段不能大于8KB。所以uboot的第一阶段最少要完成DDR初始化和重定位，最多不能超过8KB。在满足这些条件时，第一阶段和第二阶段的接点可以随便挑。

（3）找到合适的地方来写重定位代码，重定位之后远跳转到第二阶段的入口。

### 12.7.2、重定位代码移植

### 12.7.3、清bss段移植

### 12.7.4、movi_bl2_copy函数移植

（1）从三星版本的uboot中赋值movi.c和movi.h到uboot2013.10中。

（2）改makefile和u-boot.lds。

### 12.7.5、_mian函数中基本处理

（1）主要就是把里面的重定位代码部分给删除掉。剩下就是：设置栈、调用board_init_f函数和board_init_r函数。

### 12.7.6、代码同步及编译

（1）主要是crt0.S和movi.h。

### 12.7.7、编译中出现问题解决

（1）movi.h中宏定义出错，最后在s5p_goni.h中添加了 CONFIG_EVT1这个宏解决了

（2）连接错误：u-boot contains relocations other than 	R_ARM_RELATIVE
在uboot下用grep "R_ARM_RELATIVE" -nR *搜索，发现Makefile中有一个检查重定位的规则，屏蔽掉这个规则后编译连接成功。

### 12.7.8、结果验证及下阶段展望

（1）看到了uboot启动打印出来的一系列信息，但是uboot没有进入命令行。

（2）这说明uboot中的DDR初始化和重定位功能都已经完美实现，后面就是第二阶段的继续移植了。

*****

## 12.8、CPU时钟信息显示移植

### 12.8.1、小问题：banner信息补全

### 12.8.2、CPU ID的确定

### 12.8.3、CPU各种频率的自动计算

### 12.8.4、代码实践

（1）arch/arm/include/asm/arch-s5pc1xx/cpu.h，和arch/arm/cpu/armv7/s5p-common/cpu_info.c文件同步一下

### 12.8.5、问题分析

（1）时钟显示ARMCLK是400MHz。

（2）调试，把m、p、s和apll_ratio打印出来后，发现这几个值的设置和之前的uboot的设置是不同的。原因在于我们当前版本的uboot中并未对SoC的时钟进行过设置，当前uboot中的时钟是iROM代码默认设置的。

（3）我自己之前一直认为iROM中把210的时钟设置为了1000MHz，然后三星版本的uboot中设置的时钟也是按照这个数据手册356页推荐的这个最佳性能配置时钟设置的。所以以前认为uboot中可以没有时钟设置也是一样的。

（4）但是实际上不是这样的，实际上内部iROM中设置的时钟APLL输出是800MHz，ARMCLK是400MHz。如果uboot中不做时钟的设置实际得到的就是这个时钟。所以我们之前代码得到的结果是400MHz。

（5）所以要解决这个时钟不对的问题，要在lowlevel_init.S中添加上时钟初始化的代码即可。

### 12.8.6、时钟初始化函数的添加

（1）在lowlevel_init.S中移植system_clock_init函数，并且在s5p_goni.h中添加相关的宏定义参数，然后在lowlevel_init函数中调用system_clock_init函数。

****

## 12.8、board和DDR配置显示移植

### 12.8.1、board名称更改

### 12.8.2、DDR配置值修改

### 12.8.3、MACH_TYPE定义

### 12.8.4、DDR打印信息更改

### 12.8.5、代码实践

### 12.8.6、关于MACH_TYPE的定义问题。

（1）在uboot2013.10中和uboot1.3.4中设计有所不同。在uboot1.3.4中这个东西是分散定义在各个配置头文件当中的。但是在uboot2013.10中我们把MACH_TYPE集中定义在一个文件arch/arm/include/asm/mach-types.h中了。

（2）集中定义其实是uboot从linux内核中学来的。在linux kernel中MACH_TYPE就是在文件中集中定义的。集中定义的好处是方便查阅，不容易定义重复。

（3）这个MACH_TYPE是和开发板绑定的，原则上每一个开发板型号都有一个MACH_TYPE，这个机器码由linux内核管理者来分配的，如果需要应该向这些人申请。

****

## 12.9、board_init_r移植

### 12.9.10、去掉oneNand支持

（1）在s5p_goni.h中将关于oneNand的宏定义都注释掉，之后进行编译根据编译的报错信息来将因为注释掉的宏导致的问题给修补回来。

（2）修改完之后启动已经可以进入命令行了，命令也是可以执行的，但是修改环境变量保存还是不行，会报错Writing to MMC failed，环境变量不能保存说明是SD/MMC的读写有问题

### 12.9.11、添加SD/MMC支持

*****

## 12.10、uboot2013.10中SD/MMC驱动浏览

### 12.10.1、从初始化代码开始浏览

### 12.10.2、相关函数和文件

drivers/mmc/mmc.c、
drivers/mmc/sdhci.c
board/samsung/goni/goni.c
arch/arm/include/asm/arch-s5pc1xx/mmc.h

### 12.10.3、当前错误定位及解决方案分析

（1）错误发生路径定位
board_init_r
	mmc_initialize
		do_preinit
			mmc_start_init
				mmc_go_idle
					mmc_send_cmd
						sdhci_send_command
							sdhci_transfer_data	错误在这个函数中
（1）错误原因分析
sdhic.c中的所有函数构成了三星210CPU的SD/MMC控制器的驱动。这里面的函数是三星公司的工程师写的，内容就是用来控制210CPU的内部的SD/MMC控制器和外部的SD卡通信的。这就是所谓的驱动。
sdhci_transfer_data函数出错，说明是SoC的SD/MMC控制器和外部SD卡（其实现在用的是SD0的iNand）的数据传输出了问题。（细节分析发现是控制器内部有一个中断状态错误标志被置位了。）

（2）解决方案分析：
两条思路：第一是去逐行的分析SD卡驱动实现（分析中要对SD卡通信协议和210这个SoC的SD控制器非常熟悉），然后发现错误所在，然后修改代码解决问题；第二个是投机取巧的方法，就是把原来三星移植版本的uboot中的SD/MMC驱动整个移植过来替换掉uboot2013.10中的MMC驱动。其实还有第三条折中思路，就是综合第一种和第二种，譬如参考三星移植版本的uboot中的驱动实现来修补uboot2013.10中的驱动实现。

****

## 12.11、SD卡驱动移植

### 12.11.1、分析两个版本的uboot中SD卡驱动差异

（1）uboot2013.10中：驱动相关的文件主要有：
drivers/mmc/mmc.c
drivers/mmc/sdhci.c
drivers/mmc/s5p_sdhci.c
board/samsung/goni/goni.c

（2）三星移植版本中，驱动相关的文件主要有：
drivers/mmc/mmc.c
drivers/mmc/s3c_hsmmc.c
cpu/s5pc11x/cpu.c
cpu/s5pc11x/setup_hsmmc.c
(3)经过分析发现：SD卡驱动要工作要包含2部分内容，一部分是drivers/mmc目录下的是驱动，另外一部分是uboot自己提供的初始化代码（譬如GPIO初始化、时钟初始化）

### 12.11.2、复制必要的文件并修改相应Makefile

（1）首先解决drivers/mmc目录下的文件替换。

将三星版本的下的drivers/mmc/mmc.c    drivers/mmc/s3c_hsmmc.c  放到官方版本的drivers/mmc/目录下，将三星版本的cpu/s5pc11x/setup_hsmmc.c  放到board/samsung/goni/目录下

（2）修改初始化代码。

### 12.11.3、代码浏览及修补

（1）按照代码运行时的流程来逐步浏览代码，看哪里需要修补。

### 12.11.4、继续修补驱动代码

（1）include/mmc.h

（2）include/s3c_hsmmc.h

### 12.11.5、同步及编译、问题解决

（1）出错1：cmd_mmc.c中出错。原因是cmd_mmc.c和mmc驱动密切相关，所以改了驱动后这个实现文件也要跟着改，解决方法是从三星版本的直接同名文件复制过来替换

（2）出错2：drivers/mmc/mmc_write.c编译出错。原因是这个文件和本来版本中的mmc.c文件相关，但是mmc.c被替换掉了所以这个文件编译报错。解决方案就是修改makefile去掉这个文件的依赖，让他不被编译。

（3）出错3：#include<regs.h>注释掉，然后添加#include <s5pc110.h>

### 12.11.6、解决每次编译时间都很长的问题。

（1）每次编译脚本cp.sh执行时都会先cp同步代码，然后make distclean···所以每次都会清空后从头编译，这就很费时间了。

（2）但是实际上有时候是不会make distclean的，只需要先cp然后直接make即可（当更改没有涉及到配置头文件s5p_goni.h，没有涉及到makefile文件，或者其他项目配置文件，也就是说我们的更改只是普通代码文件的更改时）

### 12.11.7、效果测试

（1）读测试 mmc read 1 30000000 1# 1  读SD卡的扇区1这一个扇区的东西读到内存30000000的地方,命令输入之后出现read：ok 说明读取成功，再输入md 30000000 将读取的信息显示出来如果没有问题那么我们显示的应该就是我们uboot的第一部分的内容

（1）写测试 先用mw命令写一段内存，mw.l 31000000 12345678  将内存31000000地址处写入12345678,再将这段内存写入mmc 0中，mmc write 31000000 21# 1 将内存31000000地址的内容写入mmc 0第21个扇区开始写一个扇区，再将这个扇区内的数据读到内存中再打开看是否相同

****

## 12.12、环境变量的移植

### 12.12.1、iNand分区表检查-env究竟应该放在哪

（1）测试环境变量是否可以保存，通过开机set设置环境变量然后save，然后关机后重启来测试环境变量的保存是否成功。

（2）我们的环境变量究竟保存到哪里去了？这个就要去分析代码中的分区表。

（3）环境变量应该被放在哪里？虽然无法确定ENV一定要放在哪里，但是有一些地方肯定是不能放的，否则将来会出问题。原则是同一个SD卡扇区只能放一种东西，不能叠加，否则就会被覆盖掉。uboot烧录时使用的扇区数是：SD2的扇区1-16和49-x（x-49大于等于uboot的大小）

（4）从uboot的烧录情况来看，SD2的扇区0空闲，扇区1-16被uboot的BL1占用，扇区17-48空闲，扇区49-x被uboot的BL2占用。再往后就是内核、rootfs等镜像的分区了。系统移植工程师可以根据kernel镜像大小、rootfs大小等来自由给SD分区。

（5）从uboot的分区情况来看，ENV不能往扇区1-16或者49-x中来放置，其他地方都可以商量。ENV的大小是16K字节也就是32个扇区。

### 12.12.2、环境变量相关代码浏览

（1）目前情况是uboot在SD2中，而ENV在SD0中，所以现在ENV不管放在哪个扇区都能工作，不会有问题。但是我们还是得找到ENV分区所在并且改到不会和uboot冲突，因为将来部署系统时我们会将uboot和kernel、rootfs等都烧录到iNnand中去，那时候也要确保不会冲突。

（2）static inline int write_env(struct mmc *mmc, unsigned long size,
			    unsigned long offset, const void *buffer)
类似于这种函数，在代码分析中，关键是弄明白各种参数的意义。mmc表示要写的mmc设备，size表示要写的大小，offset表示要写到SD卡的哪个扇区去，buffer是要写的内容。

（3）CONFIG_ENV_OFFSET这个宏决定了我们的ENV在SD卡中相对SD卡扇区0的偏移量，也就是ENV写到SD卡的哪里去了。经过分析发现这个宏的值为0.所以我们的ENV
被写到了0扇区开始的32个扇区中。

（4）写到这里肯定不行，因为和uboot的BL1冲突了。解决方案是改变这个CONFIG_ENV_OFFSET的值，将ENV写到别的空闲扇区去。

（5）#define MOVI_BL2_POS		((eFUSE_SIZE / MOVI_BLKSIZE) + MOVI_BL1_BLKCNT + MOVI_ENV_BLKCNT)		后面这三个其实分别是1+16+32=49
其中的1就是扇区0（空闲的），16是就是扇区1-16（uboot的BL1），32就是扇区17-48（存放ENV的），49自然就是uboot的BL2开始扇区了。这种安排是三星移植的uboot版本中推荐的SD卡的分区方式，不一定是唯一的。

（6）我们参考这个设计，即可实现环境变量不冲突。所以只要将ENV放到17扇区起始的地方即可。

****

## 12.13、环境变量的测试和配置移植

### 12.13.1、如何测试环境变量的保存是否正确

（1）程序修改重新编译后启动，启动后要注意iNand中本来有没有环境变量。为了保险起见对iNand的前49个扇区进行擦除，然后就可以确保里面没有之前保存过的环境变量了。使用命令：mmc write 0 30000000 0# 49 来擦除SD0的扇区0-48，保证以前的环境变量都没有了。

（2）重新开机后先set随便改一个环境变量作为标记然后saveenv然后重启。

（3）测试方法是，使用：mmc read 0 30000000 17# 32命令将iNand的17开始的32个扇区读出来到内存30000000处，然后md查看。找到显示区域里面的各个环境变量，看读出来的和自己刚才修改的值是否一样。

### 12.13.2、常用环境变量的配置移植

（1）常用的环境变量就是网络相关的那几个，和CONFIG_BOOTCOMMAND、CONFIG_BOOTARGS等。

******

## 12.14、网卡驱动的移植

### 12.14.1、添加网络支持

（1）uboot中对各种功能也是一个条件编译可以配置可以裁剪的设计（从linux内核学来的），默认情况下我们的uboot没有选择支持网络。

（2）在配置头文件中添加一行 #define CONFIG_CMD_NET，实际发现官方版本中是在#include <config_cmd_default.h>头文件中有定义CONFIG_CMD_NET宏的，但是在后面用#undef取消定义了，所以只需要将取消定义删除即可

（3）添加了网络支持宏之后，在uboot初始化时就会执行eth_initialize函数，从而网络相关代码初始化就会被执行，将来网络就有可能能用。

### 12.14.2、添加ping和tftp命令

（1）在linux系统中网络底层驱动被上层应用调用的接口是socket，是一个典型的分层结构，底层和上层是完全被socket接口隔离的。

（2）但是在uboot中网络底层驱动和上层应用是黏在一起的，不分层。意思就是上层网络的每一个应用都是自己去调用底层驱动中的操作硬件的代码来实现的。

（3）uboot中有很多预先设计的需要用到网络的命令，和我们直接相关的就是ping和tftp这两个命令。这两个命令在uboot中也是需要用相应的宏开关来打开或者关闭的。

（4）经过代码检查，发现ping命令开关宏为CONFIG_CMD_PING，而tftp命令的开关为CONFIG_CMD_NET，确认添加。

### 12.14.3、代码实践

结果是ping和tftp命令都被识别了，但是都提示no ethernet found`````网络不通。为什么不通？因为还没做初始化等移植

### 12.14.4、实验现象分析

（1）因为我们没有自定义的网卡初始化函数（board_eth_init或者cpu_eth_init），所以uboot启动时初始化网卡时打印：Net:   Net Initialization Skipped

（2）eth.c中有2个很重要的全局变量：eth_devices（用来指向一个链表，这个链表中保存了当前系统中所有的网卡信息）和eth_current（eth_current指针指向当前我们正在操作的那个网卡）。

（3）在linux的网卡驱动体系中，有一个数据结构（struct eth_device）用来表示（封装）一个网卡的所有信息，系统中注册一个网卡时就是要建立一个这个结构体的实例，然后填充这个实例中的各个元素，最后将这个结构体实例加入到eth_devices这个链表上，就完成了注册。了解了这些之后，你就明白了网卡驱动在初始化时必须负责将自己注册到系统的网卡驱动体系中（其实就是把自己的eth_device结构体实例添加到eth_devices链表中）。如果你不做这个过程就会出现：网卡找不到的错误。

（4）分析当前的问题是：在305行判断eth_devices是否为NULL之前没有去做网卡驱动的注册，所以这里为NULL，所以打印出了“No ethernet found.”

### 12.14.5、DM9000驱动浏览

（1）想解决这个问题，就是要在305行之前去注册网卡驱动。注册网卡驱动的代码不能随便乱写，一定要遵守linux网卡驱动架构的要求。这一块的代码一般属于网卡驱动的一部分，像这里就在dm9000x.c中。

（2）dm9000x.c中的最后一个函数int dm9000_initialize(bd_t *bis)，这个函数就是用来注册dm9000网卡驱动的。

### 12.14.6、问题修复

（1）根据之前分析uboot函数，发现前面有2个函数预留的可以用来放网卡初始化函数的，经过对比感觉board_eth_init函数稍微合适点，于是乎去添加。

*****

# 13、uboot杂记-logo显示和fastboot原理

## 13.1、X210的uboot中LCD操作分析

### 13.1.1、新旧版本开发板的LCD模组差异

（1）2015.11月初之前购买的X210开发板都属于老版本，型号是X210V3；之后购买的开发板都是新版本的，型号是X210V3S。

（2）两个开发板主要电路是完全一样的，不同主要有3点：一个是把拨码开关换成了短路帽；另一个是LCD分辨率从800*480升级成1024*600；第三个是触摸屏芯片型号换了。

### 13.1.2、背光电路分析

（1）LCD的背光源有2种设计。一种是简单设计，背光只能点亮和熄灭两种状态，不能调亮度；另一种设计类似手机屏幕可以调节亮度。第一种设计很简单，就是开和关。第二种模式比较复杂，需要一个额外的PWM调光IC来支持，X210的LCD模组上使用MP3202芯片来做调光。

（2）分析原理图和MP3202的数据手册，可以得出结论：
第一：PWMTOUT0（GPD0_0）接在了IC的FB引脚上，SoC应该通过该引脚输出一个频率合适的PWM波形给调光IC，这个波形的占空比就会控制MP3202输出的电流大小，从而控制屏幕亮度。
第二：L_DISP（DISP、SYS_OE、GPF3_5）接在了MP3202的EN引脚上，SoC应该给该引脚一个高电平来让背光工作，或者给一个低电平来让背光不工作。

（3）综合分析：背光要点亮，要同时满足以上两个条件。GPD0_0要输出低电平或者PWM信号，同时GPF3_5要输出一个高电平。一般来说我们在uboot中都把GPD0_0设置成输出模式然后输出低电平来点亮背光。

### 13.1.3、X210的uboot中LCD代码分析

（1）在uboot-jiuding/board.c中init_sequence中的display_banner中的open_backlight函数中给GPF3_5输出高电平。但是这个其实是可以省略的，注释掉这一句uboot的LCD显示照样正常的，主要原因是后面LCD操作的部分还会再做一遍的。

（2）真正的初始化LCD系统并且显示logo是在start_armboot函数的后段的x210_preboot_init中。这个函数纯粹是九鼎在移植时添加的。如果我们自己移植uboot可以考虑自己去添加。在追代码的过程中发现，x210_preboot_init函数内部只调用了mpadfb_init函数，原因是有一个函数调用的层次逻辑在里面，x210_preboot_init函数放在board目录下属于我们开发板初始化的一部分属于软件部分，mpadfb_init函数在我们uboot中是放在driver目录下是属于驱动文件的。这就是框架分层的概念

*****

## 13.2、logo显示和LCD屏幕分辨率适配

### 13.2.1、LCD驱动mpadfb.c分析

```c
	info.bitmap.info.width = lcd.width;
	info.bitmap.info.height = lcd.height;
	info.bitmap.info.bpp = lcd.bpp;
	info.bitmap.info.bytes_per_pixel = lcd.bpp / 8;
	info.bitmap.info.pitch = lcd.width * lcd.bpp / 8;

	info.bitmap.info.red_mask_size = lcd.rgba.r_mask;
	info.bitmap.info.red_field_pos = lcd.rgba.r_field;
	info.bitmap.info.green_mask_size = lcd.rgba.g_mask;
	info.bitmap.info.green_field_pos = lcd.rgba.g_field;
	info.bitmap.info.blue_mask_size = lcd.rgba.b_mask;
	info.bitmap.info.blue_field_pos = lcd.rgba.b_field;
	info.bitmap.info.alpha_mask_size = lcd.rgba.a_mask;
	info.bitmap.info.alpha_field_pos = lcd.rgba.a_field;

	info.bitmap.info.fmt = get_bitmap_format(&(info.bitmap.info));

	info.bitmap.info.fg_r = 0xff;
	info.bitmap.info.fg_g = 0xff;
	info.bitmap.info.fg_b = 0xff;
	info.bitmap.info.fg_a = 0xff;

	info.bitmap.info.bg_r = 0x00;
	info.bitmap.info.bg_g = 0x00;
	info.bitmap.info.bg_b = 0x00;
	info.bitmap.info.bg_a = 0x00;

	info.bitmap.viewport.left = 0;
	info.bitmap.viewport.top = 0;
	info.bitmap.viewport.right = lcd.width;
	info.bitmap.viewport.bottom = lcd.height;

	info.bitmap.allocated = 0;
	info.bitmap.data = lcd.vram;
```



（1）fb_init函数给framebuffer相关的数据结构赋值。左值的info是一个结构体，这个结构体描述fb驱动中的硬件设备参数的，右值的lcd是自己定义的一个数据结构，里面的值都是我们人为配置给驱动体系的。

（2）lcd_port_init看名字是lcd端口的初始化，端口就是GPIO，所以这个函数是在初始化LCD相关的SoC的引脚。

（3）lcd_reg_init看名字是LCD的寄存器的初始化，就是SoC的LCD控制器中的那些寄存器的初始化。

（4）以上三个函数调用执行完后，LCD初始化就结束了。然后向LCD写东西就能显示了。但是你要注意背光是否被点亮了。后面剩下的事情就是写东西和开背光两个了。

（5）display_logo(&s5pv210_fb);这个函数负责把logo图片写到LCD的fb中去。backlight_brigness_init(1);负责开背光。

### 13.2.2、解决新版开发板X210BV3S的logo显示问题

（1）用旧版本的uboot.bin下载到新版开发板中，发现能工作，但是屏幕logo显示不正常（屏幕下面有一条显示不正常的，然后logo是显示出来的但是不在屏幕正中间）。

（2）原因分析：主要原因新版开发板LCD屏幕的分辨率是1024*600而旧版分辨率是800*480.所以旧版本的uboot在新版开发板上运行时，就会造成屏幕填充不满（现象就是下面有一排显示不正常的），还会造成显示内容位置偏移，本来在中间结果偏左了。

（3）解决方案：很简单，在uboot中将LCD的参数部分，分辨率改成1024*600即可。

### 13.2.3、logo显示代码分析

（1）logo是以工具将图片做成二进制的字符串数据。

（2）显示时通过计算将logo代表的矩形放在屏幕正中央

（3）绘图时先绘制背景色，然后在logo矩形中写入logo图片内容即可。

****

## 13.3、fastboot的基本分析

### 13.3.1、什么是fastboot

（1）fastboot是android使用的一种刷机方法.android系统设计了2种刷机方式：fastboot和recovery。

（2）fastboot使用usb作为物理传输。刷机其实就是镜像传输+烧录，fastboot刷机时就是通过usb线来传输镜像的。

（3）fastboot是uboot中的一个命令。uboot进入命令行中后，如果需要刷机，则可以在命令行执行fastboot命令就可以让uboot进入fastboot模式，刷机就是在fastboot模式下进行的。

（4）fastboot需要主机端的fastboot软件配合。要实现fastboot刷机，只有开发板端uboot是不行的，还需要在主机上有fastboot.exe的软件配合。

（5）fastboot在开发板和主机间定义了一套协议。其实fastboot是我们在开发板和主机之间定义的一套协议，这套协议以usb为底层传输物理层，协议规定了主机fastboot软件和开发板fastboot软件之间的信息传输规则。消息传递可以实现功能有：主机可以向开发板发送命令、开发板可以向主机发送回复、主机可以向开发板发送文件（download）

### 13.3.2、fastboot的工作原理

（1）uboot的fastboot命令将开发板伪装成一个usb从设备。开发板本身并不是一个usb设备，所以开发板直接插到电脑上电脑是没有反应，没有提示发现设备需要装驱动的。伪装之后开发板就被主机windows识别成一个安卓手机了。

（2）主机的fastboot软件和开发板的fastboot程序通信来工作。平时工作时，开发板端只要执行了fastboot命令进入fastboot模式即可，剩下的就不用管了。主机端通过运行fastboot命令，传递不同的参数来实现主机端和开发板端的通信。
譬如主机端执行fastboot devices，则这个命令通过USB线被传递到开发板中被开发板的fastboot程序接收，接收后去处理然后向主机端发送反馈信息，主机端接收到反馈信息后显示出来。

（2）我们学习fastboot时分析代码的思路就是：
主机端：fastboot.exe的源代码没有，fastboot协议虽然能找到但是很枯燥，所以主机端没有去分析的。
开发板端：主要分析点就是uboot如何进入fastboot模式，fastboot模式下如何响应主机发送的各种命令。

*****

## 13.4、uboot的fastboot代码分析

### 13.4.1、do_fastboot函数

（1）do_fastboot函数本身涉及到很多操作SD/Nand等磁盘的，主要目的是为了刷机。要完整的分析fastboot的函数细节很复杂很麻烦，我们并不是要做这个。

### 13.4.2、关键点：rx_handler（顺藤摸瓜一路找下去）

do_fastboot
	fastboot_poll
		fboot_usb_int_hndlr
			fboot_usb_pkt_receive
				fboot_usb_int_bulkout
					fastboot_interface->rx_handler（函数指针）
						指向cmd_fastboot.c/rx_handler
找的过程涉及到USB物理层通信的一些概念和理解，相对比较复杂。最终uboot这边的fastboot是通过rx_handler函数来处理主机端fastboot软件发送过来的信息的。fastboot协议的命令实现都在这个函数中提现。所以这个函数的分析就是重点。

### 13.4.3、代码分析

（1）大文件download机制
rx_handler函数中通过if和else分成了两部分，if部分负责处理download，else部分负责处理命令。usb传输单次传输最大只能有限个字节（64、256），因此当我们发送比较小的东西（譬如命令）时可以单次传输完毕；当我们发送比较大的东西（譬如文件）时就必须要分包发送。

（2）down后的响应机制。开发板端通过fastboot_tx_status函数向主机发送响应，主机显示这个响应。

（3）uboot中fastboot有关的一些宏定义设置值
CFG_FASTBOOT_TRANSFER_BUFFER	配置fastboot工作时的缓冲区地址，fastboot在执行某些功能时需要大块内存做缓冲区（譬如download时），这里就是在给他配置缓冲区。
CFG_FASTBOOT_TRANSFER_BUFFER_SIZE  fastboot缓冲区的大小。
注意：很多同学在之前刷机时，烧录uboot和zImage都正常，但是烧录android镜像x210.img时错误，提示：image too large...（意思是文件太大）。这个错误的原因就是x210.img太大了，超出了CFG_FASTBOOT_TRANSFER_BUFFER_SIZE所以放不下了，所以uboot的fastboot这里报错了。

### 13.4.4、fastboot命令响应之：fastboot reboot

==注意==：只要是存储类设备的第一个扇区都是不存储东西的，主要原因就是，扇区0都是用来存放MBR的，MBR就是这个设备的分区信息。

（1）作用：在PC机这边可以远程重启开发板，当开发板接收到reboot命令之后就会去执行do_reset函数，这个函数就会重启开发板

### 13.4.5、fastboot命令响应之：fastboot getvar

（1）作用是得到一些fastboot中定义的变量名的值，譬如version、product。。。。。

### 13.4.6、fastboot命令响应之：fastboot erase

### 13.4.7、fastboot命令响应之：fastboot download

### 13.4.8、fastboot命令响应之：fastboot boot

### 13.4.9、fastboot命令响应之：fastboot flash

### 13.4.10、fastboot命令响应之：fastboot oem

（1）oem命令是用户自定义的。其他命令全都是fastboot协议定义的，但是有时候自带的命令不足以使用，oem厂商可能希望定义一些自己专有的命令，则可以使用oem命令。

*****

# 14、话说linux内核

## 14.1、内核和发行版的区别

### 14.1.1、到底什么是操作系统

（1）linux、windows、android、ucos就是操作系统

（2）操作系统本质上是一个程序，由很多个源文件构成，需要编译连接成操作系统程序（vmlinz、zImage）

（3）操作系统的主要作用就是管理计算机硬件，给应用程序提供一个运行环境。

### 14.1.2、操作系统核心功能

（1）内存管理。如果没有操作系统，内存是需要程序自己来管理的。譬如在uboot中要使用内存的哪里是自己随便用的，没有注册也没有限制。这时候如果程序自己不小心把同一块内存重复用了就会出现程序逻辑错误。系统大了之后（内存多了）内存管理非常麻烦；有了操作系统之后，操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要向操作系统去申请和注册，由操作系统的内存管理模块来分配内存给你使用，这样好处是可以保证内存使用不会冲突。

（2）进程调度。操作系统下支持多个应用程序同时运行（所以可以一边聊QQ一边看电影···），这是宏观上的并行。实际上在单核心CPU上微观上是不能并行的，宏观上的并行就是操作系统提供的分时复用机制。操作系统的进程调度模块负责在各个进程之间进行切换。

（3）硬件设备管理。没有操作系统时要控制任何硬件都要自己写代码，有了操作系统后操作系统本身会去控制各个硬件，应用程序就不用考虑硬件的具体细节了。操作系统的硬件设备管理模块就是驱动模块。

（4）文件系统。文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成的，每个扇区有512/1024/2048/4096字节，存储设备要以扇区为单位进行读写。如果没有文件系统，程序要自己去读写扇区，就得记得哪个文件在哪个扇区。有了文件系统之后我们人不用再关注扇区，人只用关注文件系统中的目录和文件名，而不用管这个文件在物理磁盘的哪个扇区。

### 14.1.3、操作系统扩展功能

（1）协议栈

（2）有用的应用程序包。应用程序本身不属于操作系统内核的一部分，应用程序是给人用的，面向某种功能的。譬如ping程序用来测试网络是否联通，ifconfig程序用来配置网卡。

### 14.1.4、内核和发行版的区别

区别：内核是操作系统内核的简称，内核负责实现操作系统的核心功能（资源管理模块，譬如内存管理、调度系统······），内核不包括应用程序。所以说只有内核人是没法用的，因为人做任何事情都是通过相应的应用程序来完成的。所以卖操作系统的人把内核和一些常用的应用程序打包在一起提供给普通用户，这就是操作系统的发行版（也就是普通意义上的操作系统）。

（1）内核只有一个。www.kernel.org

（2）发行版有很多。譬如ubuntu、redhat、suse、centos······

******

## 14.2、内核和驱动的关联

### 14.2.1、学习linux的思路

（1）对庞大的整体要有个认识。学习路线就是先建立框架和整体，然后逐渐去学习各个细节部分，逐步细化。

（2）对各分层的作用要清楚。

（3）对层次间的关联和互相调用要理解。

### 14.2.2、驱动属于内核的一部分

（1）驱动就是内核中的硬件设备管理模块

（2）驱动工作在内核态。整个操纵系统分为用户态和内核态两个状态，主要区别是访问权限的不同

（3）驱动程序故障可能导致整个内核崩溃

（4）驱动程序漏洞会使内核不安全

******

## 14.3、内核和应用程序、根文件系统的关联

### 14.3.1、应用和内核的关系

（1）应用程序不属于内核，而是在内核之上的

（2）应用程序工作在用户态，是受限制的。

（3）应用程序故障不会导致内核崩溃

（4）应用程序通过内核定义的API接口来调用内核工作

（5）总结1：应用程序是最终目标，操作系统和驱动的最终目的就是为了服务于应用程序

（6）总结2：内核就是为应用程序提供底层资源管理的服务员

### 14.3.2、内核和根文件系统

（1）根文件系统提供根目录。

（2）进程1存放在根文件系统中，进程1是在内核启动之后的第一个用户态程序，也是cpu从内核态变成用户态的入口。没有进程1cpu就无法从内核态转变为用户态

（3）内核启动最后会去装载根文件系统。

（4）总结：根文件系统为操作系统启动提供了很多必备的资源：根目录、进程1

*****

## 14.4、linux内核的模块化设计

### 14.4.1、什么是模块化设计

（1）因为linux内核很庞大，代码量很大、东西很多，如果设计时完全设计成一体（各个文件、各个函数之间紧耦合），复杂度超出了人所能理解的范围。所以模块化设计也是一种必要。

（2）模块化设计就是内核中各个功能模块在代码上是彼此独立的，譬如说调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范的。模块化设计的目的就是实现功能模块的松耦合。

### 14.4.2、模块化设计的体现

（1）配置时可裁剪。linux内核在编译之前可以进行配置，配置时可以选择将组成内核的成千上万个模块每一个要或者不要。要了之后还有更多的一些细节的配置。

（2）模块化编译和安装。为了操作方便，逐渐从静态的升级变成了动态的升级（不需要重启系统，更不需要重新烧录系统）。这种动态的升级也是由模块化来支持的。

（3）源码中使用条件编译。这种在uboot中已经见过了。

### 14.4.3、模块化设计的好处

（1）功能可裁剪、灵活性

（2）可扩展性（动态安装卸载、新硬件支持）

（3）利于协作

### 14.4.4、模块化设计是一种普遍性的系统设计原则

*****

## 14.5、选择合适版本的内核

### 14.5.1、linux内核版本变迁简史

（1）linux0.01。初版

（2）linux0.11。很多讲linux内核源代码解析的书都是以这个版本为原本来讲。《图解linux内核设计的艺术》

（3）linux2.4。比较接近现代的版本，很多经典的书都是以2.4版本内核为参照的，譬如《LDD3》。linux2.4的晚期内核在前几年还会经常碰到有用的。

（4）linux2.6早期。2.6的早期和2.4晚期内核挺像的。

（5）linux2.6晚期。2.6的晚期内核较早期内核有一些改变，尤其是驱动相关的部分和一些头文件的位置。2.6的晚期内核目前还算是比较主流。

（6）linux3.x 4.x

### 14.5.2、如何选择合适的内核版本

（1）并不是越新版本的内核越好

（2）选择SoC厂家移植版本会减少工作量

### 14.5.3、S5PV210适用的内核版本

（1）2.6.35.7+android2.3/QT4.8.3

（2）3.0.8+android4.0

本课程使用的是2.6.35.7版本内核讲解

*****

# 15、内核的配置和编译原理

## 15.1、linux内核源码目录结构

### 15.1.1、源码从哪里来

（1）之前讲过，我们使用2.6.35.7版本的内核。这个版本的内核有三种：第一种是kernel.org上的官方版本，第二种是三星移植过的，第三种是九鼎X210的移植版本。我们讲课时使用第三种内核来讲解，后面的移植实验使用第二种内核来移植。

（2）源码在开发板光盘中有。可以自己去linux下解压然后make distclean清理然后再次打包传输到windows下去解压分析；也可以直接去我网盘中下载我打包好的。

（4）解压后最终在windows下得到了一个kernel的源码目录树，这个源码目录就是九鼎以三星移植过的内核为原材料自己针对X210移植后的内核版本。

### 15.1.2、分析源码目录下的单个文件

（1）Kbuild，Kbuild是kernel build的意思，就是内核编译的意思。这个文件就是linux内核特有的内核编译体系需要用到的文件。

（2）Makefile，这个是linux内核的总makefile，整个内核工程用这个Makefile来管理的。

（3）mk，是九鼎在移植时自己添加的，不是linux内核本身的东西。九鼎添加这个文件的作用是用这个文件来整天管理kernel目录的配置和编译，也就是说这个文件有点类似于我们之前移植uboot时自己创建的那个cp.sh。

### 15.1.3、简单讲一下linux内核的配置体系。

（1）linux内核很庞大，里面模块很多，而且可配置性非常高。所以linux源代码的配置是一个很复杂的事情，必须要有一套很复杂的机制来保证linux内核可以被正确的配置。（对比一下uboot，uboot的配置项都是在xxx.h中，用宏定义来表示的。uboot的这种方式很依赖于人的水平，因为uboot的配置体系很简单。）

（2）linux内核本身配置项有上千个，光靠人眼睛去看脑袋去记根本不可能，所以内核发明了一种体系用来帮助人进行简单化的配置。这种体系就是我们本课程中重点要研究的东西。

（3）Kbuild、Kconfig等文件，都是和内核的配置体系有关的。

### 15.1.4、分析源码目录下的文件夹

（1）arch。arch是architecture的缩写，意思是架构。arch目录下是好多个不同架构的CPU的子目录，譬如arm这种cpu的所有文件都在arch/arm目录下，X86的CPU的所有文件都在arch/x86目录下。

（2）block。英文是块的意思，在linux中block表示块设备（以块（多个字节组成的整体，类似于扇区）为单位来整体访问），譬如说SD卡、iNand、Nand、硬盘等都是块设备。你几乎可以认为块设备就是存储设备。block目录下放的是一些linux存储体系中关于块设备管理的代码。

（3）crypto。英文意思是加密。这个目录下放了一些各种常见的加密算法的C语言代码实现。譬如crc32、md5、sha1等。

（4）Documentation。里面放了一些文档。

（5）drivers。驱动目录，里面分门别类的列出了linux内核支持的所有硬件设备的驱动源代码。

（6）firmware。固件。什么是固件？固件其实是软件，不过这个软件是固话到IC里面运行的叫固件。就像S5PV210里的iROM代码。

（7）fs。fs就是file system，文件系统，里面列出了linux支持的各种文件系统的实现。

（8）include。头文件目录，公共的（各种CPU架构共用的）头文件都在这里。每种CPU架构特有的一些头文件在arch/arm/include目录及其子目录下。

（9）init。init是初始化的意思，这个目录下的代码就是linux内核启动时初始化内核的代码。

（10）ipc。ipc就是inter process commuication，进程间通信，里面都是linux支持的IPC的代码实现。

（11）kernel。kernel就是内核，就是linux内核，所以这个文件夹下放的就是内核本身需要的一些代码文件。

（12）lib。lib是库的意思，这里面都是一些公用的有用的库函数，注意这里的库函数和C语言的库函数不一样的。在内核编程中是不能用C语言标准库函数，这里的lib目录下的库函数就是用来替代那些标准库函数的。譬如在内核中要把字符串转成数字用atoi，但是内核编程中只能用lib目录下的atoi函数，不能用标准C语言库中的atoi。譬如在内核中要打印信息时不能用printf，而要用printk，这个printk就是我们这个lib目录下的。

（13）mm。mm是memory management，内存管理，linux的内存管理代码都在这里。

（14）net。该目录下是网络相关的代码，譬如TCP/IP协议栈等都在这里。

（15）scripts。脚本，这个目录下全部是脚本文件，这些脚本文件不是linux内核工作时使用的，而是用来辅助对linux内核进行配置编译生产的。我们并不会详细进入分析这个目录下的脚本，而是通过外围来重点学会配置和编译linux内核即可。

（16）security。安全相关的代码。不用去管。

（17）sound。音频处理相关的。

（18）tools。linux中用到的一些有用工具

（19）usr。目录下是initramfs相关的，和linux内核的启动有关，暂时不用去管。

（20）virt。内核虚拟机相关的，暂时不用管。

总结：这么多目录跟我们关系很紧密的就是arch和drivers目录，然后其他有点相关的还有include、block、mm、net、lib等目录。

****

## 15.2、内核配置和编译体验

### 15.2.1、先确认Makefile

（1）主要是检查交叉编译工具链有没有设置对。CROSS_COMPILE   ?= /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

（2）确认ARCH = arm。主要目的是为了编译时能找到arch/arm目录。

### 15.2.2、make x210ii_qt_defconfig

（1）最后只要出现：configuration written to .config这句话，就证明我们的操作是正确的。如果没有出现这句话，就有错误。

（2）可能出现的错误1：名字敲错了。名字是字符串匹配的，一定要正确。
注意：如果这一步配置没有得到.config文件，是不能进行到下一步的。实际测试时没有.config也可以make menuconfig，但是这样做出来的内核编译和烧写运行应该是有问题的。

### 15.2.3、make menuconfig

（1）可能出现的错误1：ncurses库没装
错误信息：
 ** * Unable to find the ncurses libraries or the
 ** * required header files.
 ** * 'make menuconfig' requires the ncurses libraries.**

** * Install ncurses (ncurses-devel) and try again.

解决方案：  apt-get install libncurses5-dev 

（2）可能出现的错误2：屏幕太小
错误信息：
Your display is too small to run Menuconfig!
It must be at least 19 lines by 80 columns.
解决方案：全屏，或者是把字体调小。

总结：make menuconfig是第二步配置，具体的用法和配置意义在后面课程讲。我们这里因为是九鼎已经移植过的，所以第二步配置是可以不做的，直接退出即可。
用键盘的向右方向键移动到EXIT，按回车退出。

### 15.2.4、make

（1）可能出现的错误1：莫名其妙的错误，可以试试先make distclean

（2）代码本身的错误：具体问题具体分析

（3）编译完成后得到的内核镜像不在源码树的根目录下，在arch/arm/boot这个目录下。得到的镜像名是zImage

*****

## 15.3、内核的配置原理

### 15.3.1、烧写测试

### 15.3.2、配置的关键是得到.config文件

（1）.config以.开头，是一个隐藏文件，因此平时是看不到的，需要ls -a来看

（2）当我们make distclean后（也就是说默认情况下）是没有.config文件的，我们配置的两步过程就是为了得到内容合适的.config文件

（3）.config文件是linux内核在编译过程中很重要的一个文件，其作用类似与uboot中的include/configs/x210_sd.h，内核在编译过程中会读取.config中的配置项，并且用这些配置项去指导整个编译链接过程。

（4）.config文件的格式类似于脚本文件，其中内容为类似于于：CONFIG_ARM=y的一个一个的配置项。这些配置项就类似于脚本文件中定义的一个一个变量，所以这一行可以被理解为定义了一个变量CONFIG_ARM，这个变量的值为y。

（5）.config文件中每一行都是一个配置项，从.config文件的规模可以看出linux内核的可配置项有两三千个。所以linux内核是高度可配置的，而且linux内核的所有配置项很难全部搞明白。因为linux内核的配置项太多太繁杂超出了人的大脑能够记忆和处理的数量级，因此linux内核不像uboot那样直接手工配置，而是发明了一个图形化的配置工具menuconfig。

### 15.3.3、make xx_defconfig和make menuconfig相配合

（1）我们为了对.config文件中的两三千个配置项做逐一合适的配置，专门发明了两步结合的配置方式。

（2）其实只要人的记忆足够好，大脑足够厉害，完全可以手工去书写/修改.config文件完成内核配置，最终只要.config中内容是正确的，就不影响编译过程。

（3）第一步：make xxx_defconfig解决的问题是大部分的配置项（这一步结束后99%的配置项就已经正确了），下来就是对个别不同的针对我们的开发板进行细节调整，细节调整就通过make menuconfig来完成。

（4）make xxx_defconfig这一步其实是参考别人已经做好的，这样做有很多好处：减少很多工作量，避开了很多自己不懂的配置项（譬如对内存管理的、调度系统的等模块的配置项），我们只用管自己需要管的。

（5）make menuconfig其实就是读取第一步得到的.config，然后给我们一个图形化的界面，让我们可以更加容易的找到自己想要修改的配置项，然后更改配置他。

### 15.3.4、make xx_defconfig到底做了什么

（1）make x210ii_qt_defconfig其实相当于：cp arch/arm/configs/x210ii_qt_defconfig .config

（2）arch/arm/configs目录下的这么多个xxx_defconfig哪里来的？其实这些文件都是别人手工配置好适合一定的开发板的.config文件后自己把.config文件保存过去的。譬如说我们用S5PV210这个SoC，针对这个SoC的开发板的最初配置肯定是三星的工程师去做的。

****

## 15.4、menuconfig的使用和演示

### 15.4.1、使用说明解释

（1）make ，menuconfig中本身自带的提示就有所有的用法，这里只要全部理解就可以了。

（2）menuconfig中间的选择区中有很多个选择项，每个选择项对应.config文件中的一个配置项，每一个选择项都可以被选择和配置操作，选择区中的每一项都是有子目录的，将光标放在选择项上按Enter键可以进入子目录（子目录可能还会有子目录）。选择区太短放不下所有的一个目录层级的选项，可以用箭头按键的向上箭头和向下箭头来上翻和下翻。

注：在menuconfig中操作相关的几个键盘按键，主要是；Enter、ESC、四个方向箭头按键。还有一些特殊字符按键，如/  ? 
向上和向下箭头，主要用来在选择项菜单中目录浏览时上下翻
回车，主要作用是选中并且执行select/exit/help。
ESC，主要作用是返回上一层
向左和向右箭头，主要作用是在菜单选项（select、exit、help）间切换。

（3）用法翻译：
箭头按键导航整个菜单，回车按键选择子菜单（注意选项后面有 --->的选项才是有子菜单的，没有这个标识的没有子菜单），高亮的字母是热键（快捷键），键盘按键Y、N、M三个按键的作用分别是将选中模块编入、去除、模块化。双击ESC表示退出，按下？按键可以显示帮助信息，按下/按键可以输入搜索内容来全局搜索信息（类似于vi中的搜索），[]不可以模块化，<>的才可以模块化。

注：linux内核中一个功能模块有三种编译方法：一种是编入、一种去去除、一种是模块化。所谓编入就是将这个模块的代码直接编译连接到zImage中去，去除就是将这个模块不编译链接到zImage中，模块化是将这个模块仍然编译，但是不会将其链接到zImage中，会将这个模块单独链接成一个内核模块.ko文件，将来linux系统内核启动起来后可以动态的加载或卸载这个模块。
在menuconfig中选项前面的括号里，*表示编入，空白表示去除，M表示模块化

*****

## 15.5、menuconfig的工作原理

### 15.5.1、menuconfig本身由一套软件支持

（1）linux为了实现图形化界面的配置，专门提供了一套配置工具menuconfig。

（2）ncurses库是linux中用来实现文字式的图形界面，linux内核中使用了ncurses库来提供menuconfig

（3）scripts\kconfig\lxdialog目录下的一些c文件就是用来提供menuconfig的那些程序源代码。

### 15.5.2、menuconfig读取Kconfig文件

（1）menuconfig本身的软件只负责提供menuconfig工作的这一套逻辑（譬如在menuconfig中通过上下左右箭头按键来调整光标，Enter ESC键等按键按下的响应），而并不负责提供内容（菜单里的项目）。

（2）menuconfig显示的菜单内容（一方面是菜单的目录结构，另一方面是每一个菜单项目的细节）是由内核源码树各个目录下的Kconfig文件来支持的。Kconfig文件中按照一定的格式包含了一个又一个的配置项，每一个配置项在make menuconfig中都会成为一个菜单项目。而且menuconfig中显示的菜单目录结构和源码目录中的Kconfig的目录结构是一样的。

（3）在相应的Kconfig文件中删除一个config项，则再次make menuconfig时这个项目已经看不到了。

### 15.5.3、menuconfig读取/写入.config文件

（1）刚才已经知道menuconfig的菜单内容来自于Kconfig文件，但是每一个菜单的选择结果（Y、N、M）却不是保存在Kconfig文件中的。Kconfig文件是不变的，Kconfig文件只是决定有没有这个菜单项，并不管这个菜单项的选择结果。

（2）menuconfig工作时在我们make menuconfig打开时，他会读取.config文件，并且用.config文件中的配置选择结果来初始化menuconfig中各个菜单项的选择值。

总结：菜单项的项目内容从Kconfig文件来，菜单项的选择值从.config文件来

（3）当我们每次退出make menuconfig时，menuconfig机制会首先检查我们有没有更改某些配置项的值，如果我们本次没有更改过任意一个配置项目的值那直接退出；如果我们有改动配置项的值则会提示我们是否保存。此时如果点保存，则会将我们更改过的配置重新写入.config文件中记录，下一次再次打开make menuconfig时会再次加载.config，最终去编译内核时编译连接程序会考虑.config中的配置值指导整个编译连接过程。

总结：本节课主要内容就是讲：menuconfig和Kconfig和.config的关系。

****

## 15.6、Kconfig文件详解

### 15.6.1、Kconfig的格式

（1）Kconfig按照一定的格式来书写，menuconfig程序可以识别这种格式，然后从中提取出有效信息组成menuconfig中的菜单项。

（2）将来在做驱动移植等工作时，有时需要自己添加Kconfig中的一个配置项来将某个设备驱动添加到内核的配置项目中，这时候就需要对Kconfig的配置项格式有所了解，否则就不会添加。

（3）#开头的行是注释行

（4）menuconfig表示菜单（本身属于一个菜单中的项目，但是他又有子菜单项目）、config表示菜单中的一个配置项（本身并没有子菜单下的项目）。

（5）menuconfig或者config后面空格隔开的大写字母表示的类似于 NETDEVICES 的就是这个配置项的配置项名字，这个字符串前面添加CONFIG_后就构成了.config中的配置项名字。

（6）一个menuconfig后面跟着的所有config项就是这个menuconfig的子菜单。这就是Kconfig中表示的目录关系。

（7）内核源码目录树中每一个Kconfig都会source引入其所有子目录下的Kconfig，从而保证了所有的Kconfig项目都被包含进menuconfig中。这个也告诉我们：如果你自己在linux内核中添加了一个文件夹，一定要在这个文件夹下创建一个Kconfig文件，然后在这个文件夹的上一层目录的Kconfig中source引入这个文件夹下的Kconfig文件。

### 15.6.2、tristate和bool的含义

（1）tristate意思是三态（3种状态，对应Y、N、M三种选择方式），bool是要么真要么假（对应Y和N）。所以tristate的意思就是这个配置项可以被三种选择，bool的意思是这个配置项只能被2种选择。

### 15.6.3、depends的含义

（1）depends中文意思是“取决于”或者“依赖于”，所以depends在这里的意思是：本配置项依赖于另一个配置项。如果那个依赖的配置项为Y或者M，则本配置项才有意义；如果依赖的哪个配置项本身被设置为N，则本配置项根本没有意义。

（2）depends项目会导致make menuconfig的时候找不到一些配置项。所以你在menuconfig中如果找不到一个选项，但是这个选项在Kconfig中却是有的，则可能的原因就是这个配置项依赖的一个配置项是不成立的。

（3）depends并不要求依赖的配置项一定是一个，可以是多个，而且还可以有逻辑运算。这种时候只要依赖项目运算式子的裸机结果为真则依赖就成立。

### 15.6.4、help

（1）帮助信息，告诉我们这个配置项的含义，以及如何去配置他。

### 15.6.5、Kconfig和.config文件和Makefile三者的关联

（1）配置项被配置成Y、N、M会影响.config文件中的CONFIG_XXX变量的配置值。

（2）这个.config中的配置值（=y、=m、没有）会影响最终的编译链接过程。如果=y则会被编入（built-in），如果=m会被单独连接成一个ko模块，如果没有则对应的代码不会被编译。那么这么是怎么实现的？都是通过makefile实现的。

（3）obj-$(CONFIG_DM9000) += dm9000.o
如果CONFIG_DM9000变量值为y，则obj += dm9000.o，因此dm9000.c会被编译；如果CONFIG_DM9000变量未定义，则dm9000.c不会被编译。如果CONFIG_DM9000变量的值为m则会被连接成ko模块（这个是在linux内核的Makefile中定义的规则）

总结：把menuconfig中的菜单项、Kconfig中的配置项、.config中的一行、 Makefile中的一行，这4个东西结合起来理解，则整个linux内核的配置体系就明了了。

*****

## 15.7、menuconfig的实验学习思路

### 15.7.1、验证menuconfig和.config的关系

（1）make menuconfig时，会读取.config中的配置值来初始化menuconfig中的配置项。
验证：如果理论正确的，那么我自己手工修改了.config的配置后，再次make menuconfig时看到的初始值就应该是我手工修改的。

（2）menuconfig中修改了（按Y、N、M）配置项的值，然后退出时保存，则这个保存结果会修改.config文件中的相应行。
验证：如果结论是正确的，那么在menucofig中修改了配置后保存退出，再次去手工打开.config文件则可以看到相应配置的一行内容被修改了。

### 15.7.2、验证menuconfig和Kconfig的关系

（1）menuconfig读取Kconfig的内容作为菜单项目内容。
验证1：在Kconfig中删除一个config项，则再次make menuconfig时就看不到这个项目了。（上课时已经验证过了）
验证2：在Kconfig中自己添加创建一个config项，则再次make menuconfig时就能看到多了一个项目。

### 15.7.3、验证验证menuconfig和Makefile的关系
（1）我找一个模块，把他配制成y，然后去make编译连接，最后得到的zImage中这个模块就应该被编译连接进去到zImage中了。
验证：
	方法一：去这个模块对应的源代码目录看一下这个源码有没有被编译
	方法二：去zImage对应的elf格式的vmlinux中查看符号
	方法三：将vmlinux反编译（objdump）后得到的文件中找模块对应的符号
	方法四：将zImage下载到开发板中启动，启动后看你的模块能不能工作

*****

# 16、内核的启动过程分析

## 16.1、内核分析的准备工作

### 16.1.1、删除无用文件

（1）官方版本的kernel中是支持各种硬件架构、各种开发板的，因此有很多文件夹和文件和我们无关，在建立SI工程前应该删掉这些家伙。

（2）我们现在分析的是开发板厂商九鼎科技移植好的针对X210开发板的kernel，因此其中一些无用文件已经被删掉了。

### 16.1.2、建立SI工程并解析

（1）建立方法和uboot中当时讲的是一样的。

### 16.1.3、Makefile分析

（1）kernel的Makefile写法和规则等和uboot的Makefile是一样的，甚至Makefile中的很多内容都是一样的。

（2）kernel的Makefile比uboot的Makefile要复杂，这里我们并不会一行一行的详细分析。

（3）Makefile中只有一些值得关注的我会强调一下，其他不强调的地方暂时可以不管。

（4）Makefile中刚开始定义了kernel的内核版本号。这个版本号挺重要（在模块化驱动安装时会需要用到），要注意会查，会改。

（5）在make编译内核时，也可以通过命令行给内核makefile传参（跟uboot配置编译时传参一样）。譬如make O=xxx可以指定不在源代码目录下编译，而到另外一个单独文件夹下编译。

（6）kernel的顶层Makefile中定义了2个变量很重要，一个是ARCH，一个是CROSS_COMPILE。ARCH决定当前配置编译的路径，譬如ARCH = arm的时候，将来在源码目录下去操作的arch/arm目录。CROSS_COMPILE用来指定交叉编译工具链的路径和前缀。

（7）CROSS_COMPILE = xxx和ARCH = xxx和O=xxx这些都可以在make时通过命令行传参的方式传给顶层Makefile。
所以有时候你会看到别人编译内核时：make O=/tmp/mykernel ARCH=arm CROSS_COMPILE=/usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

### 16.1.4、链接脚本分析

（1）分析连接脚本的目的就是找到整个程序的entry

（2）kernel的连接脚本并不是直接提供的，而是提供了一个汇编文件vmlinux.lds.S，然后在编译的时候再去编译这个汇编文件得到真正的链接脚本vmlinux.lds。

（3）vmlinux.lds.S在arch/arm/kernel/目录下。

（4）思考：为什么linux kernel不直接提供vmlinux.lds而要提供一个vmlinux.lds.S然后在编译时才去动态生成vmlinux.lds呢？
猜测：.lds文件中只能写死，不能用条件编译。但是我们在kernel中链接脚本确实有条件编译的需求（但是lds格式又不支持），于是乎kernel工作者找了个投机取巧的方法，就是把vmlinux.lds写成一个汇编格式，然后汇编器处理的时候顺便条件编译给处理了，得到一个不需要条件编译的vmlinux.lds。

（5）入门在哪里？从vmlinux.lds中ENTRY(stext)可以知道入口符号是stext，在SI中搜索这个符号，发现arch/arm/kernel/目录下的head.S和head-nommu.S中都有。

（6）head.S是启用了MMU情况下的kernel启动文件，相当于uboot中的start.S。head-nommu.S是未使用mmu情况下的kernel启动文件。

****

## 16.2、head.S文件分析

### 16.2.1、内核运行的物理地址与虚拟地址

（1）KERNEL_RAM_VADDR（VADDR就是virtual address），这个宏定义了内核运行时的虚拟地址。值为0xC0008000

（2）KERNEL_RAM_PADDR（PADDR就是physical address），这个宏定义内核运行时的物理地址。值为0x30008000

（3）总结：内核运行的物理地址是0x30008000，对应的虚拟地址是0xC0008000。

### 16.2.2、内核的真正入口

（1）内核的真正入口就是ENTRY(stext)处

（2）前面的__HEAD定义了后面的代码属于段名为.head.text的段

### 16.2.3、内核运行的硬件条件

（1）内核的起始部分代码是被解压代码调用的。回忆之前讲zImage的时候，uboot启动内核后实际调用运行的是zImage前面的那段未经压缩的解压代码，解压代码运行时先将zImage后段的内核解压开，然后再去调用运行真正的内核入口。

（2）内核启动不是无条件的，而是有一定的先决条件，这个条件由启动内核的bootloader（我们这里就是uboot）来构建保证。

（3）kernel启动时MMU是关闭的，因此硬件上需要的是物理地址。但是内核是一个整体（zImage）只能被连接到一个地址（不能分散加载），这个连接地址肯定是虚拟地址。因此内核运行时前段head.S中尚未开启MMU之前的这段代码就很难受。所以这段代码必须是位置无关码，而且其中涉及到操作硬件寄存器等时必须使用物理地址。

### 16.2.4、内核启动要求的传参方式

（1）ARM体系中，linux启动是有一定的硬性要求的（譬如，MMU是关的，D-cache是关的，I-cache不重要，r0 = 0，r1 = machine nr (机器码)，r2 = atags pointer(uboot传参首地址)）才能够启动，而我们在uboot中函数调用时实际是通过寄存器传参的（函数调用时传参有两种设计：一种是寄存器传参，另一种是栈内存传参）。所以uboot中最后theKernel (0, machid, bd->bi_boot_params);执行内核时，运行时实际把0放入r0中，machid放入到了r1中，bd->bi_boot_params放入到了r2中。ARM的这种处理技巧刚好满足了kernel启动的条件和要求。

****

## 16.3、内核启动的汇编阶段

### 16.3.1、__lookup_processor_type

（1）我们从cp15协处理器的c0寄存器中读取出硬件的CPU ID号，然后调用这个函数来进行合法性检验。如果合法则继续启动，如果不合法则停止启动，转向__error_p启动失败。

（2）该函数检验cpu id的合法性方法是：内核会维护一个本内核支持的CPU ID号码的数组，然后该函数所做的就是将从硬件中读取的cpu id号码和数组中存储的各个id号码依次对比，如果没有一个相等则不合法，如果有一个相等的则合法。

（3）内核启动时设计这个校验，也是为了内核启动的安全性着想。

### 16.3.2、__lookup_machine_type

（1）该函数的设计理念和思路和上面校验cpu id的函数一样的。不同之处是本函数校验的是机器码。

### 16.3.3、__vet_atags

（1）该函数的设计理念和思路和上面2个一样，不同之处是用来校验uboot给内核的传参ATAGS格式是否正确。这里说的传参指的是uboot通过tag给内核传的参数（主要是板子的内存分布memtag、uboot的bootargs）

（2）内核认为如果uboot给我的传参格式不正确，那么我就不启动。

（3）uboot给内核传参的部分如果不对，是会导致内核不启动的。譬如uboot的bootargs设置不正确内核可能就会不启动。

### 16.3.4、__create_page_tables

（1）顾名思义，这个函数用来建立页表。

（2）linux内核本身被连接在虚拟地址处，因此kernel希望尽快建立页表并且启动MMU进入虚拟地址工作状态。但是kernel本身工作起来后页表体系是非常复杂的，建立起来也不是那么容易的。kernel想了一个好办法

（3）kernel建立页表其实分为2步。第一步，kernel先建立了一个段式页表（和uboot中之前建立的页表一样，页表以1MB为单位来区分的），这里的函数就是建立段式页表的。段式页表本身比较好建立（段式页表1MB一个映射，4GB空间需要4096个页表项，每个页表项4字节，因此一共需要16KB内存来做页表），坏处是比较粗不能精细管理内存；第二步，再去建立一个细页表（4kb为单位的细页表），然后启用新的细页表废除第一步建立的段式映射页表。

（4）内核启动的早期建立段式页表，并在内核启动前期使用；内核启动后期就会再次建立细页表并启用。等内核工作起来之后就只有细页表了。

### 16.3.5、__switch_data

（1）建立了段式页表后进入了__ switch_data部分，这东西是个函数指针数组。

（2）分析得知下一步要执行__mmap_switched函数

（3）复制数据段、清除bss段（目的是构建C语言运行环境）

（4）保存起来cpu id号、机器码、tag传参的首地址。

（5）b	start_kernel跳转到C语言运行阶段。

总结：汇编阶段其实也没干啥，主要原因是uboot干了大部分活。汇编阶段主要就是校验启动合法性、建立段式映射的页表并开启MMU以方便使用内存、跳入C阶段。

****

## 16.4、内核启动的C语言阶段1–思路

### 16.4.1、学习思路

（1）抓大放小，不深究.

（2）感兴趣可以就某个话题去网上搜索资料学习

（3）重点局部深入分析

### 16.4.2、学习方法

（1）顺着代码执行路径抓全。这是我们的学习主线。

（2）对照内核启动的打印信息进行分析。

### 16.4.3、学习线路

（1）分析uboot给kernel传参的影响和实现

（2）硬件初始化与驱动加载

（3）内核启动后的结局与归宿

****

## 16.5、内核启动的C语言阶段2–setup_arch

### 16.5.1、琐碎

（1）smp。smp就是对称多处理器（其实就是我们说的多核心CPU）

（2）lockdep。锁定依赖，是一个内核调试模块，处理内核自旋锁死锁问题相关的。

（3）cgroup。control group，内核提供的一种可与限制、记录、隔离进程组所使用的物理资源的机制。

·······

==注意==：在Linux内核中有太多各种功能的函数，前期学习过程中不应该纠结于这些函数的实现原理，只需要关注它的整体框架结构，研究我们需要研究的东西即可。

### 16.5.2、打印内核版本信息

```c
//printk 打印级别信息
#define	KERN_EMERG	"<0>"	/* system is unusable			*/
#define	KERN_ALERT	"<1>"	/* action must be taken immediately	*/
#define	KERN_CRIT	"<2>"	/* critical conditions			*/
#define	KERN_ERR	"<3>"	/* error conditions			*/
#define	KERN_WARNING	"<4>"	/* warning conditions			*/
#define	KERN_NOTICE	"<5>"	/* normal but significant condition	*/
#define	KERN_INFO	"<6>"	/* informational			*/
#define	KERN_DEBUG	"<7>"	/* debug-level messages			*/
```

（1）代码位于：kernel/init/main.c中的572行

（2）printk函数是内核中用来从console打印信息的，类似于应用层编程中的printf。内核编程时不能使用标准库函数，因此不能使用printf，其实printk就是内核自己实现的一个printf。

（3）printk函数的用法和printf几乎一样，不同之处在于可以在参数最前面用一个宏来定义消息输出的级别。为什么要有这种级别？主要原因是linux内核太大了，代码量太多，里面的printk打印信息太多了。如果所有的printk都能打印出来而不加任何限制，则最终内核启动后得到海量的输出信息。

（4）为了解决打印信息过多，无效信息会淹没有效信息这个问题，linux内核的解决方案是给每一个printk添加一个打印级别。级别定义0-7（注意编程的时候要用相应的宏定义，不要直接用数字）分别代表8种输出的重要性级别，0表示最重要，7表示最不重要。我们在printk的时候自己根据自己的消息的重要性去设置打印级别。

（5）linux的控制台监测消息的地方也有一个消息过滤显示机制，控制台实际只会显示级别比我的控制台定义的级别高的消息。譬如说控制台的消息显示级别设置为4，那么只有printk中消息级别为0-3（也可能是0-4）的才可以显示看见，其余的被过滤掉了。

（6）linux_banner的内容解析。

### 16.5.3、setup_arch函数简介

（1）从名字看，这个函数是CPU架构相关的一些创建过程。

（2）实际上这个函数是用来确定我们当前内核的机器（arch、machine）的。我们的linux内核会支持一种CPU的运行，CPU+开发板就确定了一个硬件平台，然后我们当前配置的内核就在这个平台上可以运行。之前说过的机器码就是给这个硬件平台一个固定的编码，以表征这个平台。

（3）当前内核支持的机器码以及硬件平台相关的一些定义都在这个函数中处理。

### 16.5.4、Machine查找

（1）setup_processor函数用来查找CPU信息，可以结合串口打印的信息来分析。

（2）setup_machine函数的传参是机器码编号，machine_arch_type符号在include/generated/mach-types.h的32039-32050行定义了。经过分析后确定这个传参值就是2456.

（3）函数的作用是通过传入的机器码编号，找到对应这个机器码的machine_desc描述符，并且返回这个描述符的指针。

（4）其实真正干活的函数是lookup_machine_type，找这个函数发现在head-common.S中，真正干活的函数是__ lookup_machine_type

（5）__ lookup_machine_type函数的工作原理：`adr	r3, 4b`  这句代码的意思就是b代表向程序段的前面找4这个编号，我们发现那里写

```assembly
4:	
​	.long	.
​	.long	__arch_info_begin
​	.long	__arch_info_end
```

内核在建立的时候就把各种CPU架构的信息组织成一个一个的machine_desc结构体实例，然后都给一个段属性.arch.info.init，链接的时候会保证这些描述符会被连接在一起。__ lookup_machine_type就去`__ arch_info_begin`和`__arch_info_end`中间的描述符所在处依次挨个遍历各个描述符，比对看机器码哪个相同。

### 16.5.5、setup_arch函数进行了基本的cmdline处理

（1）这里说的cmdline就是指的uboot给kernel传参时传递的命令行启动参数，也就是uboot的bootargs。

（2）有几个相关的变量需要注意：
default_command_line：看名字是默认的命令行参数，实际是一个全局变量字符数组，这个字符数组可以用来存东西。
CONFIG_CMDLINE：在.config文件中定义的（可以在make menuconfig中去更改设置），这个表示内核的一个默认的命令行参数。

（3）内核对cmdline的处理思路是：内核中自己维护了一个默认的cmdline（就是.config中配置的这一个），然后uboot还可以通过tag给kernel再传递一个cmdline。如果uboot给内核传cmdline成功则内核会优先使用uboot传递的这一个；如果uboot没有给内核传cmdline或者传参失败，则内核会使用自己默认的这个cmdline。以上说的这个处理思路就是在setup_arch函数中实现的。

### 16.5.6、实验验证内核的cmdline确定

（1）验证思路：首先给内核配置时配置一个基本的cmdline，然后在uboot启动内核时给uboot设置一个bootargs，然后启动内核看打印出来的cmdline和uboot传参时是否一样。

（2）在uboot中去掉bootargs，然后再次启动内核看打印出来的cmdline是否和内核中设置的默认的cmdline一样。

注意：uboot给内核传递的cmdline非常重要，会影响内核的运行，所以要谨慎。有时候内核启动有问题，可以分析下是不是uboot的bootargs设置不对。

注意：这个传参在这里确定出来之后，还没完。后面还会对这个传参进行解析。解析之后cmdline中的每一个设置项都会对内核启动有影响。

思考：内核为什么要这样设计？

这样设计的好处就是，当内核被编译成功后，我们任然希望可以去修改它的一些配置，这给时候就可以用传参的方式将我们需要的配置信息传递给内核

****

## 16.6、内核启动的C语言阶段3–其余函数

### 16.6.1、setup_command_line

（1）也是在处理和命令行参数cmdline有关的任务。

### 16.6.2、parse_early_param&parse_args

（1）解析cmdline传参和其他传参

（2）这里的解析意思是把cmdline的细节设置信息给解析出来。譬如cmdline：console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3，则解析出的内容就是就是一个字符串数组，数组中依次存放了一个设置项目信息。
console=ttySAC2,115200  一个
root=/dev/mmcblk0p2 rw  一个
init=/linuxrc 			一个
rootfstype=ext3			一个

（3）这里只是进行了解析，并没有去处理。也就是说只是把长字符串解析成了短字符串，最多和内核里控制这个相应功能的变量挂钩了，但是并没有去执行。执行的代码在各自模块初始化的代码部分。

### 16.6.3、琐碎函数

（1）trap_init					设置异常向量表
（2）mm_init						内存管理模块初始化
（3）sched_init					内核调度系统初始化
（4）early_irq_init&init_IRQ		中断初始化
（5）console_init					控制台初始化，之前执行的函数所打印的信息在控制台初始化之前都是没有打印出来的，都是暂时放入了缓冲区，等控制台初始化后才打印出来的

总结：start_kernel函数中调用了很多的xx_init函数，全都是内核工作需要的模块的初始化函数。这些初始化之后内核就具有了一个基本的可以工作的条件了。

 如果把内核比喻成一个复杂机器，那么start_kernel函数就是把这个机器的众多零部件组装在一起形成这个机器，让他具有可以工作的基本条件。

### 16.6.4、rest_init

（1）这个函数之前内核的基本组装已经完成。

（2）剩下的一些工作就比较重要了，放在了一个单独的函数中，叫rest_init。

总结：start_kernel函数做的主要工作：打印了一些信息、内核工作需要的模块的初始化被依次调用（譬如内存管理、调度系统、异常处理···）、我们需要重点了解的就是setup_arch中做的2件事情：机器码架构的查找并且执行架构相关的硬件的初始化、uboot给内核的传参cmdline。

****

## 16.7、内核启动的C语言阶段4–rest_init

### 16.7.1、操作系统去哪了

（1）rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd

（2）调用schedule函数开启了内核的调度系统（操作系统内的好多个进程开始依次被执行的过程），从此linux系统开始转起来了。

（3）rest_init最终调用cpu_idle函数结束了整个内核的启动。也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。

（4）简单来说，linux内核最终的状态是：kernel的任务调度系统可以让cpu有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。

（5）之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。

### 16.7.2、什么是内核线程

（1）进程和线程。简单来理解，一个运行的程序就是一个进程。所以进程就是任务、进程就是一个独立的程序。独立的意思就是这个程序和别的程序是分开的，这个程序可以被内核单独调用执行或者暂停。

（2）在linux系统中，线程和进程非常相似，几乎可以看成是一样的。实际上我们当前讲课用到的进程和线程的概念就是一样的。

（3）进程/线程就是一个独立的程序。应用层运行一个程序就构成一个用户进程/线程，那么内核中运行一个函数（函数其实就是一个程序）就构成了一个内核进程/线程。

（4）所以我们kernel_thead函数运行一个函数，其实就是把这个函数变成了一个内核线程去运行起来，然后他可以被内核调度系统去调度。说白了就是去调度器注册了一下，以后人家调度的时候会考虑你。

### 16.7.3、进程0、进程1、进程2

（1）截至目前为止，我们一共涉及到3个内核进程/线程。

（2）操作系统是用一个数字来表示/记录一个进程/线程的，这个数字就被称为这个进程的进程号。这个号码是从0开始分配的。因此这里涉及到的三个进程分别是linux系统的进程0、进程1、进程2.

（3）在linux命令行下，使用ps命令可以查看当前linux系统中运行的进程情况。

（3）我们在ubuntu下ps -aux可以看到当前系统运行的所有进程，可以看出进程号是从1开始的。为什么不从0开始，因为进程0不是一个用户进程，而属于内核进程。

（5）三个进程
进程0：进程0其实就是刚才讲过的idle进程，叫空闲进程，也就是死循环。
进程1：kernel_init函数就是进程1，这个进程被称为init进程。
进程2：kthreadd函数就是进程2，这个进程是linux内核的守护进程。这个进程是用来保证linux内核自己本身能正常工作的。

总结1：本节课的重点在于理解linux内核启动后达到的一个稳定状态。注意去对比内核启动后的稳定状态和uboot启动后的稳定状态的区别。
总结2：本节课的第二个重点就是初步理解进程/线程的概念。
总结3：你得明白每个进程有个进程号，进程号从0开始依次分配的。明白进程0是idle进程（idle进程是干嘛的）；进程2是ktheadd进程（基本明白干嘛的就行）
总结4：分析到此，发现后续的料都在进程1.所以后面课程会重点从进程1出发，分析之后发生的事情。

****

## 16.8、init进程详解

### 16.8.1、init进程完成了从内核态向用户态的转变

（1）一个进程2种状态。init进程刚开始运行的时候是内核态，它属于一个内核线程，然后他自己运行了一个用户态下面的程序后把自己强行转成了用户态。因为init进程自身完成了从内核态到用户态的过度，因此后续的其他进程都可以工作在用户态下面了。

（2）内核态下做了什么？重点就做了一件事情，就是挂载根文件系统并试图找到用户态下的那个init程序。init进程要把自己转成用户态就必须运行一个用户态的应用程序（这个应用程序名字一般也叫init），要运行这个应用程序就必须得找到这个应用程序，要找到它就必须得挂载根文件系统，因为所有的应用程序都在文件系统中。

内核源代码中的所有函数都是内核态下面的，执行任何一个都不能脱离内核态。应用程序必须不属于内核源代码，这样才能保证自己是用户态。也就是说我们这里执行的这个init程序和内核不在一起，他是另外提供的。提供这个init程序的那个人就是根文件系统。

（3）用户态下做了什么？init进程大部分有意义的工作都是在用户态下进行的。init进程对我们操作系统的意义在于：其他所有的用户进程都直接或者间接派生自init进程。

（4）如何从内核态跳跃到用户态？还能回来不？
init进程在内核态下面时，通过一个函数kernel_execve来执行一个用户空间编译连接的应用程序就跳跃到用户态了。注意这个跳跃过程中进程号是没有改变的，所以一直是进程1.这个跳跃过程是单向的，也就是说一旦执行了init程序转到了用户态下整个操作系统就算真正的运转起来了，以后只能在用户态下工作了，用户态下想要进入内核态只有走API这一条路了。

### 16.8.2、init进程构建了用户交互界面

（1）init进程是其他用户进程的老祖宗。linux系统中一个进程的创建是通过其父进程创建出来的。根据这个理论只要有一个父进程就能生出一堆子孙进程了。

（2）init启动了login进程（为用户提供登录界面）、命令行进程（为用户提供命令行环境）、shell进程（负责提供命令行里的命令解析）

（3）shell进程启动了其他用户进程。命令行和shell一旦工作了，用户就可以在命令行下通过./xx的方式来执行其他应用程序，每一个应用程序的运行就是一个进程。

总结：本节的主要目的是让大家认识到init进程如何一步步发展成为我们平时看到的那种操作系统的样子。

### 16.8.3、打开控制台

（1）linux系统中每个进程都有自己的一个文件描述符表，表中存储的是本进程打开的文件。

（2）linux系统中有一个设计理念：一切届是文件。所以设备也是以文件的方式来访问的。我们要访问一个设备，就要去打开这个设备对应的文件描述符。譬如/dev/fb0这个设备文件就代表LCD显示器设备，/dev/buzzer代表蜂鸣器设备，/dev/console代表控制台设备。

（3）这里我们打开了/dev/console文件，并且复制了2次文件描述符，一共得到了3个文件描述符。这三个文件描述符分别是0、1、2.这三个文件描述符就是所谓的：标准输入、标准输出、标准错误。

（4）进程1打开了三个标准输出输出错误文件，因此后续的进程1衍生出来的所有的进程默认都具有这3个三件描述符。

### 16.8.4、挂载根文件系统

（1）prepare_namespace函数中挂载根文件系统

（2）根文件系统在哪里？根文件系统的文件系统类型是什么？ uboot通过传参来告诉内核这些信息。
uboot传参中的root=/dev/mmcblk0p2 rw 这一句就是告诉内核根文件系统在哪里，这是表示你的根目录在inand/SD 第0个设备的第二个分区
uboot传参中的rootfstype=ext3这一句就是告诉内核rootfs的类型。

（3）如果内核挂载根文件系统成功，则会打印出：VFS: Mounted root (ext3 filesystem) on device 179:2.
如果挂载根文件系统失败，则会打印：No filesystem could mount root, tried:  yaffs2

（4）如果内核启动时挂载rootfs失败，则后面肯定没法执行了，肯定会死。内核中设置了启动失败休息5s自动重启的机制，因此这里会自动重启，所以有时候大家会看到反复重启的情况。

（4）如果挂载rootfs失败，可能的原因有：
	最常见的错误就是uboot的bootargs设置不对。
	rootfs烧录失败（fastboot烧录不容易出错，以前是手工烧录很容易出错）
	rootfs本身制作失败的。（尤其是自己做的rootfs，或者别人给的第一次用）

### 16.8.5、执行用户态下的进程1程序

（1）上面一旦挂载rootfs成功，则进入rootfs中寻找应用程序的init程序，这个程序就是用户空间的进程1.找到后用run_init_process去执行他

（2）我们如果确定init程序是谁？方法是：
先从uboot传参cmdline中看有没有指定，如果有指定先执行cmdline中指定的程序。cmdline中的init=/linuxrc这个就是指定rootfs中哪个程序是init程序。这里的指定方式就表示我们rootfs的根目录下面有个名字叫linuxrc的程序，这个程序就是init程序。

如果uboot传参cmdline中没有init=xx或者cmdline中指定的这个xx执行失败，还有备用方案。第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。
如果以上都不成功，则认命了，死了。

*****

## 16.9、cmdline常用参数

### 16.9.1、格式简介

（1）格式就是由很多个项目用空格隔开依次排列，每个项目中都是项目名=项目值

（2）整个cmdline会被内核启动时解析，解析成一个一个的项目名=项目值的字符串。这些字符串又会被再次解析从而影响启动过程。

### 16.9.2、root=

（1）这个是用来指定根文件系统在哪里的

（2）一般格式是root=/dev/xxx（一般如果是nandflash上则/dev/mtdblock2，如果是inand/sd的话则/dev/mmcblk0p2）

（3）如果是nfs的rootfs，则root=/dev/nfs。

### 16.9.3、rootfstype=

（1）根文件系统的文件系统类型，一般是jffs2、yaffs2、ext3、ubi

### 16.9.4、console=

（1）控制台信息声明，譬如console=/dev/ttySAC0,115200表示控制台使用串口0，波特率是115200.

（2）正常情况下，内核启动的时候会根据console=这个项目来初始化硬件，并且重定位console到具体的一个串口上，所以这里的传参会影响后续是否能从串口终端上接收到内核的信息。

### 16.9.5、mem=

（1）mem=用来告诉内核当前系统的内存有多少

### 16.9.6、init=

（1）init=用来指定进程1的程序pathname，一般都是init=/linuxrc

### 16.9.7、常见cmdline介绍

（1）console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3
第一种这种方式对应rootfs在SD/iNand/Nand/Nor等物理存储器上。这种对应产品正式出货工作时的情况。

（2）root=/dev/nfs nfsroot=192.168.1.141:/root/s3c2440/build_rootfs/aston_rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC0,115200 
第二种这种方式对应rootfs在nfs上，这种对应我们实验室开发产品做调试的时候。

****

## 16.10、内核中架构相关代码简介

### 16.10.1、内核代码基本分为3块

（1）arch。		本目录下全是cpu架构有关的代码

（2）drivers		本目录下全是硬件的驱动

（3）其他			相同点是这些代码都和硬件无关，因此系统移植和驱动开发的时候这些代码几乎都是不用关注的。

### 16.10.2、架构相关的常用目录名及含义

（1）mach。（mach就是machine architecture）。arch/arm目录下的一个mach-xx目录就表示一类machine的定义，这类machine的共同点是都用xx这个cpu来做主芯片。（譬如mach-s5pv210这个文件夹里面都是s5pv210这个主芯片的开发板machine）；mach-xx目录里面的一个mach-yy.c文件中定义了一个开发板（一个开发板对应一个机器码），这个是可以被扩展的。

（2）plat（plat是platform的缩写，含义是平台）plat在这里可以理解为SoC，也就是说这个plat目录下都是SoC里面的一些硬件（内部外设）相关的一些代码。
在内核中把SoC内部外设相关的硬件操作代码就叫做平台设备驱动。

（3）include。这个include目录中的所有代码都是架构相关的头文件。（linux内核通用的头文件在内核源码树根目录下的include目录里）

### 16.10.3、补充

（1）内核中的文件结构很庞大、很凌乱（不同版本的内核可能一个文件存放的位置是不同的），会给我们初学者带来一定的困扰。

（2）头文件目录include有好几个，譬如：
	kernel/include		内核通用头文件
	kernel/arch/arm/include		架构相关的头文件
		kernel/arch/arm/include/asm
			kernel\arch\arm\include\asm\mach
	kernel\arch\arm\mach-s5pv210\include\mach
	kernel\arch\arm\plat-s5p\include\plat

（3）内核中包含头文件时有一些格式

#include <linux/kernel.h>		kernel/include/linux/kernel.h
#include <asm/mach/arch.h>		kernel/arch/arm/include/asm/mach/arch.h
#include <asm/setup.h>			kernel\arch\arm\include\asm/setup.h
#include <plat/s5pv210.h>		kernel\arch\arm\plat-s5p\include\plat/s5pv210.h

（4）有些同名的头文件是有包含关系的，有时候我们需要包含某个头文件时可能并不是直接包含他，而是包含一个包含了他的头文件。

*****

# 17、内核的移植-从三星官方内核开始移植

## 17.1、内核移植初体验

### 17.1.1、三星官方移植版内核获取

（1）从网盘下载源码包。

（2）这个文件最初是来自于三星的SMDKV210开发板附带的光盘资料

### 17.1.2、配置编译下载尝试

（1）检查Makefile中ARCH和CROSS_COMPILE

（2）make xx_defconfig

（3）make menuconfig

（4）make -j4
默认情况下直接make则会直接单线程编译。但是如果make -j4则会4线程编译。

### 17.1.3、后续要做的事情

（1）编译得到的zImage去下载运行，看结果

（2）根据结果去分析问题原因，然后去尝试解决这些问题。

******

## 17.2、初步移植以看到启动信息

### 17.2.1、分析问题

（1）根据运行结果，分析发现：linux内核的自解压代码都没有运行（因为没有看到：Uncompressing Linux... done, booting the kernel.）

（2）说明zImage根本没有被解压成功，内核代码根本就没有被运行，当然没有输出信息了。所以问题出在解压相关的部分。

（3）问题出在内核配置的解压后代码放置的内存地址处。

（4）内核配置的解压地址应该等于连接地址，否则自解压之后内核无法运行。现在问题变成：第一，内核的连接地址等于多少？第二，内核中配置的解压地址是多少？

（5）这里面还有个问题：内核的连接地址是一个虚拟地址，而自解压代码解压内核时需要物理地址，因此上面说的等于，其实是连接地址对应的物理地址等于自解压地址。

（6）连接地址和他对应的物理地址在head.S中可以查到，分别是0xC0008000和0x30008000。那么自解压代码配置的解压地址应该是30008000.

（7）自解压代码对应的自解压地址在mach/Makefile.boot文件中。在其中修改，加入两行：

```c
# override for SMDKV210
zreladdr-$(CONFIG_MACH_SMDKV210)	:= 0x30008000
params_phys-$(CONFIG_MACH_SMDKV210)	:= 0x30000100
```

（8）同步代码，并且编译，得到的zImage复制到/tftpboot，然后重新下载运行查看结果。

（9）结果就是：还是没运行，但是有效果。自解压代码解压打印信息已经出来了。但是内核还没运行

### 17.2.2、问题分析

（1）定义的物理地址不对，从20000000改到30000000即可

*****

## 17.3、内核中机器码的确定

### 17.3.1、MACHINE_START宏

（1）这个宏用来定义一个机器码的数据结构的。这个宏的使用其实是用来定义一个结构体类型为machine_desc类型的结构体变量，名为__mach_desc_SMDKV210。这个结构体变量会被定义到一个特定段.arch.info.init，因此这个结构体变量将来会被链接器链接到这个.arch.info.init段中。

```c
static const struct machine_desc __mach_desc_SMDKV210	\
 __used							\
 __attribute__((__section__(".arch.info.init"))) = {	\
	.nr		= MACH_TYPE_SMDKV210,		\
	.name		= "SMDKV210",
	.phys_io	= S3C_PA_UART & 0xfff00000,
	.io_pg_offst	= (((u32)S3C_VA_UART) >> 18) & 0xfffc,
	.boot_params	= S5P_PA_SDRAM + 0x100,
	.init_irq	= s5pv210_init_irq,
	.map_io		= smdkv210_map_io,
	.init_machine	= smdkv210_machine_init,
	.timer		= &s5p_systimer,
};
```

（2）经过分析，发现一个mach-xxx.c文件中定义了一个机器码的开发板的machine_desc结构体变量，这个结构体变量放到.arch.info.init段中后，那么就表示当前内核可以支持这个机器码的开发板。

（3）落实到当前开发板和当前内核中来分析，当前我们移植的目标开发板使用S5PV210的CPU，开发板名字叫X210.我们在三星官方版本的内核中是找不到mach-x210.c的，所以我们又不想从零开始去移植，因此我们的思路是在三星移植的mach-s5pv210目录下找一个mach-xx.c，这个开发板和我们的X210开发板最为接近，然后以此为基础来移植。

（4）经过查看，发现mach-s5pc110.c和mach-s5pv210.c和我们的X210开发板最为接近。我们一般确定的一个原则是：看我们的开发板和三星官方的哪个开发板最为相似。我们的X210开发板抄的是三星的SMDKV210，因此要找这个对应的那个文件。

（5）结合mach-s5pv210目录下的Makefile来分析，得知.config中定义了CONFIG_MACH_SMDKV210后，实际绑定的是mach-smdkc110.c这个文件。所以实际上mach-smdkv210.c这个文件根本没用到。启示就是不要光看名字。

### 17.3.2、硬件驱动的加载和初始化函数执行

（1）.init_machine	= smdkc110_machine_init,

（2）这个元素定义了一个机器硬件初始化函数，这个函数非常重要，这个函数中绑定了我们这个开发板linux内核启动过程中会初始化的各种硬件的信息。

****

## 17.4、解决内核启动中的错误

### 17.4.1、认识内核启动OOPS

（1）内核启动后会有打印信息，打印信息中隐藏了问题所在。认真的去分析这个打印信息，从中找到对的或者错误的一些信息片段，才能帮助我们找到问题，从而解决问题。

（2）内核启动中的错误信息有一些特征：
Unable to handle kernel NULL pointer dereference at virtual address 00000060
Internal error: Oops: 5 [#1] PREEMPT	当出现oops的时候就说明内核启动失败了而且失败在这句话附件
PC is at dev_driver_string+0xc/0x44
LR is at max8698_pmic_probe+0x150/0x32c

（3）从以上错误信息中的PC和LR的值可以看出，程序是执行到dev_driver_string或者max8698_pmic_probe（这两个是函数或者汇编中的标号）符号部分的时候出错了。我们就从这两个符号出发去寻找、思考可能出错的地方然后试图去解决。

### 17.4.2、错误追溯及问题解决

（1）max8698_pmic_probe看名字是max8698这个电源管理IC的驱动安装函数部分出错了，应该是我们的开发板系统中配置了支持这个电源管理IC，于是乎启动时去加载他的驱动，结果驱动在加载执行的过程中出错了OOPS了。

（2）我们为什么要配置支持这个驱动？这个驱动加载为什么要出错？

（3）结合我们X210开发板的硬件实际情况来分析：我们X210开发板上根本就没有max8698这个电源管理IC，既然硬件都没有驱动执行了肯定会出错。

（4）回忆当时从三星版本的uboot移植的时候，在uboot的lowlevel_init.S中也有调用个电源管理IC初始化函数（PMIC_init），后来解决的办法就是屏蔽掉了这个函数的调用，uboot就成功运行下去了。

（5）为什么我们的uboot和内核中默认都调用了这个电源管理IC的初始化代码？原因就是三星的SMDKV210开发板中是用了max8698这个电源管理IC的，所以三星的uboot和kernel中都有默认支持这个。但是X210中是没用的，因此都需要去掉。

（6）怎么解决？在uboot中是直接改源代码屏蔽掉那个初始化函数解决的；在内核中不能这么干？因为linux kernel是高度模块化高度可配置的，内核中每一个模块都是被配置项条件编译了的，因此要去掉某个模块的支持，只需要重新配置去掉选项即可，不用改源代码。所以我们的关键就是要找它对应的配置项。

（7）我们做法：make menuconfig，然后/搜索"MAX8698"这几个关键字，然后看到这个配置项的路径，然后到路径下去按N键去掉这个模块的支持，保存，重新编译即可。

（8）实践证明问题被解决了，而且内核再次启动后直接运行到挂载rootfs才出错。

### 17.4.3、分析及总结

（1）分析：问题究竟是怎么被解决的？涉及哪几个方面
根本原因在于CONFIG_MFD_MAX8698这个配置宏。这个配置宏决定了很多东西
第一：这个配置宏决定了drivers目录下的max8698对应的驱动程序源代码是否被编译
第二：这个配置宏决定了kernel启动过程中是否会调用一些max8698的相关的代码

（2）总结：kernel是高度模块化和可配置化的，所以在内核中做任何事情（添加一个模块、更改一个模块、去掉一个模块）都必须按照内核设定的方案和流程来走。

***

## 17.5、iNand的问题和安排

### 17.5.1、错误分析

（1）得到的内核错误信息：Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)。从错误信息字面意思来分析，就是内核试图挂载根文件系统时失败，失败的原因是unknown-block（不能识别的块设备）

（2）backstrace分析，可以得知错误信息的来源，再结合之前的内核启动流程分析，就更加确定了出错的地方。

（3）下一个问题：分析这个错误出现的原因。unknown-block(0,0)。在kernel启动时uboot会传给内核一个cmdline，其中用root=xx来指定了rootfs在哪个设备上，内核就会到相应的地方去挂载rootfs。譬如我们传参中：root=/dev/mmcblk0p2，这里的/dev/mmcblk0p2就是rootfs的设备地址，这个设备文件编号的含义就是mmc设备0的第2个分区（设备0就是在SD0通道上的设备，也就是iNand），这里的问题就是没找到mmc设备0的第2分区。

（4）下一步问题：为什么没找到mmc设备0的第2分区。一定是因为kernel启动过程中加载mmc驱动的时候有问题，驱动没有发现mmc设备0.问题定位在MMC相关的驱动方面。

（5）对比九鼎版本的内核启动信息，即可发现我们的内核启动并没有找到MMC设备（内置的iNand和外置的SD卡都没找到），没找到肯定是驱动的问题，这就要去移植MMC驱动了。

### 17.5.2、问题阐述

（1）SD/iNand本身都是由一个一个的扇区组成的，回忆裸机中讲到的210的启动时，BL1在SD卡的1扇区开始往后存放，SD卡的0扇区是不用的。SD卡的0扇区是用来放置MBR的。

（2）MBR就是用来描述块设备的分区信息的，事先定义了一个通用的数据结构来描述块设备的分区，我们只要按照这个标准将分区信息写入MBR中即可对该设备完成分区。MBR默认就是在块设备的第0个扇区上存放的。

（3）我们内核中读到iNand分4个分区，我们哪里分区的？uboot中有一个命令fdisk -c 0时就对iNand进行了分区。uboot的fdisk命令内部已经写死了iNand的分区表，到内核中时内核直接读取MBR就知道了分区。所以在uboot和内核之间iNand设备的分区信息是靠iNand自己传递的，所以uboot不用给内核传参时传递分区表信息。

（4）如果开发板用的是nandFlash的话，分区表一般是在内核中自己用代码构建的。所以nand版本的内核移植的时候一般都需要去移植更改nand分区表。

### 17.5.3、解决安排

（1）暂时解决不了这个问题。

### 17.5.4、后续课程安排

（1）一节课搞定网卡驱动的移植，一节课讲述一些内核移植的小方法和技巧，然后课程结束

（2）整体移植的课程结束，进入根文件系统部分。

****

## 17.6、网卡驱动的移植和添加实验

### 17.6.1、移植标准

（1）网卡驱动移植ok时，启动信息为：
[    1.452008] dm9000 Ethernet Driver, V1.31
[    1.455870] eth0: dm9000c at e08f4300,e08f8304 IRQ 42 MAC: 00:09:c0:ff:ec:48 (platform data)

（2）当前内核中网卡驱动尚未移植，因此内核启动时有错误的打印信息：
[    1.130308] dm9000 Ethernet Driver, V1.31
[    1.133113] ERROR : resetting 
[    1.135700] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.140915] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.145941] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.150963] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.155992] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.161018] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.166041] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.171070] dm9000 dm9000.0: read wrong id 0x2b2a2928
[    1.176092] dm9000 dm9000.0: wrong id: 0x2b2a2928
[    1.180774] dm9000 dm9000.0: not found (-19).

（3）移植的目标就是让我们的版本的内核可以打印出正确情况下的启动信息，那我们就相信内核启动后网卡是可以工作的。

### 17.6.2、make menuconfig中添加DM9000支持

（1）menuconfig中选择Y

（2）其实这一步本来就是Y，所以在我们这里是不用管的。但是你自己遇到的一个内核可能默认不是Y，因此要设置。

### 17.6.3、mach-smdkc110.c中逻辑分析

（1）mach-smdkc110.c中的smdkc110_machine_init是整个开发板的所有硬件的初始化函数，在这里加载了的硬件将来启动时就会被初始化，在这里没有的将来启动时就不管。

（2）smdkc110_devices和smdkc110_dm9000_set()这两个地方是和DM9000有关的，要分别去做移植。

（3）smdkc110_dm9000_set这个函数就是DM9000相关的SROM bank的寄存器设置，相当于uboot中dm9000移植时的dm9000_pre_init函数。只是读写寄存器的函数名称不同了。

### 17.6.4、修改相应的配置参数

（1）DM9000相关的数据配置在arch/arm/plat-s5p/devs.c中更改

（2）在arch/arm/mach-s5pv210/include/mach/map.h中定义了DM9000的IO基地址，和DM9000接在哪个bank有关。

（3）还有+2改成+4，IRQ_EINT9改成10即可。

### 17.6.5、代码实践

（1）同步代码、编译生成zImage

（2）下载启动后看启动信息。

*****

## 17.7、内核启动第一阶段的调试方法

### 17.7.1、问题点描述

（1）内核启动在head.S中首先进行了三个校验（CPU id的校验、机器码的校验、tag的校验），然后创建页表，然后做了一些不太会出错的事情，然后b start_kernel。基本上能运行到start_kernel内核移植就不太会出问题了。

（2）有时候移植的内核启动后的现象是：根本没有启动信息出来。这时候有可能是内核启动运行了但是运行出错了没启动起来所以没有打印信息；也有可能是内核根本没得以运行。都有可能但是没法确定。我们希望能有一种调试手段来确定问题所在。

### 17.7.2、调试方法和原理

（1）调试方法就是在内核启动的第一阶段添加汇编操作led点亮/熄灭的方法来标明代码运行的轨迹。

（2）我们找之前裸机中汇编操作led点亮/熄灭的代码过来，复制粘贴到head.S中合适位置。然后内核启动后根据led的表现来标明代码有无运行。

### 17.7.3、动手测试

（1）整理好led操作的代码段，在head.S中合适的地方添加led这个函数，然后在head.S的内核起始运行阶段添加调用led函数，然后重新编译内核，运行内核看这段代码有无被运行。

（2）如果被运行了，证明在这个调用led的步骤之前的部分都是没问题的，那么如果有错肯定错误在后边；如果没有被运行则证明错误在之前，那么就要去之前的部分debug。

*****

# 18、根文件系统的原理

## 18.1、根文件系统概述

### 18.1.1、为什么需要根文件系统

（1）init进程的应用程序在根文件系统上

（2）根文件系统提供了根目录/

（3）内核启动后的应用层配置(etc目录)在根文件系统上。几乎可以认为：发行版=内核+rootfs

（4）shell命令程序在根文件系统上。譬如ls、cd等命令

总结：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、/bin  /sbin等目录下的shell命令，还有/lib目录下的库文件等···）相配合才能工作。

### 18.1.2、根文件系统的实质是什么

（1）根文件系统是特殊用途的文件系统。

（2）根文件系统也必须属于某种文件系统格式。rootfstype= 这句话的意思就是告诉内核我的根文件是什么格式的

（3）究竟文件系统是用来干嘛的。ZnFAT
首先，存储设备（块设备，像硬盘、flash等）是分块（扇区）的，物理上底层去访问存储设备时是按照块号（扇区号）来访问的。这就很麻烦。

其次，文件系统是一些代码，是一套软件，这套软件的功能就是对存储设备的扇区进行管理，将这些扇区的访问变成了对目录和文件名的访问。我们在上层按照特定的目录和文件名去访问一个文件时，文件系统会将这个目录+文件名转换成对扇区号的访问。

最后，不同的文件系统的差异就在于对这些扇区的管理策略和方法不同，譬如坏块管理、碎片管理。

*****

## 18.2、根文件系统的形式

### 18.2.1、镜像文件形式

（1）使用专用工具软件制作的可供烧录的镜像文件

（2）镜像中包含了根文件系统中的所有文件

（3）烧录此镜像类似于对相应分区格式化。

（4）镜像文件系统具有一定的格式，格式是内化的，跟文件名后缀是无关的。

### 18.2.2、文件夹形式

（1）根文件系统其实就是一个包含特定内容的文件夹而已

（2）根文件系统可由任何一个空文件夹添加必要文件构成而成

（3）根文件系统的雏形就是在开发主机中构造的文件夹形式的

### 18.2.3、总结

（1）镜像文件形式的根文件系统主要目的是用来烧录到块设备上，设备上的内核启动后去挂载它。镜像文件形式的根文件系统是由文件夹形式的根文件系统使用专用的镜像制作工具制作而成的。

（2）最初在开发主机中随便mkdir创建了一个空文件夹，然后向其中添加一些必要的文件（包括etc目录下的运行时配置文件、/bin等目录下的可执行程序、/lib目录下的库文件等···）后就形成了一个文件夹形式的rootfs。然后这个文件夹形式的rootfs可以被kernel通过nfs方式来远程挂载使用，但是不能用来烧录块设备。我们为了将这个rootfs烧录到块设备中于是用一些专用的软件工具将其制作成可供烧录的一定格式的根文件系统镜像。

（3）文件夹形式的rootfs是没有格式的，制作成镜像后就有了一定的rootfs格式了，格式是由我们的镜像制作过程和制作工具来决定的。每一种格式的镜像制作工具的用法都不同。

***

## 18.3、制作ext3格式的根文件系统

### 18.3.1、mke2fs介绍

（1）mke2fs是一个应用程序，在ubuntu中默认是安装了的。这个应用程序就是用来制作ext2、ext3、ext4等格式的根文件系统的。

（2）一般用来制作各种不同格式的rootfs的应用程序的名字都很相似，类似于mkfs.xxx（譬如用来制作ext2格式的rootfs的工具叫mkfs.ext2、用来制作jffs2格式的rootfs的工具就叫mkfs.jffs2）

（3）ubuntu14.04中的mkfs.ext2等都是mke2fs的符号链接而已。

### 18.3.2、动手制作ext3格式的根文件系统

（1）创建rootfs.ext2文件并且将之挂载到一个目录下方便访问它
《参考资料：http://blog.csdn.net/zhengmeifu/article/details/24174513》
dd if=/dev/zero of=rootfs.ext2 bs=1024 count=2048
losetup  /dev/loop1 rootfs.ext2
mke2fs -m 0 /dev/loop1 2048
mount -t ext2 /dev/loop1 ./rootfs/

（2）我们向镜像中写入一个普通文件linuxrc。这个文件就会成为我们制作的镜像中的/linuxrc。内核挂载了这个镜像后就会尝试去执行/linuxrc。然后执行时必然会失败。我们将来实验看到的现象就应该是：挂载成功，执行/linuxrc失败。

（3）将来真正去做有用的rootfs时，就要在这一步添加真正可以执行的linuxrc程序，然后还要添加别的/lib目录下的库文件，/etc目录下的配置文件等。

（4）卸载掉，然后镜像就做好了。
umount /dev/loop1
losetup -d /dev/loop1

### 18.3.3、烧录制作的rootfs.ext3

（1）烧录过程参考裸机中第三部分的刷机过程。注意bootargs传参设置

*****

## 18.4、nfs方式启动自制简易文件夹形式的rootfs

### 18.4.1、什么是nfs

（1）nfs是一种网络通讯协议，由服务器和客户端构成。

（2）nfs的作用。利用nfs协议可以做出很多直接性应用，我们这里使用nfs主要是做rootfs挂载。开发板中运行kernel做nfs客户端，主机ubuntu中搭建nfs服务器。在主机ubuntu的nfs服务器中导出我们制作的文件夹形式的rootfs目录，则在客户端中就可以去挂载这个文件夹形式的rootfs进而去启动系统。

（3）搭建nfs服务器。

### 18.4.2、配置内核以支持nfs作为rootfs

（1）设置nfs启动方式的bootargs

（2）在menuconfig中配置支持nfs启动方式

如果内核没有配置支持nfs在内核启动挂载根文件系统的时候会报以下错误 VFS: Cannot open root device "nfs" or unknown-block(0,255) 

### 18.4.3、总结

（1）nfs方式启动相当于开发板上的内核远程挂载到主机上的rootfs

（2）nfs方式启动不用制作rootfs镜像

（3）nfs方式不适合真正的产品，一般作为产品开发阶段调试使用

****

## 18.5、什么是linuxrc

### 18.5.1、/linuxrc是一个可执行的应用程序

（1）/linuxrc是应用层的，和内核源码一点关系都没有

（2）/linuxrc在开发板当前内核系统下是可执行的。因此在ARM SoC的linux系统下，这个应用程序就是用arm-linux-gcc编译链接的；如果是在PC机linux系统下，那么这个程序就是用gcc编译连接的。

（3）/linuxrc如果是静态编译连接的那么直接可以运行；如果是动态编译连接的那么我们还必须给他提供必要的库文件才能运行。但是因为我们/linuxrc这个程序是由内核直接调用执行的，因此用户没有机会去导出库文件的路径，因此实际上这个/linuxrc没法动态连接，一般都是静态连接的。

### 18.5.2、/linuxrc执行时引出用户界面

（1）操作系统启动后在一系列的自己运行配置之后，最终会给用户一个操作界面（也许是cmdline，也许是GUI），这个用户操作界面就是由/linuxrc带出来的。

（2）用户界面等很多事并不是在/linuxrc程序中负责的，用户界面有自己专门的应用程序，但是用户界面的应用程序是直接或者间接的被/linuxrc调用执行的。用户界面程序和其他的应用程序就是进程2、3、4·····，这就是我们说的进程1（init进程，也就是/linuxrc）是其他所有应用程序进程的祖宗进程。

### 18.5.3、/linuxrc负责系统启动后的配置

（1）busybox是一个C语言写出来的项目，里面包含了很多.c文件和.h文件。这个项目可以被配置编译成各个平台下面可以运行的应用程序。我们如果用arm-linux-gcc来编译busybox就会得到一个可以在我们开发板linux内核上运行的应用程序。

（2）busybox这个程序开发出来就是为了在嵌入式环境下构建rootfs使用的，也就是说他就是专门开发的init进程应用程序。

（3）busybox为当前系统提供了一整套的shell命令程序集。譬如vi、cd、mkdir、ls等。在桌面版的linux发行版（譬如ubuntu、redhat、centOS等）中vi、cd、ls等都是一个一个的单独的应用程序。但是在嵌入式linux中，为了省事我们把vi、cd等所有常用的shell命令集合到一起构成了一个shell命令包，起名叫busybox。

****

## 18.6、rootfs中还应该有什么

（1）最重要的就是上节课讲过的/linuxrc

（2）dev目录下的设备文件。在linux中一切皆是文件，因此一个硬件设备也被虚拟化成一个设备文件来访问，在linux系统中/dev/xxx就表示一个硬件设备，我们要操作这个硬件时就是open打开这个设备文件，然后read/write/ioctl操作这个设备，最后close关闭这个设备。
在最小rootfs中/dev目录也是不可少的，这里面有一两个设备文件是rootfs必须的。

（3）sys和proc目录。在最小rootfs中也是不可省略的，但是这两个只要创建了空文件夹即可，里面是没东西的，也不用有东西。这两个目录也是和驱动有关的。属于linux中的虚拟文件系统。这里面文件是空的在系统运行起来之后系统会用软件模拟的是我们内核运行时状态展示

（4）usr是系统的用户所有的一些文件的存放地，这个东西将来busybox安装时会自动生成。

（5）etc目录是很关键很重要的一个，目录中的所有文件全部都是运行时配置文件。/etc目录下的所有配置文件会直接或者间接的被/linuxrc所调用执行，完成操作系统的运行时配置。etc目录是制作rootfs的关键，所以后面下一个课程专门讲这个etc目录。

（6）lib目录也是rootfs中很关键的一个，不能省略的一个。lib目录下放的是当前操作系统中的动态和静态链接库文件。我们主要是为了其中的动态链接库。

****

## 18.7、VFS简介

### 18.7.1、什么是VFS

（1）VFS是linux内核的一种设计理念、设计机制。VFS就是vitrual file system，叫虚拟文件系统。

（2）具体的一些文件系统如FAT、NTFS、ext2、ext3、jffs2、yaffs2、ubi等主要设计目的是为了管理块设备（硬盘、Nand···）

（3）VFS是借鉴了文件系统的设计理念（通过文件系统将底层难以管理的物理磁盘扇区式访问，转换成目录+文件名的方式来访问），将硬件设备的访问也虚拟化成了对目录+文件的访问。所以有了VFS后我们可以通过设备文件（目录+文件名，譬如/dev/mmcblk0p2）的方式来访问系统中的硬件设备。

（4）以上可以初步看出VFS的一些厉害之处，但是VFS不止于此。

### 18.7.2、VFS的意义

（1）上面说过的对硬件设备的访问，将对硬件设备的访问和对普通文件的访问给接口统一化了（linux中一切届是文件）。

（2）将操作系统上层（应用层）对下层不同文件系统类型的访问细节给屏蔽掉了。譬如，我们要将一个在vfat文件系统中管理的数据要复制到ext3文件系统中去，因此如果没有VFS那我们写cp命令（其他命令也一样）的时候就不得不去考虑你cp的这个文件在什么文件系统类型下。所以cp命令非常复杂，因此要考虑具体的文件系统类型。有了VFS后情况就不同了。VFS成了一个隔离层，隔离了下层的不同文件系统的差异性，对上层应用提供一个统一的接口。

（3）VFS将不同文件系统和下层硬件设备（块设备）驱动之间的细节也给屏蔽了。不同类型的文件系统在本身设计时是不用考虑各种不同的硬件设备的具体操作差异的，这里有一个类似于VFS的设计理念。

### 18.7.3、VFS和我们学习的关系

（1）VFS机制和rootfs挂载，和其他文件系统的挂载都是有关联的。

（2）内核中有一些sys proc这种虚拟文件系统，这东西也是和VFS机制有关。

（3）/dev/目录下的设备文件都和VFS有关，所以学习驱动绕不开VFS。

****

# 19、根文件系统构建实验及过程详解

## 19.1、根文件系统的构建路线

### 19.1.1、先逐步构建文件夹形式根文件系统然后制作烧录镜像

（1）rootfs有2种格式：nfs方式启动的文件夹形式的rootfs和用来烧录的镜像形式的rootfs。

（2）传统的培训机构中上课时，rootfs制作实验都是直接给制作文档，学生参照制作文档的步骤自己动手做，一步到位做出来的就是可供烧录的rootfs。

（3）我们先从空文件夹开始，逐步向其中添加一些rootfs中必备的东西，然后做一步就用nfs方式去挂载启动，观察启动后的现象，并且理论上去分析原因。

### 19.1.2、逐步添加不断复杂化的rootfs

****

## 19.2、busybox的移植实战

### 19.2.1、busybox源码下载

（1）busybox是一个开源项目，所以源代码可以直接从网上下载。
（2）busybox的版本差异不大，版本新旧无所谓。
（3）下载busybox可以去linuxidc等镜像网站，也可以去www.busybox.net官方网站下载。

### 19.2.2、修改Makefile

（1）ARCH = arm
（2）CROSS_COMPILE = /usr/local/arm/arm-2009q3/bin//arm-none-linux-gnueabi-

### 19.2.3、make menuconfig进行配置

（1）参照《busybox menuconfig配置.txt》文件中的记录进行配置。

### 19.2.4、make 然后 make install

（1）make编译，如果有错误解决之

（2）make install执行的时候其实是在执行busybox顶层目录下的一个目标install。

（3）make install在所有的linux下的软件中作用都是安装软件。在传统的linux系统中安装软件时都是选择源代码方式安装的。我们下载要安装的软件源代码，然后配置、编译、安装。make install的目的就是将编译生成的可执行程序及其依赖的库文件、配置文件、头文件安装到当前系统中指定（一般都可以自己指定安装到哪个目录下，如果不指定一般都有个默认目录）的目录下

### 19.2.5、设置bootargs挂载添加了busybox移植的rootfs

（1）之前建立了一个空的文件夹然后自己touch linuxrc随便创建了一个不能用的/linuxrc然后去nfs挂载rootfs，实验结果是：挂载成功，执行/linuxrc失败。

（2）现在我们移植了busybox后/linuxrc就可以用了，然后再次去nfs挂载这个rootfs。预计看到的效果是：挂载成功，执行/linuxrc也能成功。

（3）注意uboot的bootargs设置成：setenv bootargs root=/dev/nfs nfsroot=192.168.1.141:/root/porting_x210/rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC2,115200 

（4）实验结果：挂载成功，执行/linuxrc（也就是busybox）成功，但是因为找不到/etc/init.d/rcS和/dev/tty2等文件所以一直在打印错误提示信息，但是其实有进入命令行。

### 19.2.6、busybox-1.31.1配置与编译

（1）修改ARCH、CROSS_COMPILE

（2）make menuconfig

```c
Settings--->
	Build Options--->
		[*]Build static binary (no shared libs)		
	Library Tuning--->
		[*]vi-style line editing commands
		[*]Fancy shell prompts
	
	
Linux Module Utilities--->
	[ ]Simplified modutils
	[*]insmod
	[*]rmmod
	[*]lsmod
	[*]modprobe
	[*]depmod


（默认是选中的）	
Linux System Utilities--->
	[*]mdev
		[*]Support /etc/mdev.conf
		[*]Support subdirs/symlinks
		[*]Support regular expressions substitutions when renaming dev
		[*]Support command execution at device addition/removal
		[*]Support loading of firmwares
	[ ]nsenter


Coreutils--->
	[ ]sync
```

（4）make  

报错：

```c
networking/libiproute/ipaddress.c: In function ‘print_addrinfo’:
networking/libiproute/ipaddress.c:333: error: ‘IFA_F_DADFAILED’ undeclared (first use in this function)
networking/libiproute/ipaddress.c:333: error: (Each undeclared identifier is reported only once
networking/libiproute/ipaddress.c:333: error: for each function it appears in.)
make[1]: *** [networking/libiproute/ipaddress.o] Error 1
make: *** [networking/libiproute] Error 2
```

打开报错文件

```c
修改
networking/libiproute/ipaddress.c:333:
添加条件编译
#ifdef IFA_F_DADFAILED 	//添加
		if (ifa->ifa_flags & IFA_F_DADFAILED) {
				ifa->ifa_flags &= ~IFA_F_DADFAILED;
				printf("dadfailed ");
		}
#endif			//添加
```

（5）重新make

​	成功

### 19.2.7、Linux通过nfs挂载根文件系统失败

确认过内核和uboot发现应该有的配置都已经配置过了，还是挂载不上，上网发现是因为ubuntu版本太高，不兼容导致的查找资料发现从Ubuntu17.04开始，nfs默认只支持协议3和协议4，而kernel中默认支持协议2，所以才会出现挂载失败的情况，现有两种方法可以解决该问题：

（1）设置Ubuntu20系统中的nfs服务支持协议2，修改nfs配置文件 /etc/default/nfs-kernel-server,在文件末尾加入一句：RPCNFSDOPTS="--nfs-version 2,3,4 --debug --syslog"。

（2）如果kernel版本较高支持nfs协议3的话，可以在Uboot传到Kernel的bootargs参数中加入'nfsvers=3',使kernel使用nfs协议3。

*****

## 19.3、inittab详解

### 19.3.1、添加一个典型的inittab

（1）将我提供的典型的inittab文件复制到我们制作的rootfs的根目录下的/etc/目录下

（2）再次启动内核挂载这个rootfs看效果

（3）实验现象是成功启动并且挂载rootfs进入了控制台命令行。当前制作的最小rootfs成功了

### 19.3.2、inittab格式解析

（1）inittab的工作原理就是被/linuxrc（也就是busybox）执行时所调用起作用。

（2）inittab在/etc目录下，所以属于一个运行时配置文件，是文本格式的（内容是由一系列的遵照一个格式组织的字符组成的），实际工作的时候busybox会（按照一定的格式）解析这个inittab文本文件，然后根据解析的内容来决定要怎么工作。

（3）busybox究竟如何完成解析并且解析结果如何去工作（busybox中实现/etc/inittab的原理）并不是我们的目标，我们的重点是inittab的格式究竟怎样的？我们看到一个inittab后怎么去分析这个inittab对启动的影响。

（4）inittab的格式在busybox中定义的，网上可以搜索到详细的格式说明，具体去参考即可：

第一个：#开始的行是注释
第二个：冒号在里面是分隔符，分隔开各个部分。
第三个：inittab内容是以行为单位的，行与行之间没有关联，每行都是一个独立的配置项，每一个配置项表示一个具体的含义。
第四个：每一行的配置项都是由3个冒号分隔开的4个配置值共同确定的。这四个配置值就是id:runlevels:action:process。值得注意得是有些配置值可以空缺，空缺后冒号不能空缺，所以有时候会看到连续2个冒号。
第五个：每一行的配置项中4个配置值中最重要的是action和process，action是一个条件/状态，process是一个可被执行的程序的pathname。合起来的意思就是：当满足action的条件时就会执行process这个程序。

注意：理解inittab的关键就是明白“当满足action的条件时就会执行process这个程序。” 你去分析busybox的源代码就会发现，busybox最终会进入一个死循环，在这个死循环中去反复检查是否满足各个action的条件，如果某个action的条件满足就会去执行对应的process。

第六个：明白各个action什么意思

*****

## 19.4、busybox源码分析

### 19.4.1、整个程序入口确认

（1）分析一个程序，不管多庞大还是小，最好的路线都是按照程序运行时的逻辑顺序来。所以找到一个程序的入口至关重要。

（2）学C语言的时候都知道程序的主函数main函数就是整个程序的入口。这种情况适应于操作系统下工作的应用程序的情况。

（3）在uboot和linux kernel这两个大的C语言的项目中，main函数都没有，都不是入口。在我们这种裸机程序中入口不是main函数，而是由连接脚本来指定的。

（4）busybox是linux启动起来后工作的一个应用程序，因此其中必然有main函数，而且main就是入口。

### 19.4.2、busybox中main函数全解析

（1）busybox入口就是main函数，其中有很多个main但是只有一个起作用了，其他的是没起作用的。真正的busybox工作时的入口是libbb/appletlib.c中的main函数

（2）busubox中有很多xxx_main函数，这些main函数每一个都是busybox支持的一个命令的真正入口。譬如ls_main函数就是busybox当作ls函数使用时的入口程序。

（3）ls或者cd等命令其实都是busybox一个程序，但是实际执行时的效果却是各自的效果。busybox是如何实现一个程序化身万千还能各自工作的？答案就是main转xxx_main。也就是说busybox每次执行时都是先执行其main，在main函数中识别（靠main函数的传参argv[0]来识别）我们真正要执行的函数（譬如ls）然后去调用相应的xxx_main（譬如ls_main）来具体实现这个命令。

### 19.4.3、inittab解析与执行

（1）inittab的解析是在busybox/init/init.c/init_main函数中

（2）执行逻辑是：先通过parse_inittab函数解析/etc/inittab（解析的重点是将inittab中的各个action和process解析出来），然后后面先直接执行sysinit和wait和once（注意这里只执行一遍），然后在while(1)死循环中去执行respwan和askfirst。

### 19.4.4、pwd命令执行路径分析

（1）根据上节讲的，我们在busybox命令行下执行pwd命令时实际执行的是pwd_main这个函数。

### 19.4.5、busybox的体积优势原理

（1）busybox实际上就是把ls、cd、mkdir等很多个linux中常用的shell命令集成在一起了。集成在一起后有一个体积优势：就是busybox程序的大小比busybox中实现的那些命令的大小加起来要小很多。

（2）busybox体系变小的原因主要有2个：第一个是busybox本身提供的shell命令是阉割版的（busybox中的命令支持的参数选项比发行版中要少，譬如ls在发行版中可以有几十个-x，但是在busybox中只保留了几个常用的选项，不常用的都删除掉了）；第二个是busybox中因为所有的命令的实现代码都在一个程序中实现，而各个命令中有很多代码函数都是通用的（譬如ls和cd、mkdir等命令都会需要去操作目录，因此在busybox中实现目录操作的函数就可以被这些命令共用），共用会降低重复代码出现的次数，从而减少总的代码量和体积。

（3）经过分析，busybox的体积优势是嵌入式系统本身的要求和特点造成的。

****

## 19.5、rcS文件介绍1

/etc/init.d/rcS文件是linux的运行时配置文件中最重要的一个，其他的一些配置都是由这个文件引出来的。这个文件可以很复杂也可以很简单，里面可以有很多的配置项。

### 19.5.1、PATH=xxx

（1）首先从shell脚本的语法角度分析，这一行定义了一个变量PATH，值等于后面的字符串

（2）后面用export导出了这个PATH，那么PATH就变成了一个环境变量。

（3）PATH这个环境变量是linux系统内部定义的一个环境变量，含义是操作系统去执行程序时会默认到PATH指定的各个目录下去寻找。如果找不到就认定这个程序不存在，如果找到了就去执行它。将一个可执行程序的目录导出到PATH，可以让我们不带路径来执行这个程序。

（4）rcS中为什么要先导出PATH？就是因为我们希望一旦进入命令行下时，PATH环境变量中就有默认的/bin /sbin /usr/bin /usr/sbin 这几个常见的可执行程序的路径，这样我们进入命令行后就可以ls、cd等直接使用了。

（5）为什么我们的rcS文件还没添加，系统启动就有了PATH中的值？原因在于busybox自己用代码硬编码为我们导出了一些环境变量，其中就有PATH。

### 19.5.2、runlevel=

（1）runlevel也是一个shell变量，并且被导出为环境变量。

（2）runlevel这个环境变量到底有什么用？

（3）runlevel=S表示将系统设置为单用户模式

### 19.5.3、umask=

（1）umask是linux的一个命令，作用是设置linux系统的umask值。

（2）umask值决定当前用户在创建文件时的默认权限。

### 19.5.4、mount -a

（1）mount命令是用来挂载文件系统的

（2）mount -a是挂载所有的应该被挂载的文件系统，在busybox中mount -a时busybox会去查找一个文件/etc/fstab文件，这个文件按照一定的格式列出来所有应该被挂载的文件系统（包括了虚拟文件系统）

****

## 19.6、rcS文件实战

### 19.6.1、PATH&runlevel

（1）我们实战发现rcS文件明明存在但是却提示不存在，问题原因就是rcS文件在windows下创建的，行尾换行符为'\r\n'，多了点东西。但是因为ubuntu中的vi对行尾做了优化，所以在ubuntu中是看不出来多了东西的。但是在securecrt下一看就发现每一行末尾多出来了一个^M。

（2）这个故事告诉我们：shell脚本文件如果格式不对，运行时可能会被提示文件不存在。

（3）扩展讲一个：有时候一个应用程序执行时也会提示文件不存在，问题可能是这个程序所调用的一个动态链接库找不到。

（4）测试结果：PATH本来在busybox中就已经用代码导出过了，所以rcS中再次导出没有任何明显的现象，因此看不出什么差别；runlevel实际执行结果一直是unknown，问题在于busybox并不支持runlevel这个特性。

### 19.6.2、umask测试

（1）umask是022的时候，默认touch创建一个文件的权限是644

（2）umask是044的时候，默认touch创建一个文件的权限是622

（3）umask是444的时候，默认touch创建一个文件的权限是222
总结：umask的规律就是：umask值和默认创建文件的权限值加起来是666.

### 19.6.3、mount测试

（1）挂载时全部出错：
mount: mounting proc on /proc failed: No such file or directory
mount: mounting sysfs on /sys failed: No such file or directory
mount: mounting tmpfs on /var failed: No such file or directory
mount: mounting tmpfs on /tmp failed: No such file or directory
mount: mounting tmpfs on /dev failed: No such file or directory

（2）原因是因为根文件系统中找不到挂载点。所谓挂载点就是我们要将目标文件系统（当然这里都是虚拟文件系统）挂载到当前文件系统中的某一个目录中，这个目录就是挂载点。

（3）解决方案就是自己在制作的rootfs根目录下创建这些挂载点目录即可。

（4）验证是否挂载成功，可以看挂载时输出信息；还可以启动后去看proc和sys文件夹，如果有文件出现则证明挂载成功了，如果没东西就证明失败了。

****

## 19.7、rcS文件介绍2

### 19.7.1、mdev

（1）mdev是udev的嵌入式简化版本，udev/mdev是用来配合linux驱动工作的一个应用层的软件，udev/mdev的工作就是配合linux驱动生成相应的/dev目录下的设备文件。

（2）因为这个问题涉及到驱动，因此详细讲解要等到驱动部分。这里我们只是通过一些直观的现象来初步理解udev/mdev的工作效果。

（3）在rcS文件中没有启动mdev的时候，/dev目录下启动后是空的；在rcS文件中添加上mdev有关的2行配置项后，再次启动系统后发现/dev目录下生成了很多的设备驱动文件。

（4）/dev目录下的设备驱动文件就是mdev生成的，这就是mdev的效果和意义。

### 19.7.2、hostname

（1）hostname是linux中的一个shell命令。命令（hostname xxx）执行后可以用来设置当前系统的主机名为xxx，直接hostname不加参数可以显示当前系统的主机名。

（2）/bin/hostname -F /etc/sysconfig/HOSTNAME -F来指定了一个主机名配置文件（这个文件一般文件名叫hostname或者HOSTNAME）

### 19.7.3、ifconfig

（1）有时候我们希望开机后进入命令行时ip地址就是一个指定的ip地址（譬如192.168.1.30），这时候就可以在rcS文件中ifconfig eth0 192.168.1.30

****

## 19.8、profile文件和用户登录理论

### 19.8.1、profile文件添加

（1）之前添加了/bin/hostname在/etc/sysconfig/HOSTNAME文件中定义了一个hostname（aston210），实际效果是：命令行下hostname命令查到的host名字确实是aston210。但是问题就是命令行的提示符是没有显示的。

（2）这个问题的解决就要靠profile文件。将提供的profile文件放入/etc/目录下即可。

（3）添加了之后的实验现象：命令行提示符前面显示：[@enosx210 ]#
结论是：第一，profile文件起了作用，hostname显示出来了。第二，还有个问题，登录用户名没显示出来。原因就是我们直接进入了命令行而没有做登录。等我们添加了用户登录功能，并且成功登陆后这个问题就能解决。

（4）profile文件工作原理是：profile文件也是被busybox（init进程）自动调用的，所以是认名字的。

### 19.8.2、如何看到用户登录界面

（1）linux中有一个原则就是用一个小程序来完成一个功能。如果我们产品确实需要很复杂的综合型的功能，我们倾向于先使用很多个小程序完成其中的一个功能，然后再将这些小程序集成起来完成整个大功能的产品。

（2）这种集成很多个小程序来完成一个大的功能，有很多种技术实现。譬如shell脚本，还有一些别的技术，譬如linux启动中的inittab。

（3）因为我们之前intttab中有一个配置项 ::askfirst:-/bin/sh，这个配置项作用就是当系统启动后就去执行/bin/sh，执行这个就会出现命令行。因此我们这样的安排就会直接进入命令行而不会出现登录界面。

（4）我们要出现登录界面，就不能直接执行/bin/sh，而应该执行一个负责出现登录界面并且负责管理用户名和密码的一个程序，busybox中也集成了这个程序（就是/bin/login和/sbin/gettty），因此我们要在inittab中用/bin/login或者/sbin/getty去替代/bin/sh。

### 19.8.3、用户名和密码的设置

（1）用户名和密码的设置是和登录程序有关联的，但是/bin/login和/sbin/getty在用户名和密码的管理上是一样的。其实常见的所有的linux系统的用户名和密码的管理几乎都是一样的。

（2）密码一般都是用加密文字的，而不是用明文。意思就是系统中的密码肯定是在系统中的一个专门用来存密码的文件中存储的，用明文存密码有风险，因此linux系统都是用密文来存储密码的。关于密文密码的使用下节课实践时会详细讲。

*****

## 19.9、用户登录实战

### 19.9.1、添加/bin/login到sysinit

（1）在inittab中修改，去掉/bin/sh，换上/bin/login，则系统启动后出现登录界面。可以输入用户名和密码。

（2）实验现象：成功出现用户登录界面，但是死活密码不对。

### 19.9.2、添加passwd和shadow文件

（1）为什么用户名和密码不对？因为我们根本没有为root用户设置密码。

（2）linux系统中用来描述用户名和密码的文件是passwd和shadow文件，这两个文件都在etc目录下。passwd文件中存储的是用户的密码设置，shadow文件中存储的是加密后的密码。

（3）我们直接复制ubuntu系统中的/etc/passwd和/etc/shadow文件到当前制作的rootfs目录下，然后再做修改即可。

（4）/etc/passwd和/etc/shadow修理好后，shadow中默认有一个加密的密码口令，这个口令和你拷贝的shadow本身有关，像我的ubuntu中root用户的密码就是root，因此复制过来后登陆时的密码还是root。

### 19.9.3、重置密码实践

（1）ubuntu刚装好的时候默认登录是用普通用户登录的，默认root用户是关闭的。普通用户的密码是在装系统的时候设置的，普通用户登陆后可以使用su passwd root给root用户设置密码，设置了密码后root用户才可以登录。

（2）其实这个原因就是root用户在/etc/shadow文件中加密口令是空白的。所以是不能登录的。

（3）busybox中因为没有普通用户，所以做法是：默认root用户如果加密口令是空的则默认无密码直接登录。等我们登陆了之后还是可以用passwd root给root用户设置密码。

（4）平时有时候我们忘记了自己的操作系统的密码，怎么办？有一种解决方法就是用其他系统（WindowsPE系统或者ubuntu的单用户模式等···）来引导启动，启动后挂载到我们的硬盘上，然后找到/etc/shadow文件，去掉密文密码后保存。然后再重启系统后密码就没了。

### 19.9.4、getty实战

（1）大家后面做项目会发现，inittab中最常见的用于登录的程序不是/bin/login，反而是/sbin/getty。

（2）这两个的差别不详，但是在busybox中这两个是一样的。这两个其实都是busybox的符号链接而已。因此不用严格区分这两个

（3）我们可以在inittab中用getty替换login程序来实现同样的效果。

****

## 19.10、动态链接库的拷贝

### 19.10.1、静态编译链接helloworld程序并执行

（1）任务：自己写一个helloworld程序，然后交叉编译连接，然后丢到开发板根文件系统中，开机后去运行。

（2）C程序如果使用gcc来编译则可以在主机ubuntu中运行，但是不能在开发板运行；要在开发板运行需要用arm-linux-gcc来交叉编译，但是这时候就不能在主机ubuntu中运行了。我们可以用file xx命令来查看一个elf可执行程序是哪个架构的。

（3）静态链接：arm-linux-gcc hello.c -o hello_satic -static

（4）实验结果：静态编译连接后生成的hello_satic已经可以成功运行。

### 19.10.2、动态编译连接helloworld程序并执行

（1）动态链接：arm-linux-gcc hello.c -o hello_dynamic

（2）实验结果：-sh: ./hello_dynamic: not found运行时提示找不到程序。

（3）错误分析：动态连接的hello程序中调用到了printf函数，而printf函数在动态连接时要在运行时环境（开发板的rootfs）中去寻找对应的库文件（开发板rootfs中部署的动态链接库中包含了printf函数的那个库文件）。如果找到了则printf函数就会被成功解析，然后hello_dynamic程序就会被执行；如果找不到则程序就不能被执行，命令行会提示错误信息-sh: ./hello_dynamic: not found

（4）解决方案：将arm-linux-gcc的动态链接库文件复制到开发板rootfs的/lib目录下即可解决。

### 19.10.3、找到并复制动态链接库文件到rootfs中

（1）我们用的arm-2009q3这个交叉编译工具链的动态链接库在/usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/lib目录下。其他的一些交叉编译工具链中动态链接库的目录不一定在这里，要去找一下。找的方法就是find

（2）复制动态链接库到roots/lib目录下。复制时要注意参数用-rdf，主要目的就是符号链接复制过来还是符号链接。
复制命令：cp lib/* so * /root/porting_x210/rootfs/rootfs/lib/ -rdf

（3）现在再去测试./hello_dynamic看看是否可以运行，实验结果是可以运行。

### 19.10.4、使用strip工具去掉库中符号信息

动态链接库so文件中包含了调试符号信息，这些符号信息在运行时是没用的（调试时用的），这些符号会占用一定空间。在传统的嵌入式系统中flash空间是有限的，为了节省空间常常把这些符号信息去掉。这样节省空间并且不影响运行。
去掉符号命令：arm-linux-strip * so*
实际操作后发现库文件由3.8M变成了3.0M，节省了0.8M的空间。

****

## 19.11、开机自启动与主流rcS格式介绍

### 19.11.1、修改rcS实现开机自启动

（1）开机自启动指的是让一些应用程序能够开机后自动执行

（2）开机自启动的实现原理就是在开机会自动执行的脚本rcS中添加上执行某个程序的语句代码即可

### 19.11.2、前台运行与后台运行

（1）程序运行时占用了当前的控制台，因此这个程序不结束我们都无法使用控制台，这就叫前台运行。默认执行程序就是前台运行的。

（2）后台运行就是让这个程序运行，并且同时让出控制台。这时候运行的程序还能照常运行而且还能够不影响当前控制台的使用。

（3）让一个程序后台运行的方法就是 ./xxx &

### 19.11.3、开机装载驱动等其他开机自动执行

实际开发过程中如果遇到需要开机自启动的驱动或者程序都是可以在rcs中添加执行开机自启动

### 19.11.4、实际开发中rootfs的rcS是怎样的

（1）我们以X210开发板九鼎科技做的rootfs中rcS部分来分析

（2）分析inittab发现：sysinit执行rcS，shutdown时执行rcK。

（3）分析/etc/init.d/rcS和rcK文件发现，rcS和rcK都是去遍历执行/etc/init.d/目录下的S开头的脚本文件，区别是rcS传参是start，rcK传参是stop。

（4）由此可以分析出来，正式产品中的rcS和rcK都是一个引入，而不是真正干活的。真正干活的配置脚本是/etc/init.d/S??*。这些文件中肯定有一个判断参数是start还是stop，然后start时去做一些初始化，stop时做一些清理工作。

****

## 19.12、制作ext2格式的镜像并烧录启动

### 19.12.1、确定文件夹格式的rootfs可用

（1）设置bootargs为nfs启动方式，然后从主机ubuntu中做好的文件夹格式的rootfs去启动，然后看启动效果，作为将来的参照物。

### 19.12.2、动手制作ext2格式的镜像

```c
dd if=/dev/zero of=rootfs.ext4 bs=1024 count=10240
mkfs.ext4  -F  rootfs.ext4
sudo mount  -t  ext4 rootfs.ext4  ./rootfs_ext4
```

（2）向./rootfs中复制内容，用sudo cp -raf ~/nfs/rootfs/*  ./

（3）sudo  umount  /mnt


（4）完成后得到的rootfs.ext2就是我们做好的rootfs镜像。拿去烧录即可。

### 19.12.3、烧录镜像并设置合适的bootargs

（1）使用fastboot烧录制作好的rootfs.ext2到开发板inand中
fastboot flash system rootfs.ext2
烧录完成后重启系统

（2）设置bootargs为：set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext2

（3）启动后发现现象和之前nfs方式启动挂载rootfs后一样的，至此rootfs制作实验圆满完成。

### 19.12.4、总结

（1）13节课将rootfs的制作步骤和原理已经完全清楚的讲完了

（2）制作过程本身如果有文档指导非常容易，非常简单，但是我们学习时侧重于不是rootfs制作本身，而是rootfs工作的原理分析。

