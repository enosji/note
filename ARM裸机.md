# 1、ARM那些你得知道的事

## 1.1、ARM成长史

### 1.1.1、ARM里程碑

- ARM前身是爱康电脑（Acorn）于1978，于英国剑桥创立。
- 在1980年代晚期，苹果电脑开始和爱康电脑合作开发新版ARM核心。
- 1985年开发出全球第一台商用RISC处理器，即ARM1。
- 1990年爱康电脑财务危机，受苹果和VLSI的投资，分割出独立子公司Advanced RISC Machines（ARM），ARM公司正式问世。RISC：精简指令集。
- 1991年，ARM推出第一款嵌入式RISC处理器，即ARM6
- 1993年，发布ARM7
- 1997年，发布ARM9TDMI
- 1999年，发布ARM9R
- 2001年，发布ARMv6构架
- 2002年，发布ARM11微构架
- 2004年，发布ARMv7架构的Cortex系列处理器，同时推出Cortex-M3
- 2005年，发布Cortex-A8处理器（就是我们的210开发板的处理器）
- 2007年，发布Cortex-M1和Cortex-A9
- 2009年，实现Cortex-A9、发布Cortex-M0
- 2010年，推出Cortex-M4、成立Linao（这个公司专门做ARM处理器在linux平台上的开发和移植），推出Cortex-A15MPcore高性能处理器
- 2011年，推出Cortex-A7、ARMv8发布
- 2012年，开始64位处理器进程
- …………

*****



## 1.2、ARM的商业模式和生态系统

ARM之前的半导体公司

- Intel、AMD、Motorola、Zilog、VIA等
- 自己设计IC、自己生产芯片、自己销售

ARM的商业模式

- ARM只设计IC，并且出卖自己的设计IP（版权）

- ARM自己不生产芯片，而是把设计的IP授权给其他半导体公司让厂商来生产芯片。

- 严格来说，ARM并不是一家半导体厂商。

  

  *****

## 1.3、为什么是三星

三星的优点：

- 本身使用范围广泛、有很好的企业应用基础
- 资料多，积累好，便于学习
- 开发板和方案商多，软硬件平台好找
- 体系很经典，时候学习

三星主要的ARM CPU：

- ARM7		44B0

- ARM9        2440  2410

- ARM11       6410

- A8              S5PV210  S6PC100

- A9              4412   4418

  

## 1.4、各种版本号

### 1.4.1、描述ARM的几种版本号

- ARM内核版本号（ARM设计出来后卖个别的公司的版本号）（ARMv7）
- ARM SoC版本号                                                                      (Cortex-A8)
- 芯片型号                                                                                 （S5PV210）

### 1.4.2、ARM型号的发展

| 内核版本号 |  Soc版本号  | 芯片型号(三星)  |
| :--------: | :---------: | :-------------: |
|   ARMv1    |             |                 |
|     ……     |             |                 |
|   ARMv4    |    ARM7     |     S3C44B0     |
|   ARMv4    |    ARM9     | S3C2440 S3C2410 |
|   ARMv5    | ARM9+XScale |                 |
|   ARMv6    |    ARM11    |     S3C6410     |
|            |  Cortex-M   | M0 M0+ M3 M4 M7 |
|   ARMv7    |  Cortex-A   |                 |
|            |  Cortex-R   |                 |

Cortex-M  :microcontroller  微控制器	单片机	stm32

Cortex-A：application		就是手机、平板、电脑的CPU

Cortex-R：realtime 实时处理器		响应速度快，主要用在工业、航空航天

实时操作系统 RTOS	单片机

Linux 和Windows还有Android都不是实时操作系统

|          Cortex-A          |     芯片型号     |
| :------------------------: | :--------------: |
|         Cortex-A8          | S5PV210/S9PC100  |
|         Cortex-A9          |    Exynos4412    |
|  Cortex-A7（A9的阉割版）   | 全志A10 A20 A31  |
| Cortex-A15（A9的高性能版） | exynos5250 5450  |
|         64位处理器         |                  |
|       Cortex-A53 A57       | 高通骁龙815和410 |

==注意==：

- ARM内核版本号和SoC版本号是由ARM确定的，而SoC的型号是由半导体公司确定的。
- Cortex系列上市后，ARM产品线分割成3个系列，这是市场细分的需要和选择
- ARM已经发布了一些64位架构的如A53等，主要面向高性能服务类应用
- ARM下一步重点发展方向是Cortex-M7，特点是低功耗，主要面向物联网终端

*****

## 1.5、SoC、CPU和外设的概念

CPU：运算器加控制器就等于CPU

SoC和CPU

- SoC = System on Chip（芯片）（就是在一个芯片里装一个系统）
- 芯片的发展方向：从CPU到SoC
- 现在已经没有纯粹的CPU了，都是SoC
- ARM出卖的内核其实就是CPU（当然还需要添加总线），各种外设是半导体公司自己添加的

以前CPU的工作原理：

​		当时的cpu只有运算和控制的功能，在一块pcb板子上装上CPU芯片和串口控制器、LCD控制器、Nand控制器这些外设互相由pcb走线相互连接 以前的只能叫 System on Board(PCB板)

外设：外部设备  peripheral  只要不是在CPU里面的都是外设

现在的SoC的工作原理：

​		 就是 在一个芯片里面既有CPU又有内置的其他外设他们的连接时靠芯片内部的总线。

ARM所买的就是SoC里面的CPU和芯片内部的总线，其他外设由半导体公司添加。

外设（Peripheral）

- 外设就是外部设备
- SoC中的外设大部分都跑进去了
- 网卡、音频编解码等个别的还经常在外面
- 芯片设计的趋势是更大集成度，近年甚至讲音频编解码、DDR都集成进了SoC内做出所谓的单芯片解决方案。如华为海思Hi3518E
- 裸机学习其实就是学习的SoC的内核（CPU，表现为汇编指令集）和各种外设（如串口）。

******

## 1.6、主流学习型芯片介绍

三星的：

- S3C44B0
- S3C2440、S3C2410
- S3C6410
- S5PV210
- Exynos4412、S5P4418

其他半导体厂商的

- Freecale i.MX5系列
- TI Omap 系列
- Qualcomm 晓龙系列
- 全志科技A10 A20 A33等
- 行业专用型SoC如华为海思HI3518系列

课程平台

- SoC：三星S5PV210
- 开发板：九鼎科技X210
- 逻辑实验方法：USB启动下载+SD卡启动
- bootloader支持：uboot、xboot
- 操作系统支持：Linux2.6.35、Linux3.0.8、Android2.3、Android4.0.4

****

## 1.7、210开发板

## 1.8、嵌入式和单片机的区别

芯片平台

- 主流的单片机平台：51、PIC、STM32、AVR、MSP430等
- 主流的嵌入式平台：ARM、PPC、MIPS

资源、价格、应用领域

- 单片机片上资源有限、价格低、应用领域多为小家电、终端设备等。
- 嵌入式系统片上资源丰富、价格较高、应用领域宽广，列如智能手机、平板电脑、游戏机、路由器、摄像头等。

开发模式

- 单片机开发多是裸机，程序规模小，多为单个程序员独立开发。有些复杂的产品也会使用高端单片机如STM32之类的，并使用RTOS（uCOS、freeRTOS等）。
- 嵌入式开发几乎全部基于嵌入式操作系统，目前使用最多的就是linux和Android

技术特征

- 编程语言方面：单片机主要使用C语言（少量用汇编），和标准c略有不同，很少使用结构体、函数指针等c语言的高级特性。而嵌入式开发较复杂，一般分为底层和应用层。底层使用C语言，应用层使用C、C++、java等语言均有。嵌入式C语言对结构体、数据结构、算法、函数指针（用来实现面向对象）等高级特性使用比较多。
- 软硬件组件方面：单片机多涉及一些简单外设，例如说串口、I2C、ADC、LCD（小屏幕和分辨率）；而嵌入式系统则涉及更多复杂外设，例如网络（有线网卡、wifi、蓝牙等）、USB、音视频编解码等。

****

## 1.9、嵌入式学习和编程语言、英语水平的关系

嵌入式和编程语言

- 嵌入式开发主要使用C语言
- 辅助为汇编语言
- 中间层开发用C++多一些
- 应用层开发用C++、Java、python、tcl/tk、perl等

*****

## 1.10、嵌入式系统的构成特点和发展演进

### 1.10.1、嵌入式系统特点

- 专用、软硬件可裁剪可配置
- 低功耗、高可靠性、高稳定性
- 软件代码短小精悍
- 代码可固化
- 实时性
- 弱交互
- 专用开发工具及开发环境
- 专业开发人员

嵌入式系统的组成特点

硬件：

- 微处理器
- 存储器（内存、flash等）
- I/O接口、输入输出设备等等

软件：（分层的）

- 嵌入式操作系统
- BSP  （board support package板级支持包）
- 应用软件

### 1.10.2、嵌入式系统的分层

上层：应用程序		GUI、GPRS、3G、WiFi

中层：操作系统		智能操作系统、操作平台

底层：硬件				中央处理器、ROM、RAM、IO设备和电源

### 1.10.3、嵌入式系统的发展演进

- 以单芯片为核心，可编程控制器存在的形式

  —   没有操作系统支持

  —   软件以汇编为主

  —	功能单一、处理效率低、存储容量小、没有对外接口

  —	使用简单、价格低
  
- 以嵌入式CPU为基础、简单操作系统为核心

  —	CPU种类多、通用性弱、

  —	系统开销小、效率高

  —	达到一定的兼容性、拓展性

  —	用户体验度不够、交互性界面不够友好

- 以嵌入式操作系统为标志

  —   兼容性号，适用于不同的平台

  —   系统开销小，效率高，具有高度模块化及拓展

  —   图形化界面，用户界面友好

  —   丰富的外部接口

- 以物联网为标准
  —   将传感器技术，互联网技术及传统嵌入式技术综合联系

  —    小型化、智能化、网络可视化

  —    低功耗、绿色环保

  —    多核技术、云计算技术及虚拟化技术

***

## 1.11、何为交叉编译

### 1.11.1、两种软件开发模式

- 非嵌入式开发（桌面电脑开发），A（类）机编写（源代码）、编译得到可执行程序，发布到A（类）机运行。
- 嵌入式开发，A（类）机编写（源代码）、编译得到可执行程序，发布给B（类）机运行。这种方式就是叫交叉编译

### 1.11.2、 交叉编译的原因

- 嵌入式开发的CPU比较简单，本身无法搭载开发环境，有些甚至是操作系统都没有。

- 交叉编译可以用高性能机器为低性能机器开发软件（包括裸机软件、系统级和应用级软件）

### 1.11.3、交叉编译的特点

- 必须使用专门的交叉编译工具链
- 由于可执行程序不能本地运行调试，因此必须配合一定手段（专用调试器，JTAG调试器、USB下载、串口下载、SD启动、网络共享等）将可执行程序加载到目标嵌入式设备上运行及调试

*****

## 1.12、CPU的设计原理、数据总线和地址总线

一般CPU的三部分：

运算器：进行数学运算的

控制器：控制CPU的运行，读取指令代码

寄存器：快速的临时内存

平时数据是存储在Flash里的，需要时通过总线将数据读取到CPU的寄存器里，再将数据传到内存，在内存里运行。

地址总线和数据总线

地址和数据是分开传输的

- CPU通过地址总线寻址，然后通过数据总线与外部设备互换信息
- 地址总线的位数决定CPU寻址范围；数据总线的位数决定CPU单次通信能交换的信息数量（平时说的32位/64位说的就是数据总线的位数）
- 总线的速度决定CPU和外设互换信息的速度

==注意==

- CPU的地址总线位数和数据总线位数可以不同（典型的就是51单片机），但是一般都是相同的
- CPU的位数一般说的就是数据总线的位数
- 32位CPU寻址的范围是4G，所以最多支持4G内存
- 数据总线是32位的，所以内存是32位的最好，所以编程一般推荐使用int

*****

## 1.13、为何需要Jlink、SD卡等辅助设备

嵌入式开发特点

- 交叉编译，不便于本机运行调试程序
- 嵌入式系统需要bootloader来启动，而bootloader必须首先存在于可启动的介质中，这个过程需要专用工具
- 嵌入式系统无法通过纯软件实现单步调试，因此必须借助专业的调试器

Jlink的作用

- 下载可执行程序到目标机
- 在目标机上实现单步调用，便于开发bootloader。

SD卡的作用

- 作为启动介质。工作方式是：事先用读卡器将SD卡连接到开发机（一般是Windows电脑），通过写卡软件将交叉编译得到的可执行程序镜像烧录到SD卡，然后将SD卡插入嵌入式目标机卡槽，设置正确的启动方式，则系统可以从SD卡中烧录的镜像处启动

USB转串口线

- 串口本身用来做嵌入式目标机的调试输出，主要目的是用来监控及调试软件。
- 因为现在大多数个人电脑（大部分台式机和几乎全部的笔记本电脑）都未配置DB9串口，因此工作中一般直接使用USB转串口线来连接PC和开发板

其他开发辅助工具

- USB OTG线（OTG是USB的一种规范）
- DB9串口线
- 交叉网线（观察网线两端排线是否一致，一致就不是交叉网线）

****

# 2、ARM体系结构与汇编指令

## 2.1、可编程器件的编程原理

可编程器件的特点

- CPU在固定频率的时钟控制下节奏运行
- CPU可以通过总线读取外部存储设备中的二进制指令集，然后解码执行
- 这些可以被CPU解码执行的二进制指令集是CPU设计的时候确定的，是CPU的设计者（ARM公司）定义的，本质上是一串由1和0组成的数字。这就是CPU的汇编指令集。

整个编译及运行过程

- 程序员用汇编指令编程—经汇编器汇编成二进制可执行文件—>二进制文件被CPU读取进去—>CPU内部电路对二进制文件解码—>解码通过则CPU执行指令、完成指令动作
- 如果程序员用C语言等高级语言编程，则编译器先将C语言编译为汇编程序，在进行上面的后续部分。

*****

## 2.2、指令集对CPU的意义

### 汇编语言与C语言的差异

- 汇编难写，C语言好写
- 汇编无可移植性，C语言有一定的可移植性，Java等高级语言移植性跟好
- 汇编语言效率最高，C语言次之，Java等高级语言效率更低
- 汇编不适合完成大型复杂项目，更高级的语言更适合完成更大、更复杂的项目

### 汇编语言的本质

- 汇编语言的本质是机器指令（机器码）的助记符，是一种低级符号指令
- 机器指令集是一款CPU的编程特征，是这款CPU的设计者制定的，CPU的内部电路设计就是为了实现这些指令集的功能。机器指令集就好像CPU的API接口一样。

### 编程语言的发展过程

- 纯机器码编程
- 汇编语言编程
- C语言编程
- c++语言编程
- Java C#等语言编程
- 脚本语言编程

总结

- 汇编语言就是CPU的机器指令集的助记符，是一款CPU本质特征
- 不同CPU的机器指令集设计不同，因此汇编语言不能在不同的CPU之间相互移植。
- 使用汇编编程可以充分发挥CPU的设计特点，所以汇编编程的效率最高，因此在操作系统内核中效率极其重要的地方都需要汇编处理。

****

## 2.3、RISC和CISC的区别

### 2.3.1、CISC

- complex instruction set computer 复杂指令集CPU
- CISC体系的设计理念是用最少的指令来完成任务（列如计算乘法只需要一条MUL指令即可），因此CISC的CPU本身设计复杂、工艺复杂，但是好处是编译器好设计。CISC出现较早，至今Intel还一直采用CISC设计

### 2.3.2、RISC

- Reduced Instruction-set computer 精简指令集CPU
- RISC的设计理念是让软件去完成具体的任务，CPU本身仅提供基本功能指令集。因此这种设计相对与CISC，CPU的设计和工艺简单了，但是编译器的设计难度增加了。

### 2.3.3、CPU设计方式的发展

- 早期简单CPU，指令和功能有限
- CISC年代——CPU功能扩展依赖于指令集的扩展，实质是CPU内部组合逻辑电路的扩展
- RISC年代——CPU仅提供基础功能指令集（列如内存于寄存器通信指令，基本运算与判断指令等），功能的拓展由使用CPU的人利用基础构件灵活实现。

*****

## 2.4、同一编址&独立编址&哈佛结构&冯诺依曼结构

### 2.4.1、什么是IO，什么是内存

- 内存是程序的运行场所，内存和CPU之间通过总线连接，CPU通过一定的地址来访问具体的存放单元
- IO（input and output）是输入输出接口，是CPU和其他外部设备（如串口、LCD、触摸屏、LED等）之间通信的道路。一般的，IO就是指CPU的各种内部或者外部外设。

### 2.4.2、内存的访问方式

- 内存是通过CPU的地址总线来寻址定位的，然后通过CPU数据总线来读写
- CPU的地址总线的位数是CPU设计时确定的，因此一款CPU所能寻址的范围时一定的，而内存是需要占用CPU的寻址空间的。
- 内存与CPU的这种总线式连接方式是一种直接连接，优点是效率高访问快，缺点是资源有限，扩展性差。

### 2.4.3、IO的访问方式

- IO指的是与CPU连接的各种外设
- CPU访问各种外设由两种方式：一种是类似于访问内存的方式，即把外设的寄存器当作一个内存地址来读写，从而以访问内存的相同方式来操作外设，叫IO与内存的同一编址（类似RISC的理念，所以同一编址一般出现在ARM的CPU里）；另一种是使用专用的CPU指令来访问某种特定外设，叫IO和内存独立编制（相当于CISC的理念）

==对比==

- 由于内存的访问频率高，因此采用总线式的连接，直接访问地址，效率最高
- IO与内存的同一编址方式，优势式IO当作内存来访问，编程简单；缺点就是IO也需要占用一定的COP地址空间，而CPU的地址空间是有限资源
- IO与内存独立编址方式，优势是不占用CPU地址空间；缺点是CPU的设计变复杂了。

程序和数据

- 程序运行时的两大元素：程序（编写的函数）+数据（定义的变量）
- 程序是我们写好的源代码经过编译、汇编之后得到的机器码，这些机器码可以拿给CPU去解码执行，CPU不会也不应该去修改程序，所以程序是只读的
- 数据是程序运行过程中定义和产生的变量的值，只可以读写的，程序运行实际上就是改变数据的值。

****

### 2.4.4、冯诺依曼结构和哈佛结构

- 程序和数据都存放在内存中，且不彼此分离的结构称为冯诺依曼结构，列如说Intel的CPU 采用的就是冯诺依曼结构。
- 程序和数据分开独立放在不同的内存快中，彼此完全分离的结构称为哈佛结构，列如大部分的单片机和嵌入式多采用哈佛结构。

优劣对比

- 冯诺依曼结构中的程序和数据不区分的放在一起，因此安全和稳定性是个问题 ，好处是处理起来简单。
- 哈佛结构中程序（一般放在ROM、flash中）和数据（一般放在RAM中）独立分开存放，因此好处是安全和稳定性高，缺点是软件的处理复杂一些（需要统一规划链接地址等）

***

## 2.5、软件编程控制硬件的关键—寄存器

### 2.5.1、什么是寄存器

- 寄存器属于CPU外设的硬件组成部分
- CPU可以像访问内存一样访问寄存器
- 寄存器是CPU硬件设计者指定的，目的是留作外设被编程控制的“活动开关”
- 正如汇编指令集是CPU的编程接口API一样，寄存器是外设硬件的软件编程接口API。使用软件编程控制某一硬件，其实就是编程读写改硬件的寄存器

### 2.5.2、寄存器的演示

- 请看S5PV210 datasheet
- 编程操作寄存器类似于访问内存
- 寄存器中每个bit位都有特定含义，因此编程操作时需要位操作
- 单个寄存器的位宽一般和CPU位宽一样，以实现最佳访问效率

### 2.5.3、两类寄存器

- SoC中有两类寄存器：通用寄存器和SFR通用寄存器
- 通用寄存器（ARM中有37个）是CPU的组成部分,CPU的很多活动都是需要通用寄存器的支持与参与，通用寄存器的功能是没有定的，可以自己去赋予的
- SFR（special function register，特殊功能寄存器）不在CPU中，而是存在于CPU的外设中，我们通过访问外设的SFR来编程操控这个外设，这就是硬件编程的一种方法，SFR通用寄存器的功能是与某个外设事先绑定的，他的功能是事先确认好的。

### 2.5.4、编程访问寄存器的方法

1、汇编方式访问

`ldr r1, =0xE0200280`

`str r0, [r1]`

`mov r0, #0`   

2、C语言方式

`int *p = (int *)0x30008000;`

`*p = 16`

***

## 2.6、ARM体系结构要点总结

### 2.6.1、ARM是RISC架构

- 常用的ARM汇编指令只有二三十条
- ARM是低功耗CPU
- ARM的架构非常适合单片机、嵌入式，尤其是物联网领域；而服务器等高性能领域的主导目前还是Intel。

### 2.6.2、ARM是同一编址的

- 大部分ARM（M3 M4 M7 M0 ARM9 ARM11 A8 A9）都是32位架构
- 32位ARM CPU 支持的内存少于4G，通过CPU地址总线来访问’
- SoC中的各种内部外设通过各自的SFR编程访问，这些SFR的访问方式类似访问普通内存，这叫做IO与内存的统一编址

### 2.6.3、ARM是哈佛结构

- 常见的ARM（除ARM7外）都是哈佛结构的
- 哈佛结构保证了ARM CPU允许的稳定性和安全性，因此ARM适用于嵌入式领域
- 哈佛结构也决定了ARM裸机程序（使用实地址即物理地址）的链接比较麻烦，必须使用复杂的链接脚本告知链接器如何组织程序；对于OS之外的应用（工作在虚拟地址之中）则不需要考虑这么多

***

## 2.7、S5PV210的内存（地址）映射访问详解

### 2.7.1、什么是内存映射

- S5PV210属于ARM Cortex-A8架构，32位CPU，CPU设计时就是有32根地址总线&32根数据总线
- 32位地址总线决定了CPU的地址内存空间位4G，那么这4G空间如何分配使用，这个问题就是内存映射问题（地址映射）

### 2.7.2、一些简单的专业术语

- ROM：read only memory 只读存储器
- RAM：ramdom access memory 随机访问存储器
- IROM：internal rom 内部ROM，指的是集成在SoC内部的ROM
- IRAM：internal ram 内部RAM，指的是集成在SoC内部的RAM
- DRAM：dynamic ram 动态RAM
- SRAM：static ram 静态RAM

***

## 2.8、CPU和外部储存器的接口

### 2.8.1、内存和外存

内存就是内部存储器，是用来运行程序的又叫RAM（DRAM SRAM DDR）

外存就是外部存储器，是用来存储东西的又叫ROM（硬盘 Flash（Nand、iNand、U盘、SSD……）光盘）

CPU连接内存和外存的连接方式是不同的，内存需要直接地址访问（你可以直接通过内存访问内存），所以是通过地址总线&数据总线的总线方式连接的（好处的直接访问，随机访问；坏处是占用CPU的地址空间，大小是受限的）；外存是通过CPU的外存接口来连接到（好处是不占用CPU的地址空间；坏处是访问速度没有总线快，访问时序较为复杂）

### 2.8.2、SoC常用的外部存储器

NorFlash类（电子式、电子存储原理）

- NorFlash：特点是可以总线式访问，可以直接接在内存的SROM Bank中，优点是可以直接总线访问，一般用来启动。

NandFlash类型（不能直接总线访问）

- NandFlash：分为SLC和MLC，SLC工艺导致其容量不是很大但是时序比较简单，稳定性好，不容易出现坏块；MLC容量可以做的很大，但是其时序比较复杂，容易出现坏块。
- eMMC/iNand/moviNand：eMMC就是（embeded MMC）嵌入式的MMC卡里面集成了一些电路用来帮助CPU去管理和检查内部坏块，减轻CPU的工作量。iNand 是sanDisk公司出产的eMMC，moviNand是三星公司出产的eMMC
- oneNAND：是三星公司出的一种Nand
- SD卡/TF卡/MMC卡
- eSSD：就是（embeded SSD）SSD就是固态硬盘里面其实就是MLC

硬盘类（机械式、磁存储原理）

- SATA硬盘，SATA是一种接口（现在市面上几乎都是这种接口的硬盘）

### 2.8.3、总结

1、现代SoC支持多种外部存储器

2、外部存储器主要用来存储程序（可执行代码），相当于电脑的硬盘

3、各种不同外部存储器原理不同，大小、性价比不同，一般产品厂家根据需要选择合适自己的产品的外存使用

4、外部存储器和CPU连接一般不是通过地址总线&数据总线直接相连的，因为地址空间不够用，一般都是通过专门的接口来连接的

***

## 2.9、S5PV210启动过程详解

### 2.9.1、一些设备的特性

内存：

​	SRAM	静态内存，特点是容量小，价格高；优点是不需要软件初始化，一上电就能用

​	DRAM	动态内存	特点是容量大，价格低；缺点就是上电后不能直接使用，需要软件初始化后才能使用

总结：

​	单片机中：内存需求小，而且希望开发尽量简单，适合全部使用SRAM

​	嵌入式系统：内存需求量大，而且没有NorFlash等启动介质

​	pc机中：内存需求量大，而且软件复杂，不在乎DRAM的初始化开销，适合全部用DRAM

外存：

​	NorFlash：特点是容量小，价格高，优点是可以和CPU直接总线式相连，CPU上电后可以直接读取，所以一般作为启动介质。

​	NandFlash（和硬盘类型）：特点是容量大，价格低，缺点是不能总线式访问，也就是不能上电CPU直接读取，需要CPU先运行一些初始化软件，然后通过时序接口读写

所以一般PC机都是：小容量的BIOS（NorFlash）+大容量的硬盘（类似NandFlash）+大容量的DRAM

一般单片机的配比：很小容量的NorFlash+很小容量的SRAM

嵌入式系统：因为NorFlash很贵，所以现在很多嵌入式系统倾向于不用NorFlash，直接用：外接的Nand + 外接的DRAM + SoC内置的SROM

S5PV210使用的启动方式是：外接的Nand + 外接的DRAM + SoC内置的SROM

实际上210启动还要更复杂些：210内置一块96KB大小的SRAM（又叫iRAM），同时还有一块内置的64KB大小的NorFlash（又叫iROM）

### 2.9.2、210的启动过程的大致：

​	第一步：CPU上电后先从内部的IROM内部读取先设置的代码（BL0），执行。这段IROM代码做了一些基本的初始化（CPU时钟、管看门狗……）这一段IROM代码是三星出厂前设置的，三星也不知道我们的板子上将来使用的是什么样的DRAM，因此这一段IROM是不能负责初始化外接的DRAM，因此这段代码只能初始化SoC内置的东西；然后这段代码会判断我们的启动模式（我们可以通过硬件的条线可以更改板子的启动模式），然后从相应的外部存储器去读取第一部分启动代码（BL1，大小为16k）到内部的SRAM。

​	第二步：从IRAM去运行上一步读取来的启动代码BL1（16KB），然后执行。BL1负责初始化NandFlash，然后将BL2读取到IRAM（剩余的空间）然后运行

​	第三步：从IRAM运行BL2，BL2初始化DRAM，然后将OS读取到DRAM中，然后启动OS，启动过程结束。

​	思路：因为启动代码的大小是不定的，有些公司可能96kb就够了，有些公司可能1mb都不够，三星的解决方案就是把启动代码分两半（BL1和BL2），这两部分协同工作来完成启动。

### 2.9.3、iROM和iRAM

- S5PV210出厂时内置了64KB iROM和96KB iRAM。iROM中预先内置烧录了一些代码（称为iROM代码），iRAM属于SRAM（不需要软件初始化，上电即可用），210启动时首先在内部运行iROM代码，然后由iROM代码开启外部启动流程
- 设计iROM和iRAM的原因就是为了支持多种外部设备启动

### 2.9.4、Second boot support（二次启动）

- 当第一次启动失败时，SD/MMC卡启动模式下将会从SD/MMC2通道再次启动
- 这种二级启动是一种冗余设计，SoC中的第一次启动介质故障而导致不能启动时，可以从备用启动介质启动，我们做逻辑实验时从SD2启动就是利用这种设计特性

### 2.9.5、使用iROM启动的好处

1、降低BOM成本，因为iROM可以使SoC从各种外设启动，因此可以省下一块bootrom（专门用来启动的rom，一般是norflash）

2、支持各种校验类型的nand

3、可以在不使用编程器的情况下使用一中外部存储器运行程序来给另一种外部存储器编程烧录。这样生产时就不用额外购买装用的编程器了，降低了量产成本。

### 2.9.6、iROM程序启动时做的事情

- 关看门狗
- 初始化指令cache
- 初始化栈
- 初始化堆
- 初始化块设备复制函数（硬盘之类的）（device copy function）
- 设置SoC的时钟系统
- 复制BL1到内部的IRAM（16KB）
- 检查BL1的校验和（就是这段代码的所有字节加起来的数字）
- 跳转到BL1去执行

wake up status 唤醒状态（复位状态）

### 2.9.7、S5PV210的所有启动

- 先1st启动，通过OMpin选择启动介质
- 再2nd启动，从SD卡通道2启动
- 如果失败再Uart启动
- 再失败就USB启动

***

## 2.10、如何在开发板上选择不同启动方式

SoC通过通过OMpin来识别外部启动介质

具体查看S5PV210硬件手册

### 2.10.1、体验从SD0的eMMC启动

- 开发板收到默认就是从eMMC启动，内部预先烧录了Android

### 2.10.2、从SD2启动

- 可以使用外置SD卡从SD2通道启动，但是必须先破坏板载的eMMC中的Android镜像因为默认的是SD卡通道0启动，只有当通道0启动失败才执行二次启动。
- 所以OMpin设置和SD0启动一样

### 2.10.3、总结

- 拨码开关设置我们只需要动OM5即可，其他几个根本不需要动，需要SD启动时OM5打到GND，需要USB启动时OM5打到VCC
- 可以先不销毁eMMC中的Android，而是使用USB启动做逻辑实验，之后的课程USB和SD卡启动都会用

***

## 2.11、ARM的编程模式和7种工作模式

### 2.11.1、ARM的基本设定

- ARM采用32位架构
- ARM的约定
  - Byte（字节）：8 bite
  - Halfword：16 bite（2 byte）
  - word：32 bite （4 byte）
- 大部分ARM core 提供：
  - ARM 指令集（32 bit）
  - Thumb 指令集（16 bit）
  - Thumb2 指令集（16&32 bit）
- Jazelle cores 支持 Java bytecode

### 2.11.2、ARM处理器的工作模式

非特权模式
-  User：非特权模式，大部分任务执行这种模式

特权模式（异常模式）

- FIQ：当一个高优先级（fast）中断产生时将会进入这个模式
- IRQ：当一个低优先级（normal）中断产生时将会进入这个模式
- Supervisor：当复位或软中断指令执行时将会进入这个模式
- Abort：当存取异常时将会进入这个模式
- Undef：当执行未定义指令时会进入这个模式

系统模式

- System：使用和User模式相同寄存器集的特权模式

==注意==

- 除User（用户模式）是Normal（普通模式）之外的其他6个都是Privilege特权模式
- Privilege中除Sys模式外，都是5种异常模式
- CPU同时只能有一个模式，各种模式的切换，可以是程序员通过写代码主动切换（通过写CPSR寄存器）；也可以是CPU在某些情况下自动切换
- 各种模式下权限和可以访问的寄存器不同

### 2.11.CPU设计这么些模式的原因

- CPU是硬件，OS是软件，软件的设计要依赖硬件的特性，硬件的设计要考虑软件的需要，便于实现软件特性
- 操作系统有安全级别要求，因此CPU设计多种模式是为了方便操作系统的多种安全等级需要

***

## 2.12、ARM的37个寄存器

### 2.12.1、ARM内部的寄存器

寄存器分为通用型寄存器和特殊功能寄存器（外设）

通用型寄存器是在ARM内部的，他的功能是未知的我们可以自定义，我们访问通用性寄存器是靠寄存器的名字访问的，访问特殊功能寄存器是靠其地址访问的，其功能是已经定好的。

1、ARM总共有37个寄存器，但是每种模式下最多只能看见18个寄存器，其他寄存器虽然名字相同但是当前模式不可见

2、对r14这个名字来说，在ARM中共有6个名叫r14（又叫sp）的寄存器，但是在每种特点处理器模式下只有一个r14是可见的，其他r14必须切换到它的对应的模式下才能看到，这种设计叫影子寄存器（banked register）

| 当前可见寄存器 |            |  模式   |  独有   |  寄存   |   器    |         |
| :------------: | :--------: | :-----: | :-----: | :-----: | :-----: | :-----: |
|     normal     | Abort Mode |  User   |   FIQ   |   IRQ   |   SVC   |  Undef  |
|       r0       |            |         |         |         |         |         |
|       r1       |            |         |         |         |         |         |
|       r2       |            |         |         |         |         |         |
|       r3       |            |         |         |         |         |         |
|       r4       |            |         |         |         |         |         |
|       r5       |            |         |         |         |         |         |
|       r6       |            |         |         |         |         |         |
|       r7       |            |         |         |         |         |         |
|       r8       |            |         |   r8    |         |         |         |
|       r9       |            |         |   r9    |         |         |         |
|      r10       |            |         |   r10   |         |         |         |
|      r11       |            |         |   r11   |         |         |         |
|      r12       |            |         |   r12   |         |         |         |
|    r13(sp)     |  r13(sp)   | r13(sp) | r13(sp) | r13(sp) | r13(sp) | r13(sp) |
|    r14(lr)     |  r14(lr)   | r14(lr) | r14(lr) | r14(lr) | r14(lr) | r14(lr) |
|    r15(pc)     |            |         |         |         |         |         |
|      cpsr      |            |         |         |         |         |         |
|                |    spsr    |         |  spsr   |  spsr   |  spsr   |  spsr   |

==注意==：System模式使用User模式的独有寄存器集

切换模式时将模式独有的寄存器填充到当前可见寄存器内，除了独有的寄存器之外其他都是同一个寄存器

sp：堆栈指针，在我们做函数调用或者函数切换，他的作用是在切换模式的情况下将你之前模式下的程序进行保护避免在切换模式后其他模式出现问题影响到你原来模式下的程序

lr：是用来做返回控制的将需要返回的模式的地址存在lr内，也可以做函数调用的返回值

cpsr：程序状态寄存器，每一个CPU都有一个程序状态寄存器，这个寄存器是用来记录CPU的运行状态的。

spsr：用来保存cpsr的，将cpsr保存到你要切换的模式的spsr中，以便将来返回时可以恢复原来的cpsr

pc：程序控制寄存器

### 2.12.2、总结

- ARM共有37个寄存器，都是32位的长度
- 37个寄存器中的30个为“通用”型，1个固定用作pc，一个固定用做cpsr，5个固定用作5种异常模式下的spsr

### 2.12.3、cpsr程序状态寄存器

![image-20210506134636668](C:\Users\EnosJi\AppData\Roaming\Typora\typora-user-images\image-20210506134636668.png)

bit0~bit4 模式位（mode）

​	处理器的7种模式

bit5 T位

​	切换处理器状态，T = 1：处理器处于ARM状态；T = 0：处理器处于Thumb状态

bit6~bit7 I F位是中断禁止位

​	I = 1：禁止IRQ （普通中断）

​	F = 1：禁止FIQ（快速中断）

bit23~bit24 J位

​	仅ARM 5TE/J架构支持，J = 1：处理器处于Jazelle状态

bit27~bit28 Q位

​	仅ARM 5TE/J架构支持，指示饱和状态

bit28~bit31 条件位

N = Negative result from ALU（表示ALU运算得到负结果）

Z = Zero result from ALU（表示ALU运算得到0）

C = ALU operation Carried out（表示ALU进位）

V = ALU operation oVerflowed （表示ALU进位标志位溢出）

这4种状态平时都是0，当出现问题就会变化，这是自动的

==注意==

- CPSR中各bit位表明了CPU的某些状态信息，这些信息非常重要，和后面学的汇编指令息息相关（列如BLE指令中的E就和CPSR中的Z标志位有关）
- CPSR中I、F位和开中断、关中断有关
- CPSR中的mode位（bit4~bit0共5位）决定了CPU的工作模式，在uboot代码中会使用汇编进行设置

### 2.12.4、pc（r15）程序控制寄存器

- PC（Program control register ）为程序指针，PC指向哪里，CPU就会执行哪条指令（所以程序跳转时就是把目标地址代码放到PC中）
- 整个CPU中只有一个PC（CPSR也只有一个，但是SPSR有5个）

***

## 2.13、ARM的异常处理方式介绍

### 2.13.1、什么是异常处理

- 正常工作之外的流程都叫异常处理
- 异常会打断正在执行的工作，并且一般我们希望异常处理完成后继续回来执行原来的工作
- 中断是异常的一种

### 2.13.2、异步和同步

异步的	是靠中断（一种特殊的异常）来实现的

同步的	通过同步时钟让两个事件同步进行

### 2.13.3、异常向量表

- 所有CPU都有异常向量表，这是CPU设计时就设定好的，是硬件决定的
- 当异常发生时，CPU会自动动作（PC跳转到异常向量处处理异常，有时伴有一些辅助动作）
- 异常向量表是硬件向软件提供的处理异常的支持 

每一种异常对应一个地址，当出现异常后pc会跳到对应的地址内，在异常向量表的地址内对每一个异常进行处理，处理完之后再利用LR来返回到当前正在处理的事

![image-20210506163453043](C:\Users\EnosJi\AppData\Roaming\Typora\typora-user-images\image-20210506163453043.png)

### 2.13.4、ARM的异常处理机制

- 当异常产生时ARM core：
  - 拷贝CPSR到CPSR_<mode>
  - 设置适当的CPSR位：
    - 改变处理器状态进入ARM态
    - 改变处理器模式进入相应的异常模式
    - 设置中断禁止位禁止相应中断（如果需要）
  - 保存返回地址到LR_<mode>
  - 设置PC为相应异常变量
- 返回时，异常处理需要
  - 从SPSR_<mode>恢复CPSR
  - 从LR_<mode>恢复PC
  - Note：这些操作只能在ARM态执行 

### 2.13.5、总结

- 异常处理中有一些是硬件自动做的，有一些是程序员需要自己做的，需要搞清楚哪些是需要自己做的，才知道怎么些代码
- 以上说的是CPU设计时提供的异常向量表，一般称为一级向量表。有些CPU为了支持多个中断，还会提供二级中断向量表，处理思路类型于这里说的一级中断向量表

***

## 2.14 ARM汇编指令集

### 2.14.1、指令与伪指令

- （汇编）指令是CPU机器指令的助记符，经过编译后会得到一串1 0组成的机器码，可以由CPU读取执行
- （汇编）伪指令本质上不是指令（只是和指令一起写在代码中），它是编译器环境提供的，目的是用来指导编译过程，经过编译后伪指令最终不会生成机器码

### 2.14.2、两种不同风格的ARM指令

- ARM官方的ARM汇编风格：指令一般用大写、Windows中IDE开发环境（如ADS、MDK等）常用。如：LDR R0、[R1]
- GNU风格的ARM汇编：指令一般用小写字母、Linux中常用。如：ldr r0、[r1]

### 2.14.3、ARM汇编特点

#### 2.14.3.1、LDR/STR架构

- ARM采用RSIC架构，CPU本身不能直接读取内存，而需要先将内存中内容加载入CPU中通用寄存器中才能被CPU处理
- ldr（load register）指令将内存内容加载入通用寄存器中
- str（store register）指令将寄存器内容存入内存空间中
- ldr/str组合起来实现ARM CPU和内存数据交换

#### 2.14.3.2、8种寻址方式

- 寄存器寻址				mov r1，r2（将r2里面的内容运送到r1里面，r1 = r2）
- 立即寻址                    mov r0，#0xFF00（将#后面的16进制数给到r0里面）
- 寄存器移位寻址         mov r0，r1，lsl #3（将r1左移三位得到的数赋给r0）
- 寄存器间接寻址         ldr r1, [r2]（将r2里面的内存地址赋给r1）
- 基址变址寻址             ldr r1, [r2,#4]（将r2里面的地址加4赋给r1）
- 多寄存器寻址             ldmia r1!, {r2-r7,r12}（将r1开头的连续8内存地址里的                                 说加载到大括号里的寄存器中）
- 堆栈寻址                    stmfd sp!, {r2-r7, lr}（从栈里面连续访问多个字节放到我们的寄存器内）
- 相对寻址                    flag：beq flag（后面有冒号的叫标号，就是用来标记冒号后面那句的地址的，类似C语言的goto指令）

#### 2.14.3.3、指令后缀

- 同一指令经常附带不同后缀，变成不同的指令，经常使用的后缀有：
  - B（byte）功能不变，长度变为8位如：ldr  ldrb
  - H（Half world）功能不变，长度变为16字节如：ldr ldrh
  - S（signed）功能不变，操作数变为有符号如：ldr ldrsb
  - S（S标志）功能不变，影响CPSR标志位如：mov  movs

#### 2.14.3.4、条件执行后缀

mov r0, r1		相当于C语言中的 r0 = r1

moveq r0,r1		如果eq这个后缀成立，则执行mov r0，r1，如果eq不成立则本局代码直接作废，不执行。类似于C语言中的 if (eq) {r0 = r1};

==注意==

1、条件后缀是否成立，不是取决本局代码的，而是取决于这句代码之前的代码运行结果

2、条件后缀决定了本局代码是否被执行，不会影响上一句和和下面代码的运行

| 操作码 | 条件码助记符 |   CPSR标志    |          含义          |
| :----: | :----------: | :-----------: | :--------------------: |
|  0000  |      EQ      |     z = 1     |          相等          |
|  0001  |      NE      |     z = 0     |         不相等         |
|  0010  |    CS/HS     |     c = 1     |   无符号数大于或等于   |
|  0011  |    CC/LO     |     c = 0     |      无符号数小于      |
|  0100  |      MI      |     n = 1     |          负数          |
|  0101  |      PL      |     n = 0     |        正数或零        |
|  0110  |      VS      |     v = 1     |          溢出          |
|  0111  |      VC      |     v = 0     |        没有溢出        |
|  1000  |      HI      | c = 1，z = 0  |      无符号数大于      |
|  1001  |      LS      | c = 0，z = 1  |   无符号数小于或等于   |
|  1010  |      GE      |     n = v     |   有符号数大于或等于   |
|  1011  |      LT      |    n！= v     |      有符号数小于      |
|  1100  |      GT      | z = 0，n = v  |      有符号数大于      |
|  1101  |      LE      | z = 1，n！= v |   有符号数小于或等于   |
|  1110  |      AL      |     任意      | 无条件执行（指令默认） |
|  1111  |      NV      |     任意      |  从不执行（不要使用）  |



#### 2.14.3.5、多级指令流水线

- 为增加处理器指令流的速度，ARM使用多级流水线，下图为三级流水线工作原理图（S5PV210使用的是13级流水线，ARM11为8级）

![image-20210506201707418](C:\Users\EnosJi\AppData\Roaming\Typora\typora-user-images\image-20210506201707418.png)

​	以三级流水线为例，我们每条代码都经历三个步骤：取指、解码、执行；流水线的意思是当我第一条指令取指后解码时第二条指令就开始去指，依次往下流水执行，增加代码执行效率，一般指令发生跳转之后流水线都会被制空然后重新填充，流水线越多越怕被跳转被制空

- PC指向的是正被取指的指令，而非正在执行的指令，所以只在当前正在执行的指令比PC少上8字节，因为一个周期4个字节差两级流水线两个周期

***

### 2.14.4、数据传输和跳转指令

#### 2.14.4.1、数据处理指令

- 数据传输指令		mov mvn（用法一样，mov是原封不动的传递，mvn是按位取反后传递）
- 算术指令               add  sub  rsb  adc  sbc  rsc
- 逻辑指令               and  orr  eor  bic
- 比较指令               cmp  cmn  tst  teq
- 乘法指令               mvl  mla  umull  unlal  smull  smlal
- 前导零计数           clz

bic r0，r1，#0x1f  将r1内的数bit0~bit4清零，bic位清零指令，将为1的位清零

clz 就是看一个数前面有多少个0

比较指令用来比较两个寄存器中的数，比较指令特点是不用后加s就可以影响CPSR中的标志位

| 指令格式                      | 操作     | 功能说明                                      |
| ----------------------------- | -------- | --------------------------------------------- |
| **CMP** {cond} Rd, **< op2>** | 比较     | Rd - op2， 更新CPSR中的条件标志位             |
| **CMN** {cond} Rd, **< op2>** | 反值比较 | Rd + op2， 更新CPSR中的条件标志位             |
| **TST** {cond} Rd, **< op2>** | 位测试   | Rd AND op2，与操作， 更新CPSR中的条件标志位   |
| **TEQ** {cond} Rd, **< op2>** | 相等测试 | Rd EOR op2，异或操作， 更新CPSR中的条件标志位 |

#### 2.14.4.2、cpsr访问指令

- mrs & msr
- mrs用来读psr，msr用来写psr （cpsr和spsr都是用这两个指令访问的）
- CPSR寄存器比较特殊，需要专门的指令访问，这就是mrs和msr

cpsr和spsr的区别

cpsr是程序状态寄存器，整个SoC只有一个；而spsr有5个，分别在5中异常模式小，作用是当从普通模式进入异常模式时，用来保存普通模式下cpsr的，以在返回普通模式后恢复原来的cpsr。

#### 2.14.4.3、跳转（分支）指令

- b & bl & bx
- b 直接跳转（就没打算返回，一般用在绝对跳转）
- bl branch and link ，跳转前将返回地址放入lr中，以便返回，以便函数调用
- bx 跳转的同时切换到ARM模式，一般用于异常处理的跳转

#### 2.14.4.4、访存指令

- ldr/str & ldm/stm & swp
- 单个字/半字/字节的访问 ldr/str
- 多字批量访问 ldm/stm
- swp r1，r2，[r0] （将r0里面内存地址里面的值赋给r1，再将r2的值写回到r0里的内存地址里面）
- swp r1，r1，[r0]（将寄存器和内存交换内容）

#### 2.14.4.5、汇编中的立即数

- 合法立即数与非法立即数
- ARM指令都是32位的，除了指令标记和操作标记外，本身只能附带很少位数的立即数，因此立即数有合法和非法之分
- 合法立即数：经过任意位数的移位后非零的部分可以用8位表示的即为合法立即数

合法立即数的例子：0xff  非零部分是8位  0x00ff0000 也是合法的就算移位了但是非零部分还是8位

#### 2.14.4.6、软中断指令

- swi（software interrupt）
- 软中断指令（使用软件模拟实现中断）用来实现操作系统中系统调用

***

### 2.14.5、协处理器和协处理器指令

#### 2.14.5.1、协处理器cp15操作指令

- mcr & mrc
- mrc用作读取CP15中的寄存器
- mcr用作写入CP15中的寄存器

#### 2.14.5.2、什么是协处理器

- SoC内部另一个处理核心，协助CPU实现某些功能，被主CPU调用执行一定的任务
- ARM设计上支持多达16个协处理器，但是SoC中只实现其中的CP15（cp ： coprocessor 就是协处理器的意思）
- 协处理器和MMU、cache、TLB等处理有关，功能上和操作系统的虚拟地址映射、cache管理等有关

#### 2.14.5.3、MRC & MCR的使用方法

- mcr{<cond>}  p15, <opcode_1>, <Rd>, <Crn>, <Crm>, {<opcode_2>}

- opcode_1：对于cp15永远为0

- Rd：ARM的普通寄存器

- Crn：我们要操作的cp15的寄存器，合法值是c0～c15

- Crm：cp15的寄存器，一般均设为c0

- opcode_2：一般省略或为0

  cp15内每个寄存器的功能

![这里写图片描述](https://img-blog.csdn.net/20170504210311364?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFubGkyMDA5MDUwNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

举个例子

- mrc p15, 0, r0, c1, c0, 0
- orr r0, r0, #1
- mcr p15, 0, r0, c1, c0, 0
- 将cp15内c1寄存器读取到r0寄存器，再将r0的bit 0 或上1，c1的bit0置1的功能就是使能MMU或PU，再将修改好的内存写入cp15寄存器的c1内

***

### 2.14.6、ldm/stm 与栈的处理

#### 2.14.6.1、为什么需要多寄存器访问

- ldr/str 每个周期只能访问4字节内存，如果需要批量读取、写入内存时太慢了，解决方法就是ldm/stm
- ldm（load register mutiple）
- stm（store register mutiple）

举例用法

- stmia  sp，{r0-r12}
- 将r0存入sp指向的内存处（假设为0x30001000）；然后地址+4（即指向0x30001004），将r1存入存入改地址……直到r12内存存入指令完成
- 一个访问周期同时完成13个寄存器的读写

8种后缀

- ia		先传输后地址+4
- ib        先地址+4再传输
- da       先传输后地址-4
- db       先地址-4再传输
- fd        满递减堆栈   == db
- ed       空递减堆栈   == da
- fa        满递增堆栈   == ib
- ea       空递增堆栈   == ia

#### 2.14.6.2、！的作用

- ldmia r0，{r2-r3}
- 意思是将r0里面的内容读到r2里面，再将r0地址+4里面的内容读到r3里面（注意，地址加4是不会影响r0里面原来存放的数据的）
- ldmia r0！，{r2-r3}
- r0后面加了感叹号就是让r0在加地址的同时让r0跟着变，这会让r0的值跟着变

#### 2.14.6.3、^的作用

- ldmfd sp！，{r0-r6，pc}
- 将sp里面的地址的值满递减堆栈到r0-r6和pc中
- ldmfd sp！，{r0-r6，pc}^
- ^的作用是：在目标寄存器有pc时，会同时将SPSR写入到CPSR，一般用于从异常模式返回

#### 2.14.6.4、总结

- 批量读取或写入内存时要用ldm/stm指令
- 各种后缀以理解为主，不需要记忆，最常见的时stmia和stmfd
- 谨记：操作栈时使用相同的后缀就不会出错，不管时满栈还是空栈、增栈还是减栈

***

## 2.15、ARM伪指令集

### 2.15.1、伪指令的意义

- 伪指令都是以点开头的
- 伪指令不是指令，伪指令和指令的根本区别是经过编译后会不会生成机器码
- 伪指令的意义就在于指导编程过程
- 伪指令是和具体的编译器相关的，我们使用gnu工具链，因此学习gnu环境下的汇编伪指令

### 2.15.2、gnu汇编中的一些符号

- @用来做注释。可以在行首也可以在代码后面同一行直接跟，在C语言中和//类似
- #做注释，一般放在行首，表示这一行都是注释而不是代码	
- ：以冒号结尾的是标号，标号类似于C语言中的goto
- . 点好在gnu汇编中表示当前指令的地址
- #立即数前面要加#后者$，表示这是个立即数

C语言中的死循环：while（1）；

汇编中可以写成：

flag: b flag ：b是跳转，这句的意思就是跳转到当前程序

b .  ：这句也是跳转到当前地址

### 2.15.3、常用的伪指令

- .global  _ start          @给_start外部连接属性
- .section  .text          @指定当前段为代码段
- .ascii .byte .short .long .word .quad .float .string         @定义数据
- .align  4   (4表示 2^4^ )      @以16字节对齐
- .balignl 16 0xabcdefgh          @以16字节对齐填充
- .equ              @类型C中的宏定义

```s
IRQ_STACT_START:
	.word 0x0badc0de
//这两句就相当于 unsigned int IRQ_STACT_START = 0x0badc0de

.balignl 16 0xabcdefgh  
b表示位填充；align表示要对齐；l表示long，以4字节填充；16表示16字节对齐；0xabcdefgh  表示用来填充的原料
意思是假如我当前所在地址为0x00000008；当我这个地址存放这个指令后我不能再将下一条指令放在它的下一位0x0000000c处而是要放到16字节对齐的下一个地址处也就是0x00000010处，而我们跳过的那个地址0x0000000c地址就存放我们设置的填充原料0xabcdefgh，这要跳过的地址就那这个填充
```

### 2.15.4、偶尔会用到的伪指令

- .end					@表示汇编的结束一般加在程序最后不加也可以
- .include               @头文件包含
- .arm / .code32     
- .thumb / .code16  @声明下面的代码是arm/thumb 代码

### 2.15.5、最重要的几个伪指令

- ARM中有一个ldr指令，还有一个ldr伪指令（因为ldr指令需要考虑立即数的合法位数，而伪指令不需要考虑，一般都是使用伪指令）
- ldr            大范围的地址加载指令
- adr           小范围的地址加载指令
- adrl          中等范围的地址加载指令
- nop           空操作

```ass
ldr指令： ldr r0, #0xff
伪指令：  ldr r0, =0xfff1 @设计到合法/非法立即数，涉及到ARM文字池
```

### 2.15.6、adr与ldr

- adr编译时会被1条sub或者add指令替代，而ldr编译时会被一条mov指令替代或者文字吃方式处理
- adr总是以pc为基准来表示地址，因此指令本身和运行地址有关，可以用来检测程序当前的运行地址在哪里
- ldr加载的地址和连接时给定的地址有关，有连接脚本决定
- adr和ldr的区别：ldr加载的地址在链接时确定，而adr加载的地址在运行时确定，所以我们可以通过adr和ldr加载的地址比较判断当前程序是否在链接时指定的地址运行。

****

# 3、开发板、原理图和数据手册

## 3.1、开发板刷系统

### 3.1.1、什么是刷系统

​	刷系统就是利用刷机工具，向开发板中烧录预先编译好的系统镜像，使之在开发板上运行起来。

### 3.1.2、串口输出的意义（做系统控制台）

​	串口是一种硬件通信口，很多年前的时候串口是CPU之间进行通信的主要接口。但是现在因为串口通信的速度很低，所以现在串口主要是用来做程序输出监控、调试。
​	桌面电脑可以打开一个虚拟控制台，嵌入式系统一般是用串口来做控制台的。一般是用一根串口线连接开发板的串口和我们笔记本电脑的串口，然后在电脑上打开一个串口监视，这样开发板上的串口输出内容就可以在电脑上看到。还可以通过监视终端向开发板输入一些控制命令由开发板执行。常用的串口监视软件有：超级终端、SecureCRT、minicom

### 3.1.3、安装USB转串口线的驱动

​	本来电脑都是有串口的（DM9接口），但是现在大家都用笔记本没有串口了，所以这种串口连接线用不了。办法是使用USB转串口线，这种线传入电脑后需要安装驱动，安装驱动后在电脑上会形成一个串口（叫usb转串口），这样就相当于你电脑有了一个串口，可以通过这个串口来监视开发板的串口输出。
​	注意1：windows对USB设备的管理是和USB口有关的，你每次把usb转串口线插到1个口中，这样得到的COM口号码是不变的，方便我们后期使用。如果每次胡乱更换插口，可能得到的COM口会变。
​	注意2：COM口号码是可以改的，还可以强制占用显示“已使用”的COM号，一般改成COM4以内的就可以了。

### 3.1.4、使用SecureCRT

​	从网盘下载SecureCRT.rar，解压后直接使用。注册时参考解压包中的《说明.txt》。
​	打开SecureCRT.exe后，建立一个Serial连接，开始监视串口。设置参考视频中，注意流控一定要去掉。
​	开发板这边串口一定要接串口2（官方出厂默认的烧录镜像都是使用串口2的），然后开机，就可以看到串口信息了。

### 3.1.5、破坏iNand中的bootloader以从SD2启动

进入linux平台，执行以下命令：	

busybox dd if=/dev/zero of=/dev/mmcblk0 bs=512 seek=1 count=1 conv=sync

​	解释：这句话的意思就是说把板载的iNand的第一个扇区用全0来填充，其实就是擦除它，这样我们板载的iNand的bootloader的开始第1个扇区就被破坏了。将来启动时iROM还是会先从iNand中读取前16KB，然后计算校验和。这时候因为有1个扇区被擦掉了，所以校验和不通过，所以启动失败（会从SD2去执行2nd启动）。
​	注意：破坏板载iNand的bootloader后，不插外部SD卡，启动时串口得到：SD checksum Error

### 3.1.6、制作启动SD卡

​	有2种烧写方法：一种是在windows中用刷卡工具去制作启动SD卡；另一种是在linux中用dd命令。
​	本节介绍第一种（比较简单），刷卡工具在光盘：A盘\tools\x210_Fusing_Tool.rar
​	制作完SD后将SD卡插入开发板SD2通道（注意不是SD3），然后开机就可以进入uboot界面了。在uboot开机自动启动倒数3秒之内迅速按下电脑回车键，打断自动启动。（否则会自动启动iNand中的android）

### 3.1.7、fastboot介绍

​	fastboot是uboot中用来快速下载镜像的一个命令，fastboot同时还是一个windows上的软件。

​	fastboot下载时要注意1：fastboot是使用USB线进行数据传输的，所以fastboot执行之前要先连接开发板和主机之间的usb线。

​	fastboot下载时要注意2：需要安装驱动。

### 3.1.8、fastboot常用命令

​	fastboot devices		命令用来查看当前连接的设备。（我们开发板看到的是：																							SMDKC110-01）
​	fastboot flash xxx		命令用来烧录的
​	fastboot reboot			命令用来重启系统

### 3.1.9、使用fastboot烧录android4.0.4镜像

在cmd下使用以下三个命令来完成烧录
fastboot flash bootloader android4.0.4/uboot.bin		烧uboot，
fastboot flash kernel android4.0.4/zImage-android		烧linux kernel
fastboot flash system android4.0.4/x210.img			烧android rom

烧录完之后 cmd 中 输入fastboot reboot			命令用来重启系统

将需要烧录的东西放在fastboot软件的文件夹下面，路径写相对路径

uboot的参数设置：set bootcmd 'movi read kernel 30008000; bootm 30008000'（默认就是这个，不用设置也行）

### 3.1.10、烧录linux+QT

​	fastboot flash bootloader linuxqt/uboot.bin		烧uboot
​	fastboot flash kernel linuxqt/zImage-qt					烧linux kernel
​	fastboot flash system linuxqt/rootfs_qt4.ext3			烧rootfs
uboot的参数不用特意设置（因为我们刷了专为linux+QT定制的uboot，这个uboot中估计已经预制好了所有的启动参数）

### 3.1.11、烧录android2.3

​	fastboot flash bootloader android2.3/uboot.bin		烧uboot
​	fastboot flash kernel android2.3/zImage				烧linux kernel
​	fastboot flash system android2.3/x210.img			烧android rom
注意：android2.3中使用了串口0，所以启动后要把串口插到串口0中，不然串口没有任何启动信息出来。android2.3中屏幕上的logo是在左上角（也是个刷机成功的标志）

***

## 3.2、X210核心板、底板原理导读

​	写代码时需要查阅和参考的资料有：核心板原理图、底板原理图、相应硬件的数据手册、S5PV210数据手册

### 3.2.1、原理图、PCB图、丝印图各自是什么

​	原理图是电路原理设计图，各个电路中的部件的逻辑连接图。原理图可能会影响软件编写
​	PCB图是我们用来制作电路板，并且用电路板进行原件焊接，做成最终产品的生产性图纸。先有原理图设计，然后根据原理图来设计PCB图。PCB4图是对原理图的一种实现。原理图和PCB图一般都由硬件工程师来负责，但是原理图设计时软件工程师会一定程度参与。PCB图的设计就完全是硬件工程师的事情了，与软件工程师无任何关系。
​	丝印图是PCB图设计中，所有原件的外框的框图。丝印图其实就是整个电路板的实体的位置图纸，与软件和功能无关，与生产制造有关。对软件工程师来说，丝印图可以不理会。

### 3.2.2、原理图对嵌入式软件工程师的意义

​	原理图是电路的逻辑连接。对于可编程器件来说，不同的电路连接可能意味着不同的编程参数，因此底层软件工程师会需要查阅原理图的接法，从而决定自己的软件怎么写才能正确和硬件通信。

### 3.2.3、嵌入式软件开发人员对硬件掌握程度的要求

​	对软件工程师来说，硬件究竟有没有必要会？会到什么程度？影响有多大？
​	软件工程师分应用开发和底层开发两大块。对于应用开发工程师（直接基于操作系统来开发程序，调用操作系统的APi和库函数等写代码）来说，硬件完全被操作系统屏蔽了，可以完全不关心硬件；但是对于底层软件工程师（驱动开发的、单片机的、移植操作系统的）来说，看懂原理图和数据手册是非常有必要的，PCB图就没必要会了。
​	注意：一般来说，总工程师都是软硬都会的，这个人一般软件硬件都做过。所以对大家来说，如果时间很充裕，或者完全有条件，不妨都学习一点（学习是有轻重的）；如果时间比较紧，着急工作，或者完全不感兴趣，那就不要看了。
​	

## 3.3、S5PV210数据手册导读

### 3.3.1、datasheet（数据手册）的作用

​	数据手册就是产品（一般是芯片）厂家编写的，对这个产品的所有功能和用法的描述统一说明的文档。

数据手册的正确读法：先通读浏览，然后根据需要去查询

学会利用文档目录

利用好pdf阅读器的搜素功能

***

## 3.4、x210的dnw刷机

### 3.4.1、背景

​	1 之前讲第三部分的时候只讲了SD卡刷机，并没有讲usb启动刷机（dnw刷机）。因为sd卡刷机较简单，dnw刷机较麻烦。
​	2 有同学刷错了uboot，错刷成了nand版本的uboot（还有些确实没刷错uboot），这时候在uboot中执行了movi write u-boot 0x30000000后，再次开机碰到诡异现象：串口输出乱码、SD卡不启动。以为开发板变砖头了。这时候的解决思路就是dnw刷机。
​	3 第四部分（1.4.ARM裸机第四部分-GPIO和LED）的第一节课已经讲过了dnw下载裸机程序（dnw的介绍，dnw驱动的安装，配置下载地址的方法），大家可以先看这节课，然后再来看本节。

### 3.4.2、刷机准备

​	1 看x210 dnw刷机.txt，按照其中进行操作
​	2 事先把开发板启动方式拨到usb启动。OM5打到VCC就能从usb启动
​	3 两个刷机文件x210_usb.bin  和 uboot.bin 准备好。

### 3.4.3、刷机

​	刷机分2步：第一步刷x210_usb.bin，地址是0xd0020010;第二步刷uboot.bin，刷机地址是0x23e00000
​	uboot启动起来后，先fdisk -c 0去重新分区，然后再fastboot·······

****

## 3.5、在Linux下使用dd命令刷写uboot

### 3.5.1、SD卡连接Linux

​	首先得搞清楚：一个USB设备插到电脑后，要么可以在Windows中识别，此时不能在虚拟机linux中识别；要么能在linux中识别，但是在windows中又不见了。默认的一般都是连在Windows中的，所以linux是找不到的。
​	如果你需要将该设备连接到linux中，需要在VMware软件的菜单“虚拟机 -> 可移动设备”中点选该设备，选择连接

​	连接进linux中，在命令行中：ls /dev/sd*查看，和之前对比，就知道我们的SD卡在linux中的设备编号了。一般是/dev/sdb
​	也有可能是sdc或者其他。我们后面的实验是基于这个设备号是/dev/sdb的，如果不是，后面的实验要相应做修改。

### 3.5.2、制作SD卡启动

​	执行 ./nand_fusing.sh /dev/sdb

### 3.5.3、使用SD卡启动

​	先确定开发板是从SD卡启动的
​	然后确定板子内的iNand中的uboot是被破坏的，不能启动的。
​	SD卡插入SD2通道，启动即可。启动后（看有没必要fdisk -c 0来分区）使用fastboot继续刷机。

## 3.6、在Linux环境下使用dnw

### 3.6.1、开发板连接到Linux下

（1）开发板设置USB启动，开机，windows设备管理器中提示发现新硬件

（2）VMware菜单：虚拟机->可移动设备->Samsung S5PC110 SEC Test B/D，点击连接

（3）成功连接后现象：1、Windows下设备管理器没了；2、ls /dev/secbulk0 设备节点自动出现

### 3.6.2、使用dnw进行下载uboot.bin

（1）dnw -a 0xd0020010 x210_usb.bin 
（2）dnw -a 0x23e00000 uboot.bin
成功标志：SecureCRT中成功看到了uboot的启动信息，并且进入了uboot命令行。

### 3.6.3、uboot启动后的刷机注意事项

（1）正确的uboot启动后一定要先fdisk -c 0进行分区，然后再fastboot
（2）uboot的参数中bootcmd和bootargs一定要正确。
set bootcmd 'movi read kernel 30008000; bootm 30008000'
set bootargs console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3

****

# 4、GPIO和LED

## 4.1、usb启动配合dnw工具下载

### 4.1.1、背景知识介绍

回顾S5PV210的启动方式，必须将OM5打到VCC，才能从USB启动。
	S5PV210的启动过程：开机时先执行内部的iROM中的BL0，然后BL0做了一系列的初始化后，再读取外部OMpin的设置来确定用户选择了从哪里启动。当检测到我们设置的是USB启动时，S5PV210就会从USB OTG接口试图连接主机进行下载启动。

### 4.1.2、dnw工具介绍

​	dnw是一个软件，是三星公司编写的，这个软件的功能是通过USB线连接开发板和电脑主机，然后从主机下载文件镜像到开发板中去烧录系统。
​	dnw软件使用注意1：dnw是需要装usb驱动的，驱动在“X210光盘资料\A盘\tools\USB驱动”目录中
​	dnw软件使用注意2：dnw使用时通过usb线下载，所以一定要插USB线。
​	dnw软件使用注意3：dnw下载时需要设置dnw下载内存地址。在dnw软件的菜单“Configuration”中设置
​						Download Address为0xd0020010，确认即可。

### 4.1.3、dnw驱动安装

​	X210开发板使用了软开关，但是我们这里还没到操作系统没去处理开关，所以在整个裸机实验中必须手工按下POWER键才能保持开机，只要手一抬起来就关机了····
​	dnw驱动装好的标志是：开发板开机从usb启动后，设备管理器中显示已经安装的设备，并且关键是dnw工具中USB:OK

### 4.1.4、裸机程序下载地址设置

​	从usb启动做裸机实验时，因为不需要16字节的校验头，所以直接下载到0xd0020010

### 4.1.5、usb启动裸机实验总结

​	usb启动方式主要是用来调试程序的，其实分析S5PV210即可知道，我们这里是把裸机程序当作BL1来使用了。

***

## 4.2、SD卡下载

### 4.2.1、背景知识

​	一般情况下，用USB下载来调试裸机程序比较方便；但是有时候电脑使用dnw会频繁蓝屏，这时候用SD卡下载调试是不错选择。
​	把OM5打开GND，以从SD通道启动。
​	从SD启动时会先从iNand（SD0）启动执行，当iNand启动做校验和时失败才会转为启动SD2。而我们做裸机实验时是通过SD2来提供裸机程序镜像的，因此需要先破坏内部iNand的uboot才可以强迫开发板从SD2启动去执行我们的裸机程序。

### 4.2.2、擦除开发板iNand中的uboot的方法

​	在linux和android系统下，擦除uboot的方法：
​	busybox dd if=/dev/zero of=/dev/block/mmcblk0 bs=512 seek=1 count=1 conv=sync
​	sync
​	在uboot底下如何擦除uboot：movi write u-boot 0x30000000，

### 4.2.3、Windows环境下制作启动SD卡

方法和之前SD卡刷机很像唯一的区别就是这次烧在SD卡内的是我们自己写的裸机程序

==总结==

​	SD卡启动和usb启动优劣势对比：如果你的电脑本身支持usb启动下载而且不蓝屏，建议以后做实验用usb下载调试；

***

## 4.3、安装交叉编译工具链

### 4.3.1、Windows中装软件的特点

​	Windows中装软件使用安装包，安装包解压后有2种情况：一种是一个安装文件（.exe .msi），双击进行安装，下一步直到安装完毕。安装完毕后会在桌面上生成快捷方式，我们平时使用快捷方式来启动这些程序；另一种是所谓的绿色软件、免安装软件。这种不用安装，直接解压开里面就有exe可以直接双击执行。

### 4.3.2、Linux中安装软件的特点

​	linux中安装软件比windows中复杂。linux中安装软件一般有以下几种方法：
​	第一种：在线安装。譬如ubuntu中使用apt-get install vim来安装vim软件。
​	第二种：自己下载安装包来安装。这种方式的缺陷就是你不知道你下载的安装包和你的系统是否匹配。
​	第三种：最装逼的一种方式，就是源代码安装。
​	总结：我们安装交叉编译工具链（arm-linux-gcc）实际采用第二种安装方式。

### 4.3.3、交叉编译工具链的选择

​	我们选择交叉编译工具链的原则：和我们所使用的目标平台（给哪款SoC编程）尽量去匹配。譬如我们开发S5PV210的程序就是用arm-2009q3这个版本，因为三星官方在开发S5pv210时就使用这个版本的交叉编译工具链，这样可以最大限度的避免稀奇古怪的问题出现。

### 4.3.4、交叉编译工具链的安装

​	步骤1：打开虚拟机，在/usr/local/下创建/usr/local/arm文件夹
​	步骤2：先将安装包从Windows中弄到linux中去。可以用共享文件夹，也可以用Samba，也可以cuteftp。
​	步骤3：解压。tar -jxvf arm-2009q3.tar.bz2
​	到此相当于程序已经安装完毕，真正的应用程序安装在/usr/local/arm/arm-2009q3/bin目录下

​	注：linux中的目录管理方法。技术角度来讲，linux中所有目录性质都是一样的，所以技术角度来讲我们把软件安装到哪里都行。但是因为如果胡乱放置，将来程序可能不好找。所以久而久之大家就总结了一个文件放置的一般定义，譬如说/bin目录放置一些系统自带的用户使用的应用程序，/sbin目录下存放的是系统自带的系统管理方面的应用程序。
那我们装软件放在哪里？一般都在/usr目录下。我们安装arm-linux-gcc，就在/usr/local/底下创建一个arm文件夹，然后装到里面。	

### 4.3.5、安装后的测试

​	到真正的应用程序的安装目录下（也就是/usr/local/arm/arm-2009q3/bin），去执行arm-linux-gcc -v
​	执行方法是：./arm-none-linux-gnueabi-gcc -v
​	执行后可以得到一长串输出，其中有“gcc version 4.4.1 ”字样，即表示安装成功。

###  4.3.6、环境变量的意义

​	环境变量就是操作系统的全局变量。每一个环境变量对操作系统来说都是唯一的，名字和所代表的意义都是唯一的。linux系统可以有很多个环境变量。其中有一部分是linux系统自带的，还有一些是我们自己来扩充的。我们这里涉及到的一个环境变量是
​	PATH。PATH这个环境变量是系统自带的，它的含义就是系统在查找可执行程序时会搜索的路径范围。

### 4.3.7、将工具链导出到环境变量

​	export PATH=/usr/local/arm/arm-2009q3/bin:$PATH
​	在一个终端中执行以上命令后，该终端中就可以直接使用arm-linux-gcc了，但是只要关掉这个终端再另外打开一个立马就不行了。原因是我们本次终端中执行时的操作只是针对本终端，以后再打开的终端并未被执行过这个命令所以没导出。
​	解决方案是在~/.bashrc中，添加export PATH=/usr/local/arm/arm-2009q3/bin:$PATH 即可。

注意：我们导出这个环境变量是在当前用户，如果你登录时在其他用户下是没用的。

### 4.3.8、为工具链创建arm-linux-xxx符号链接

​	ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2line

***

## 4.4、Makefile

### 4.4.1、为什么需要Makefile

​	Makefile是用来管理工程的。
​	在一个正式的软件项目中，由很多个.c和.h文件构成，此时如果直接在命令行编译，就会像这样：gcc a.c b.c c.c d.c e.c f.c g.c -o exe		每次编译都要输入一堆东西很麻烦，这个问题严重影响工作效率，怎么办？Makefile来解决

### 4.4.2、实例

```makefile
#不是特别标准的makefile
all:
	gcc a.c b.c -o exe
	./exe
#近格不能用空格只能用tab键
```

### 4.4.3、Makefile基本概念

​	目标：目标定格写，后面是冒号（冒号后面是依赖）
​	依赖：依赖是用来产生目标的原材料。
​	命令：命令前面一定是Tab，不能是定格，也不能说多个空格。命令就是要生成那个目标需要做的动作。

```makefile
#标准写法
a.o:a.c
	gcc a.c -o a.o -c
b.o:b.c
	gcc b.c -o b.o -c
exe:a.o b.o
	gcc a.o b.o -o exe
clean:
	rm exe
#想让他执行什么就make什么目标，列如make a.o 就会执行gcc a.c -o a.o这条命令
```

### 4.4.4、Makefile的工作原理

​	其一，当我们执行 make xx 的时候，Makefile会自动执行xx这个目标下面的命令语句。
​	其二，当我们make xx的时候，是否执行命令是取决于依赖的。依赖如果成立就会执行命令，否则不执行。
​	其三，我们直接执行make 和make 第一个目标  效果是一样的。（第一个目标其实就是默认目标）

### 4.4.5、自己学习Makefile

​	我们学习Makefile的思路就是：先学会基本的概念和应用，先理解Makefile的概念和使用方法、工作原理。先自己会写简单的Makefile来管理工程。一般先学到这里就可以了，更深入的内容可以随同稍后的课程一起来学习，我们讲到课程的时候会再次提及并且逐步深入。
​	对于我们有一定基础的同学，同时还有时间，可以深入学习Makefile，看《跟我一起学Makefile》（作者：陈皓）

****

## 4.5、mkv210_image.c文件详解

### 4.5.1、mkv210_image.c的使用演示

```makefile
#分析led里面的makefile
led.bin: start.o 
	arm-linux-ld -Ttext 0x0 -o led.elf $^
	arm-linux-objcopy -O binary led.elf led.bin
	arm-linux-objdump -D led.elf > led_elf.dis
	gcc mkv210_image.c -o mkx210
	./mkx210 led.bin 210.bin
	
%.o : %.S
	arm-linux-gcc -o $@ $< -c

%.o : %.c
	arm-linux-gcc -o $@ $< -c 

clean:
	rm *.o *.elf *.bin *.dis mkx210 -f
```



​	裸机程序中的Makefile（实际上真正的项目的Makefile都是这样的）是把程序的编译和链接过程分开的。（平时我们用gcc a.c -o exe这种方式来编译时，实际上把编译和链接过程一步完成了。在内部实际上编译和链接永远是分开独立进行的，编译要使用编译器gcc，链接要使用链接器ld）

​	链接器得到led.elf其实就是我们的可执行程序，（如果是在操作系统下，这个led.elf就可以执行了）但是在嵌入式裸机中我们需要的是可以烧写的文件（可烧写的文件就叫镜像image），因此我们需要用这个led.elf为原材料来制作镜像，制作工具是交叉编译工具链中的arm-linux-objcopy

​	我们使用arm-linux-objdump工具进行反编译（反汇编），反汇编其实就是把编译后的elf格式的可执行程序给反过来的到对应的汇编程序，的到它的汇编源代码。我们使用反汇编主要是用来学习，见本部分最后一节。

​	mkv210_image.c这个程序其实最终不是在开发板上执行的，而是在主机linux（就是用来执行make对整个项目进行编译的那个机器）中执行的，因此编译这个程序用gcc而不是用arm-linux-gcc。这个.c文件编译后得到一个可执行程序mkmini210，目的是通过执行这个mkmini210程序而由led.bin得到210.bin。（210.bin是通过SD卡启动时的裸机镜像，这个镜像需要由led.bin来加工的到，加工的具体方法和原理要看mkv210_image.c）

### 4.5.2、x210启动回顾

​	分析启动过程可知；210启动后先执行内部iROM中的BL0，BL0执行完后会根据OMpin的配置选择一个外部设备来启动（有很多，我们实际使用的有2个：usb启动和SD卡启动）。在usb启动时内部BL0读取到BL1后不做校验，直接从BL1的实质内部0xd0020010开始执行，因此usb启动的景象led.bin不需要头信息，因此我们从usb启动时直接将镜像下载到0xd0020010去执行即可，不管头信息了；从SD启动时，BL0会首先读取sd卡得到完整的镜像（完整指的是led.bin和16字节的头），然后BL0会自己根据你的实际镜像（指led.bin）来计算一个校验和checksum，然后和你完整镜像的头部中的checksum来比对。如果对应则执行BL1，如果不对应则启动失败（会转入执行2st启动，即SD2启动。如果这里已经是2st启动了，这里校验通不过就死定了）。

​	所以：SD卡内的镜像和USB启动的led.bin区别就在于是否有校验头而mkv210_image.c这个程序的作用就是给led.bin添加校验头

### 4.5.3、mkv210_image.c的作用：为BL1添加校验头

​	我们编译链接时只得到了led.bin，这个210.bin的得到和交叉编译工具链是完全无关的。由led.bin得到210.bin的过程是三星的S5PV210所特有的，因此需要我们自己去完成，为此我们写了mkv210_image.c来完成。

### 4.5.4、整个程序工作流分析

​	整个程序中首先申请一个16KB大小的buffer，然后把所有内容按照各自的位置填充进去，最终把填充好的buffer写入到一个文件（名叫210.bin）就形成了我们想要的镜像。

### 4.5.5、代码详解

```c
/*
 * mkv210_image.c的主要作用就是由usb启动时使用的led.bin制作得到由sd卡启动的镜像210.bin
 *
 * 
 */
/* 在BL0阶段，Irom内固化的代码读取nandflash或SD卡前16K的内容，
 * 并比对前16字节中的校验和是否正确，正确则继续，错误则停止。
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#define BUFSIZE                 (16*1024)
#define IMG_SIZE                (16*1024)
#define SPL_HEADER_SIZE         16
//#define SPL_HEADER              "S5PC110 HEADER  "双引号里面是什么都可以只要是16字节
#define SPL_HEADER              "****************"

int main (int argc, char *argv[])
{
	FILE		*fp;
	char		*Buf, *a;
	int		BufLen;
	int		nbytes, fileLen;
	unsigned int	checksum, count;
	int		i;
	
	// 1. 3个参数
	if (argc != 3)
	{
		printf("Usage: %s <source file> <destination file>\n", argv[0]);
		return -1;
	}

	// 2. 分配16K的buffer
	BufLen = BUFSIZE;
	Buf = (char *)malloc(BufLen);
	if (!Buf)
	{
		printf("Alloc buffer failed!\n");
		return -1;
	}

	memset(Buf, 0x00, BufLen);

	// 3. 读源bin到buffer
	// 3.1 打开源bin
	fp = fopen(argv[1], "rb");
	if( fp == NULL)
	{
		printf("source file open error\n");
		free(Buf);
		return -1;
	}
	// 3.2 获取源bin长度
	fseek(fp, 0L, SEEK_END);			// 定位到文件尾
	fileLen = ftell(fp);				// 得到文件长度
	fseek(fp, 0L, SEEK_SET);			// 再次定位到文件头
	// 3.3 源bin长度不得超过16K-16byte
	count = (fileLen < (IMG_SIZE - SPL_HEADER_SIZE))
		? fileLen : (IMG_SIZE - SPL_HEADER_SIZE);
	// 3.4 buffer[0~15]存放"S5PC110 HEADER  "
	memcpy(&Buf[0], SPL_HEADER, SPL_HEADER_SIZE);
	// 3.5 读源bin到buffer[16]
	nbytes = fread(Buf + SPL_HEADER_SIZE, 1, count, fp);
	if ( nbytes != count )
	{
		printf("source file read error\n");
		free(Buf);
		fclose(fp);
		return -1;
	}
	fclose(fp);

	// 4. 计算校验和
 	// 4.1 从第16byte开始统计buffer中共有几个1
	// 4.1 从第16byte开始计算，把buffer中所有的字节数据加和起来得到的结果
	a = Buf + SPL_HEADER_SIZE;
	for(i = 0, checksum = 0; i < IMG_SIZE - SPL_HEADER_SIZE; i++)
		checksum += (0x000000FF) & *a++;
	// 4.2 将校验和保存在buffer[8~15]
	a = Buf + 8;							
    // Buf是210.bin的起始地址，+8表示向后位移2个字，也就是说写入到第3个字
	*(unsigned int *)a = checksum;

	// 5. 拷贝buffer中的内容到目的bin
	// 5.1 打开目的bin
	fp = fopen(argv[2], "wb");
	if (fp == NULL)
	{
		printf("destination file open error\n");
		free(Buf);
		return -1;
	}
	// 5.2 将16k的buffer拷贝到目的bin中
	a = Buf;
	nbytes	= fwrite( a, 1, BufLen, fp);
	if nbytes != BufLen )
	{
		printf("destination file write error\n");
		free(Buf);
		fclose(fp);
		return -1;
	}

	free(Buf);
	fclose(fp);

	return 0;
}
```

​	第1步：检验用户传参是不是3个。
​	第2步：分配16K Bbuffer并且填充为0.
​	第3步：代码备注已经很详细了

### 4.5.6、main函数两个形参的作用

​	main函数接收2个形参：argc和argv。
​	argc是用户（通过命令行来）执行这个程序时，实际传递的参数个数。注意这个个数是包含程序执行本身的
​	argv是一个字符串数组，这个数组中存储的字符串就是一个个的传参。
​	譬如我们执行程序时使用./mkx210 led.bin 210.bin
​	则argc = 3
​	则argv[0] = "./mkx210"  argv[1] = led.bin  argv[2] = 210.bin

### 4.5.7、glibc读写文件接口

​	linux中要读取一个文件，可以使用fopen打开文件，fread读取文件，读完之后fclose关闭文件。
​	要写文件用fwrite来写。这些函数是glibc的库函数，在linux中用man 3 可以查找。
​	如果你本身就知道这些函数的用法，只是记不起来可以man查找；如果你本身根本就不会用这些接口，建议先去baidu。

### 4.5.8、校验和的计算方法

​	算法：校验和其实就是需要校验的内存区域中，所有内存中的内容按照字节为单位来进行相加，最终相加的和即为校验和。
​	实现时大家要注意指针的类型为char *

***

## 4.6、点亮LED——硬件工作原理及原理图查阅

### 4.6.1、LED物理特性介绍

​	LED本身有2个接线点，一个是LED的正极，一个是LED的负极。LED这个硬件的功能就是点亮或者不亮，物理上想要点亮一颗LED只需要给他的正负极上加正电压即可，要熄灭一颗LED只需要去掉电压即可。

### 4.6.2、查阅原理图了解板载LED硬件接法

​	查阅原理图，发现开发板上一共有5颗LED。其中一颗D26的接法是：正极接5V，负极接地。因此这颗LED只要上电就会常亮。因此我们分析这颗LED是电源指示灯。
​	剩下4颗LED的接法是：正极接3.3V，负极接了SoC上的一个引脚（GPIO），具体详细接法是：
​	D22：GPJ0_3
​	D23：GPJ0_4
​	D24：GPJ0_5
​	D25：PWMTOUT1(GPD0_1)	

### 4.6.3、分析如何点亮及熄灭LED（GPIO）

​	分析：LED点亮的要求是：正极和负极之间有正向电压差。
​	思考：在开发板上如何为LED制造这个电压差让它点亮呢？
​	解答：因为正极已经定了（3.3V），而负极接在了SoC的引脚上，可以通过SoC中编程来控制负极的电压值，因此我们可以通过程序控制负极输出低电平（0V），这样在正负极上就有了压差，LED即可点亮。

***

## 4.7、点亮LED——数据手册查阅及相关寄存器浏览

### 4.7.1、GPIO的概念

​	GPIO:general purpose input output 通用输入输出
​	GPIO就是芯片的引脚（芯片上的引脚有些不是GPIO，只有一部分是），作为GPIO的这类引脚，他的功能和特点是可以被编程控制它的工作模式，也可以编程控制他的电压高低等。
​	通过之前的分析我们知道，我们设计电路时就把LED接在了一个GPIO上，这样我们就可以通过编程控制GPIO的模式和输入输出值来操控LED亮还是灭；如果你当时设计电路时把LED接在非GPIO上那就不可能了。

### 4.7.2、阅读数据手册中有关部分

​	当我们想要通过编程操控GPIO来操作LED时，我们首先需要通读一下S5PV210的数据手册中有关于GPIO的部分，这部分在数据手册的Section2.2中。

### 4.7.3、GPIO相关的寄存器介绍

​	回忆下之前说过的，软件操作硬件的接口是：寄存器。
​	我们当前要操作的硬件是LED，但是LED实际是通过GPIO来间接控制的，所以当前我们实际要操作的设备其实是SoC的GPIO。要操作这些GPIO，必须通过设置他们的寄存器。

​	查阅数据手册可知，GPJ0相关的寄存器有以下：

​	GPJ0CON, （GPJ0 control）GPJ0控制寄存器，用来配置各引脚的工作模式	
​	GPJ0DAT, （GPJ0 data）当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应。
​	GPJ0PUD, （pull up down）控制引脚内部弱上拉、下拉
​	GPJ0DRV, （driver）配置GPIO引脚的驱动能力
​	GPJ0CONPDN，（记得是低功耗模式下的控制寄存器）
​	GPJ0PUDPDN  （记得是低功耗模式下的上下拉寄存器）
​	注：在驱动LED点亮时，应该将GPIO配置为output模式。

实际上真正操控LED的硬件，主要的有：GPJ0CON, GPJ0DAT 这么2个。
	如何点亮LED，编程的步骤是：
	1、操控GPJ0CON寄存器中，选中output模式
	2、操控GPJ0DAT寄存器，相应的位设置为0

****

## 4.8、点亮LED、手写汇编点亮LED

### 4.8.1、GPxCON、GPxDAT寄存器分析

​	GPJ0端口一共有8个引脚，分别记住：GPJ0_0 ～ GPJ0_7，相关重要寄存器就是GPJ0CON和GPJ0DAT
​	GPJ0CON寄存器中设置8个引脚的工作模式（32/8=4，每个引脚可以分到4位，譬如GPJ0_0对应的bit位为bit0~ bit3，GPJ0_3对应的位为bit12~bit15。工作方法是：给相应的寄存器位写入相应的值，该引脚硬件就会按照相应的模式去工作。譬如给bit12～bit15写入0b0001，GPJ0_3引脚就成为输出模式了）

### 4.8.2、开始写代码

需要哪些先决条件才能写呢？
	1. 硬件接法和引脚：GPJ0_3 GPJ0_4 GPJ0_5	低电平亮/高电平灭
	2. GPJ0CON（0xE0200240）寄存器和GPJ0DAT（0xE0200244）寄存器
	3. 工程管理：Makefile等
	根据以上分析，我们就知道代码的写法了，代码所要完成的动作就是：
	把相应的配置数据写入相应的寄存器即可。

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-15 15:47:50
 * @FilePath     : \ubuntu share\leds_s\led.S
 * @Description  : 用汇编点亮LED
 */

_start:
    //第一步：把0x11111111写入0xE0200240（GPJ0CON）在内存中的位置

    ldr r0, =0x11111111             //这里使用“=” 所以ldr是伪指令，因为指令需要编译器来判断这个数是否合法，伪指令不需要
    ldr r1, =0xE0200240
    str r0, [r1]                    //寄存器间接寻址，将r0里的数写入到以r1里面的数为地址的内存中去

    //第二步：把0x0写入0xE0200244（GPJ0DAT）的内存地址

    ldr r0, =0x0
    ldr r1, =0xE0200244
    str r0, [r1]                    //将0写入GPJ0DAT寄存器中，引脚输出及低电平，LED点亮

flag:
    b flag     // b 跳转指令跳到有flag标号的地方去运行 类似于while死循环
        //因为裸机程序是直接在CPU上运行的，CPU会逐行运行程序直到CPU断电关机
//如果我们的程序所有代码都执行完了之后CPU就会跑飞（跑飞是未定义的，不能让CPU跑飞） //所以需要加死循环
```

### 4.8.3、编译、下载、运行看结果

​	编译时用我们的工程管理，直接make编译得到led.bin和210.bin
​	下载运行可以用usb启动dnw下载；也可以用sd卡烧录下载，根据自己的情况用
​	一般都用usb下载，因为方便。如果电脑主板插上dnw会死机没法解决，那只有sd卡下载启动了。
​	注意：开发板上按下电源键之后4颗LED默认都是半亮的，当我们下载程序后其中3颗变的很亮，这说明我们的程序已经运行了。

### 4.8.4、总结

​	软件到底是怎么控制硬件的？为什么程序一运行硬件就能跟着动？
​	软件编程控制硬件的接口就是：寄存器

***

## 4.9、点亮LED—使用位运算实现复杂要求

上节回顾：代码写的更漂亮一些

​	1、用宏定义来定义寄存器名字，再来操作。

​	2、用 b . 来实现死循环

​	3、用.global把_start链接属性改为外部，消除链接时的警告

### 4.9.1、问题提出：如何熄灭中间1颗LED

分析：程序其实就是写了GPJ0CON和GPJ0DAT这2个寄存器而已，功能更改也要从这里下手。
	GPJ0CON寄存器不需要修改，GPJ0DAT中设置相应的输出值即可。

### 4.9.2、直接解法（不使用位运算）和它的弊端

​	GPJ0DAT = 0x28

 这样写可以完成任务。

```assembly
.global _start           //不加这个编译时会报警告说找不到start
                         //意义就是把_start连接属性改为外部，这样其他文件						//就可以看到
_start:
    //第一步：把0x11111111写入0xE0200240（GPJ0CON）在内存中的位置

    ldr r0, =0x11111111   
    ldr r1, =GPJ0CON
    str r0, [r1]                 

    //第二步：把中间那颗LED（GPJ0_4）的输出设置为1，其他不变

    ldr r0, =0x10  		//这里的寄存器只有8位二进制00010000转化位16进制就						 //是0x10
    ldr r1, =GPJ0DAT
    str r0, [r1]      //将0写入GPJ0DAT寄存器中，引脚输出及低电平，LED点亮


    b .                 //. 代表当前程序段 比较简洁的死循环
```

这样写有缺陷。缺陷就是需要人为的去计算这个特定的设置值，而且看代码的也不容易看懂。
解决方案：在写代码时用位运算去让编译器帮我们计算这个特定值。

### 4.9.3、常用位运算：与、或、非、移位

位与(&)  位或(|)  位非（取反 ~） 移位（左移<< 右移>>）

### 4.9.4、使用位运算实现功能

​	1<<3  等于 0b1000
​	1<<5  等于 0b100000
​	(1<<3)|(1<<5)  等于 0b101000

### 4.9.5、用位运算实现只点亮中间1颗（两边是熄灭的）LED

```assembly
	ldr r0, =((1<<5) | (0<<4) | (1<<3))     //通过位运算实现中间亮两边暗
    ldr r1, =GPJ0DAT
    str r0, [r1]    
```

****

## 4.10、点亮LED—用汇编编写延时函数实现闪烁效果

### 4.10.1、闪烁效果原理分析

​	闪烁 = 亮 + 延时 + 灭 + 延时 + 亮 + 延时 ······

### 4.10.2、延时函数原理

​	在汇编中实现延时的方法：用一些没有目的的代码来执行消耗时间，达到延时的效果。

### 4.10.3、汇编编写延时函数

​	汇编编写延时函数的原理，用一个寄存器存放一个数字，然后在循环中每个循环里给数字减1，然后再判断这个数字的值是否为0.如果为0则停止循环，如果不为0则继续循环。

### 4.10.4、汇编编写及调用函数的方式

​	汇编中整个汇编的主程序是一个死循环，这个死循环是我们汇编程序的主体，类似于C中的main函数。其他函数必须写在这个主死循环程序的后面（死循环外），不然会出错。
​	汇编编写delay延时函数时，要注意函数的初始化和函数体的位置，不能把初始化写在了循环体内。
​	汇编中调用函数用bl指令，子函数中最后用mov pc, lr来返回。

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-15 19:56:28
 * @FilePath     : \ubuntu share\led\led3\led.S
 * @Description  : 用汇编LED闪烁
 */

#define GPJ0CON 0xE0200240
#define GPJ0DAT 0xE0200244

.global _start       //不加这个编译时会报警告说找不到start
                 //意义就是把_start连接属性改为外部，这样其他文件就可以看到
_start:
    //第一步：把0x11111111写入0xE0200240（GPJ0CON）在内存中的位置

    ldr r0, =0x11111111   //这里使用“=” 所以ldr是伪指令，因为指令需要编译							//器来判断这个数是否合法，伪指令不需要
    ldr r1, =GPJ0CON
    str r0, [r1]                    //寄存器间接寻址，将r0里的数写入到以								//r1里面的数为地址的内存中去

flash:    

    //全部点亮
    ldr r0, =0x0                       
    ldr r1, =GPJ0DAT
    str r0, [r1]      //将0写入GPJ0DAT寄存器中，引脚输出及低电平，LED点亮

    //延时
    bl delay        //使用bl进行函数调用，调用同时将当前位置保存到 lr 内

    //全部熄灭
    ldr r0, =((1<<5) | (1<<4) | (1<<3))                        
    ldr r1, =GPJ0DAT
    str r0, [r1]      //将0写入GPJ0DAT寄存器中，引脚输出及低电平，LED点亮

    bl delay   


    b flash                  // 代表当前程序段 比较简洁的死循环

//延时函数，函数名：delay
delay:
    
    ldr r2, =9000000
    ldr r3, =0x0

delay_pool:
    sub r2, r2, #1                  //将 r2-1 的数放到 r2内
    cmp r2, r3                      //比较 r2,r3 两个数是否相等，相等就将影响Z标志位，下一句eq就会成立
    bne delay_pool                  //bne 如果不相等就跳转到delay_pool
    mov pc, lr                      //函数调用返回，将 lr 内的地址给 pc 返回之前的位置
```

****

## 4.11、点亮LED—用汇编写流水灯

### 4.11.1、流水灯原理分析

​	流水灯又叫跑马灯，实现的效果就是：挨着的LED一次点亮熄灭（同时只有1颗LED亮的）

### 4.11.2、流水灯编写（使用循环）

​	LED1亮延时 + LED2亮延时 + LED3亮延时 + 循环

### 4.11.3、复杂点的实现

​	用位取反操作符来轻松愉快的实现单颗LED点亮流水效果

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-15 20:23:42
 * @FilePath     : \ubuntu share\led\led4\led.S
 * @Description  : 用汇编LED流水灯
 */

#define GPJ0CON 0xE0200240
#define GPJ0DAT 0xE0200244

.global _start                 
_start:
   

    ldr r0, =0x11111111             
    ldr r1, =GPJ0CON
    str r0, [r1]                   

flash:    

    //点亮1号
    ldr r0, =(~(1<<5))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]                    

    //延时
    bl delay                        

    //点亮2号
    ldr r0, =(~(1<<4))                        
    ldr r1, =GPJ0DAT
    str r0, [r1]                   

    bl delay   
    
    //点亮3号
    ldr r0, =(~(1<<3))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]     

    bl delay

    //点亮2号
    ldr r0, =(~(1<<4))                        
    ldr r1, =GPJ0DAT
    str r0, [r1]    

    bl delay


    b flash                             // 代表当前程序段 比较简洁的死循环

//延时函数，函数名：delay
delay:
    
    ldr r2, =9000000
    ldr r3, =0x0

delay_pool:
    sub r2, r2, #1               //将 r2-1 的数放到 r2内
    cmp r2, r3           //比较 r2,r3 两个数是否相等，相等就将影响Z标志						//位，下一句eq就会成立
    bne delay_pool        //bne 如果不相等就跳转到delay_pool
    mov pc, lr          //函数调用返回，将 lr 内的地址给 pc 返回之前的位置
```

### 4.11.4、总结

​	编程操控一个硬件的步骤：1 分析硬件工作原理 2 分析原理图 3 分析数据手册 4 找到相关的SFR （特殊功能寄存器）5 写代码设置寄存器得到想要的效果

****

## 4.12、反汇编工具objdump的使用简介

### 4.12.1、反汇编的原理&为什么要反汇编

​	arm-linux-objdump -D led.elf > led_elf.dis
​	objdump是gcc工具链中的反汇编工具，作用是由编译链接好的elf格式的可执行程序反过来得到汇编源代码
​	-D表示反汇编	> 左边的是elf的可执行程序（反汇编时的原材料），>右边的是反汇编生成的反汇编程序

反汇编的原因有以下：
		1.逆向破解。
		2.调试程序时，反汇编代码可以帮助我们理解程序（我们学习时使用objdump主要目的是这个），尤其是在理解链接脚本、链接地址等概念时。
		3. 把C语言源代码编译链接生成的可执行程序反汇编后得到对应的汇编代码，可以帮助我们理解C语言和汇编语言之间的对应关系。非常有助于深入理解C语言。

### 4.12.2、反汇编文件的格式和看法

​	（汇编 assembly   反汇编 dissembly）
​	标号地址、标号名字、指令地址、指令机器码、指令机器码反汇编到的指令
​	扩展：ARM汇编中用地址池方式来实现非法立即数

### 4.12.3、初识指令地址

​	下载烧录执行的bin文件，内部其实是一条一条的指令机器码。这些指令每一条都有一个指令地址，这个地址是连接的时候ld给指定的（ld根据我们写的链接脚本来指定）

### 4.12.4、展望：反汇编工具帮助我们分析链接脚本

​	反汇编的时候得到的指令地址是链接器考虑了链接脚本之后得到的地址，而我们写代码时通过指定连接脚本来让链接器给我们链接合适的地址。
​	但是有时候我们写的链接脚本有误（或者我们不知道这个链接脚本会怎么样），这时候可以通过看反汇编文件来分析这个链接脚本的效果，看是不是我们想要的，如果不是可以改了再看。

***

# 5、SDRAM和重定位relocate

## 5.1、汇编编写之关看门狗

### 5.1.1、什么是看门狗

​	看门狗（watch dog timer 看门狗定时器）。大家想象这样一个场景：家门口有一只狗，这个狗定时会饿（譬如说2小时一饿），狗饿了会胡乱咬死人。人进进出出要想保证安全必须提前喂狗（必须在上次喂过后的2小时内喂狗才行）。如果超时没喂狗就会被咬死，如果提前喂狗没关系，但是本次喂狗时间就会从这里开始计算。

​	现实中因为一些外部因素，电子设备经常会跑飞或者死机（譬如极端炎热、极端寒冷、工业复杂场合）。在这种情况下我们希望设备自动复位而不需要人工干预（无人值守）。看门狗用来完成这个工作。看门狗其实是我们SoC内部的一个定时器（类似于闹钟，类似于门口的狗），定好时间之后看门狗定时器会去计时，时间到之前（狗饿了之前）必须去重新置位看门狗定时器（喂狗），如果没有喂狗则系统会被强制复位。

​	系统在正常工作时，系统软件会自己去喂狗，所以看门狗定时器不会复位。但是系统一旦故障跑飞啥的，看门狗就没人喂了，然后下一个周期就会自动复位，达到我们期望的效果。

### 5.1.2、分析硬件物理特性、原理图、数据手册

​	物理特性上看门狗其实是个定时器（跟现实中的闹钟类似），硬件上就是SoC内部的一个内部外设。
​	原理图：看门狗不用分析原理图，因为看门狗属于内部外设，且没有外部相关的原件与他有关，所以不需要原理图分析，原理图上根本找不到和看门狗有关的地方。
​	数据手册：在数据手册的Section7.3，大家可以详细来看。如果直接看不懂数据手册，可以百度看门狗，然后看别人的博客来学习。

### 5.1.3、找到关键性操作SFR（特殊功能寄存器）

​	WTCON（0xE2700000），其中bit5是看门狗的开关：0代表关，1代表开

### 5.1.4、编写汇编

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-16 12:54:32
 * @FilePath     : \ubuntu share\x210\watch_dog_timer\close_watchdog_timer.S
 * @Description  : 关看门狗，流水灯
 */

#define GPJ0CON 0xE0200240
#define GPJ0DAT 0xE0200244
#define GPD0CON 0xE02000A0
#define GPD0DAT 0xE02000A4

#define WTCON 0xE2700000

.global _start                 
_start:
   
    //设置看门狗为关闭
    ldr r0, =~(1<<5)
    ldr r1, =WTCON
    str r0, [r1]

    //设置LED灯为输出模式
    ldr r0, =0x11111111             
    ldr r1, =GPJ0CON
    str r0, [r1]         

    ldr r0, =0x1111
    ldr r1, =GPD0CON
    str r0, [r1]           

flash:   
    ldr r0, =0xff
    ldr r1, =GPJ0DAT
    str r0, [r1]

    ldr r0, =(~(1<<1))
    ldr r1, =GPD0DAT
    str r0, [r1]

    bl delay

    ldr r0, =(~(0<<1))
    ldr r1, =GPD0DAT
    str r0, [r1]
  
    //点亮2号
    ldr r0, =(~(1<<5))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]                    

    //延时
    bl delay                        

    //点亮3号
    ldr r0, =(~(1<<4))                        
    ldr r1, =GPJ0DAT
    str r0, [r1]                   

    bl delay   
    
    //点亮4号
    ldr r0, =(~(1<<3))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]     

    bl delay

    //点亮3号
    ldr r0, =(~(1<<4))                        
    ldr r1, =GPJ0DAT
    str r0, [r1]    

    bl delay
    
    //点亮2号
    ldr r0, =(~(1<<5))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]   

    bl delay

    ldr r0, =((1<<5) | (1<<4) | (1<<3))                       
    ldr r1, =GPJ0DAT
    str r0, [r1]   


    b flash                             // 代表当前程序段 比较简洁的死循环


//延时函数，函数名：delay
delay:
    
    ldr r2, =9000000
    ldr r3, =0x0

delay_pool:
    sub r2, r2, #1                  //将 r2-1 的数放到 r2内
    cmp r2, r3                      //比较 r2,r3 两个数是否相等，相等就将影响Z标志位，下一句eq就会成立
    bne delay_pool                  //bne 如果不相等就跳转到delay_pool
    mov pc, lr                      //函数调用返回，将 lr 内的地址给 pc 返回之前的位置
```

### 5.1.5、总结210中看门狗特性（iROM中已经关看门狗）

为什么要关看门狗？
	一般CPU设计，在CPU启动后看门狗默认是工作的（为什么默认不关闭而要工作？我猜测是因为怕你的程序在启动代码前端就死机了或者跑飞了没人管），好处就是没有空当和漏洞，坏处就是在启动代码段我们不方便去喂狗（或者说懒得去喂狗）时看门狗会复位，所以为了偷懒我们就在启动代码前端先去关闭看门狗，然后在后面系统启动起来之后再根据需要决定是否要打开看门狗（一旦打开就必须同时提供喂狗）。

​	在S5PV210内部的iROM代码（BL0）中，其实已经关过看门狗了。所以我们的启动代码实际上是不用去关也没事的，也就是说今天写的关闭看门狗的代码运行后没有任何现象（没有现象就是正常现象）。

​	很多CPU内部是没有BL0的，因此也没人给你关看门狗，都要在启动代码前段自己写代码关看门狗，所以今天学习的内容也是有价值的。

****

## 5.2、汇编写启动代码之设置栈和调用C语言

### 5.2.1、C语言运行时需要和栈的意义

“C语言运行时（runtime）”需要一定的条件，这些条件由汇编来提供。C语言运行时主要是需要栈
	C语言与栈的关系：C语言中的局部变量都是用栈来实现的。如果我们汇编部分没有给C部分预先设置合理合法的栈地址，那么C代码中定义的局部变量就会落空，整个程序就死掉了。
	我们平时在编写单片机程序（譬如51单片机）或者编写应用程序时并没有去设置栈，但是C程序还是可以运行的。原因是：在单片机中由硬件初始化时提供了一个默认可用的栈，在应用程序中我们编写的C程序其实并不是全部，编译器（gcc）在链接的时候会帮我们自动添加一个头，这个头就是一段引导我们的C程序能够执行的一段汇编实现的代码，这个代码中就帮我们的C程序设置了栈及其他的运行时需要。

### 5.2.2、CPU模式和各种模式下的栈

在ARM中37个寄存器中，每种模式下都有自己的独立的SP寄存器（r13），为什么这么设计？
	如果各种模式都使用同一个SP，那么就意味着整个程序（操作系统内核程序、用户自己编写的应用程序）都是用一个栈的。你的应用程序如果一旦出错（譬如栈溢出），就会连累操作系统的栈也损坏，整个操作系统的程序就会崩溃。这样的操作系统设计是非常脆弱的，不合理的。

​	解决方案就是各种模式下用不同的栈。我的操作系统内核使用自己的栈，每个应用程序也使用自己独立的栈，这样各是各的，一个损坏不会连累其他人。

​	我们现在要设置栈，不可能也懒的而且也没有必要去设置所有的栈，我们先要找到自己的模式，然后设置自己的模式下的栈到合理合法的位置，即可。

​	注意：系统在复位后默认是进入SVC模式的
​	我们如何访问SVC模式下的SP呢？很简单，先把模式设置为SVC，再直接操作SP。但是因为我们复位后就已经是SVC模式了，所以直接设置SP即可。

### 5.2.3、查阅文档并设置栈指针至合法位置

​	栈必须是当前一段可用的内存（可用的意思是这个地方必须有被初始化过可以访问的内存，而且这个内存只会被我们用作栈，不会被其他程序征用）
​	当前CPU刚复位（刚启动），外部的DRRAM尚未初始化，目前可用的内存只有内部的SRAM（因为它不需初始化即可使用）。因此我们只能在SRAM中找一段内存来作为SVC的栈。
​	栈有四种：满减栈 满增栈 空减栈 空增栈
​	满栈：进栈：先移动指针再存； 出栈：先出数据再移动指针
​	空栈：xxx
​	减栈：进栈：指针向下移动；	 出栈：指针向上移动
​	增栈：xxx
​	在ARM中，ATPCS（ARM关于程序应该怎么实现的一个规范）要求使用满减栈，所以不出意外都是用满减栈
​	结合iROM_application_note中的memory map，可知SVC栈应该设置为0xd0037D80

### 5.2.4、汇编程序和C程序互相调用

​	bl cfuncion 跳转到c里面以cfunction为函数名的函数中去

​	在工程中新建并且添加一个C语言源文件（led.c），注意添加时要修改Makefile
​	在汇编启动代码中设置好栈后，使用bl xxx的方式来调用C中的函数xxx

### 5.2.5、使用C语言来访问寄存器的语法

​	寄存器的地址类似于内存地址（IO与内存统一编址的），所以这里的问题是用C语言读写寄存器，就是用C语言来读写内存地址。用C语言来访问内存，就要用到指针
`unsigned int *p = (unsigned int *)0x0xE0200240;`

`*p = 0x11111111;`
上面这两句其实可以简化为1句将其进行宏定义：*((unsigned int *)0x0xE0200240) 

`#define GPJ0CON 0xE0200240`

`#define rGPJ0CON (*(volatile unsigned int *)GPJ0CON) `

`rGPJ0CON = 0x11111111`

```c
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-16 13:44:21
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-16 14:32:40
 * @FilePath     : \ubuntu share\x210\stack\led.c
 * @Description  : LED的C语言启动代码
 */
void sleep(void);

#define GPJ0CON 0xE0200240
#define GPJ0DAT 0xE0200244          //三个LED的寄存器

#define GPD0CON 0xE02000A0
#define GPD0DAT 0xE02000A4          //剩下一个的led的寄存器

void led_blink(void)
{
    //led的初始化，设置为输出模式
    unsigned int *s = (unsigned int *)GPJ0CON;  
    									//将GPJ0CON的地址赋给 *s
    *s = 0x11111111;                            //这个写法基本上是通用的

    unsigned int *s1 = (unsigned int *)GPD0CON;
    *s1 = 0x1111;

    unsigned int *p = (unsigned int *)GPJ0DAT;      
    unsigned int *p1 = (unsigned int *)GPD0DAT;
    
    while(1)
    {
        *p1 = ~(1<<1);
        sleep();
        *p1 = ~(0<<1);
        *p = ~(1<<5);
        sleep();
        *p = ~(1<<4);
        sleep();
        *p = ~(1<<3);
    }
}

void sleep(void)
{
    volatile int i = 10000;   //volatile 不要编译器优化，这样才能真正的减，才能消耗时间
    while(i--);
}
```

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-16 14:04:01
 * @FilePath     : \ubuntu share\x210\stack\stack.S
 * @Description  : 在看门狗的基础上设置SVC内可供C语言使用的栈，之后将之前用汇编的LED用C语言实现
 */

#define WTCON 0xE2700000

.global _start                 
_start:
   
    //设置看门狗为关闭
    ldr r0, =~(1<<5)
    ldr r1, =WTCON
    str r0, [r1]

    //设置栈
    ldr sp, =0xD0037D80         //sp是内存的栈指针

    //从这里开始可以调用C语言
    
    bl led_blink                //led_blink是C语言实现的一个函数

    b .
```

编译报错（实际上是连接阶段报错）：undefined reference to `__aeabi_unwind_cpp_pr1'

解决方法：把错误信息直接贴到baidu搜索（baidu搜索不到找google），根据搜索到的内容一个一个看，一个一个尝试，直到解决。
	解决：在编译时添加-nostdlib这个编译选项即可解决。nostdlib就是不使用标准函数库。标准函数库就是编译器中自带的函数库，用-nostdlib可以让编译器链接器优先选择我程序内自己写的函数库。

### 5.2.6、神奇的volatile

​	volatile的作用是让程序在编译时，编译器不对程序做优化。优化有时候是ok的，但是有时候是自作聪明会造成程序不对。如果你的一个变量是易变的，不希望编译器帮我们做优化，就在这个变量定义时加volatile。
​	加不加有没有差别，取决于编译器。如果编译器做了优化则有差异；如果编译器本身没做优化，那就没有差别。
​	在我们这里（编译器是arm-2009q3），实际测试加不加效果是一样的。

### 5.2.7、总结

​	C和汇编函数的互相调用（函数名和汇编标号的真实意义）
​	C语法对内存访问的封装方式（使用指针来访问内存的技巧）
​	汇编的意义（起始代码&效率关键部位）

****

## 5.3、汇编写启动代码之开iCache

### 5.3.1、什么是cache，有什么用

cache是一种内存，叫高速缓存。

从容量来说：CPU <　寄存器 < cache < DDR
从速度来说：CPU >  寄存器 > cache > DDR

​	cache的存在，是因为寄存器和ddr之间速度差异太大，ddr的速度远不能满足寄存器的需要（不能满足cpu的需要，所以没有cache会拉低整个系统的整体速度）
整个系统中CPU的供应链由：寄存器+cache+DDR+硬盘/flash四阶组成，这是综合考虑了性能、成本后得到的妥协的结果。
210内部有32KB icache和32kb dcache。icache是用来缓存指令的；dcache是用来缓存数据的。

cache的意义：指令平时是放在硬盘/flash中的，运行时读取到DDR中，再从DDR中读给寄存器，再由寄存器送给cpu。但是DDR的速度和寄存器（代表的就是CPU）相差太大，如果CPU运行完一句再去DDR读取下一句，那么CPU的速度完全就被DDR给拖慢了。解决方案就是icache。

icache工作时，会把我们CPU正在运行的指令的旁边几句指令事先给读取到icache中（CPU设计有一个基本原理：代码执行时，下一句执行当前一句代码旁边代码的可能性要大很多）。当下一句CPU要指令时，cache首先检查自己事先准备的缓存指令中有没这句，如果有就直接拿给CPU，如果没有则需要从DDR中重新去读取拿给CPU，并同时做一系列的动作：清缓存、重新缓存。

### 5.3.2、iROM中BL0对cache的操作

首先，icache的一切动作都是自动的，不需人为干预。我们所需要做的就是打开/关闭icache。
其次，在210的iROM中BL0已经打开了icache。所以之前看到的现象都是icache打开时的现象。

### 5.3.3、汇编代码读写cp15以开关icache

```assembly
	mrc p15,0,r0,c1,c0,0;			// 读出cp15的c1到r0中
	bic r0, r0, #(1<<12)			// bit12 置0  关icache
	orr r0, r0, #(1<<12)			// bit12 置1  开icache
	mcr p15,0,r0,c1,c0,0;
```



### 5.3.4、实验验证

我们来看三种情况下的实验现象：
	1 直接使用BL0中对icache的操作
	2 关icache
	3 开icache
实验结果分析：
	结论1：irom中确实是打开了icache的。
	结论2：icache关闭确实比icache打开时led闪烁变慢，说明指令执行速度变慢。

****

## 5.4、重定位引入和链接脚本1

### 5.4.1、一个事实：大部分指令是位置有关编码

​	位置无关编码(PIC，position independent code)：汇编源文件被编码成二进制可执行程序时编码方式与位置（内存地址）无关。
位置有关编码：汇编源码编码成二进制可执行程序后和内存地址是有关的。

​	我们在设计一个程序时，会给这个程序指定一个运行地址（链接地址）。就是说我们在编译程序时其实心里是知道我们程序将来被运行时的地址（运行地址）的，而且必须给编译器链接器指定这个地址（链接地址）才行。最后得到的二进制程序理论上是和你指定的运行地址有关的，将来这个程序被执行时必须放在当时编译链接时给定的那个地址（链接地址）下才行，否则不能运行（就叫位置有关代码）。但是有个别特别的指令他可以跟指定的地址（链接地址）没有关系，也就是说这些代码实际运行时不管放在哪里都能正常运行。

​	对比：位置无关代码要好一些，适应性强，放在哪里都能正常运行；位置有关代码就必须运行在链接时指定的地址上，适应性差。位置无关码有一些限制，不能完成所有功能，有时候不得不使用位置有关代码。

### 5.4.2、链接地址和运行地址：可能相同也可能不同

​	对于位置有关代码来说：最终执行时的运行地址和编译链接时给定的链接地址必须相同，否则一定出错。

​	我们之前的裸机程序中，Makefile中用 -Ttext 0x0 来指定链接地址是0x0。这意味着我们认为这个程序将来会放在0x0这个内存地址去运行。

​	但是实际上我们运行时的地址是0xd0020010(我们用dnw下载时指定的下载地址)。这两个地址看似不同，但是实际相同。这是因为S5PV210内部做了映射，把SRAM映射到了0x0地址去。

分清楚这两个概念：
链接地址：链接时指定的地址（指定方式为：Makefile中用-Ttext，或者链接脚本）
运行地址：程序实际运行时地址（指定方式：由实际运行时被加载到内存的哪个位置说了算）

### 5.4.3、再解S5PV210的启动过程：三星推荐和uboot的实现是不同的

​	三星推荐的启动方式中：bootloader必须小于96KB并大于16KB，假定bootloader为80KB，启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的bootloader的前16KB（BL1）到SRAM中去运行，BL1运行时会加载BL2（bootloader中80-16=64KB）到SRAM中（从SRAM的16KB处开始用）去运行；BL2运行时会初始化DDR并且将OS搬运到DDR去执行OS，启动完成。

​	uboot实际使用的方式：uboot大小随意，假定为200KB。启动过程是这样子：先开机上电后BL0运行，BL0会加载外部启动设备中的uboot的前16KB（BL1）到SRAM中去运行，BL1运行时会初始化DDR，然后将整个uboot搬运到DDR中，然后用一句长跳转（从SRAM跳转到DDR）指令从SRAM中直接跳转到DDR中继续执行uboot直到uboot完全启动。uboot启动后在uboot命令行中去启动OS。

### 5.4.4、用重定位的原因

原因：
	链接地址和运行地址有时候必须不相同，而且还不能全部用位置无关码，这时候只能重定位。

扩展：
	分散加载：把uboot分成2部分（BL1和整个uboot），两部分分别指定不同的链接地址。启动时将两部分加载到不同的地址（BL1加载到SRAM，整个uboot加载到DDR），这时候不用重定位也能启动。

评价：分散加载其实相当于手工重定位。重定位是用代码来进行重定位，分散加载是手工操作重定位的。

****

## 5.5、重定位引入和链接脚本2

### 5.5.1、运行时地址由什么决定

​	运行时的地址是由运行时决定的（编译链接时是无法绝对确定运行时地址的）

### 5.5.2、链接地址由什么决定？

​	链接地址是由程序员在编译链接的过程中，通过Makefile中-Ttext xxx或者在链接脚本中指定的。程序员事先会预知自己的程序的执行要求，并且有一个期望的执行地址，并且会用这个地址来做链接地址。

举例：

​	1、linux中的应用程序。gcc hello.c -o hello，这时使用默认的链接地址就是0x0，所以应用程序都是链接在0地址的。因为应用程序运行在操作系统的一个进程中，在这个进程中这个应用程序独享4G的虚拟地址空间。所以应用程序都可以链接到0地址，因为每个进程都是从0地址开始的。（编译时可以不给定链接地址而都使用0）

​	2、210中的裸机程序。运行地址由我们下载时确定，下载时下载到0xd0020010，所以就从这里开始运行。（这个下载地址也不是我们随意定的，是iROM中的BL0加载BL1时事先指定好的地址，这是由CPU的设计决定的）。所以理论上我们编译链接时应该将地址指定到0xd0020010，但是实际上我们在之前裸机程序中都是使用位置无关码PIC，所以链接地址可以是0。

### 5.5.3、从源码到可执行程序的步骤：预编译、编译、链接、strip

​	预编译：预编译器执行。譬如C中的宏定义就是由预编译器处理，注释等也是由预编					译器处理的。

​	编译：  编译器来执行。把源码.c .S编程机器码.o文件。

​	链接：	链接器来执行。把.o文件中的各函数（段）按照一定规则（链接脚本来指					定）累积在一起，形成可执行文件。

​	strip： strip是把可执行程序中的符号信息给拿掉，以节省空间。（Debug版本和				Release版本）

​	objcopy：由可执行程序生成可烧录的镜像bin文件。

### 5.5.4、程序段的概念：代码段、数据段、bss段（ZI段）、自定义段

​	段就是程序的一部分，我们把整个程序的所有东西分成了一个一个的段，给每个段起个名字，然后在链接时就可以用这个名字来指示这些段。也就是说给段命名就是为了在链接脚本中用段名来让段站在核实的位置。

段名分为2种：一种是编译器链接器内部定好的，先天性的名字；一种是程序员自己指定的、自定义的段名。
先天性段名：
	代码段：（.text），又叫文本段，代码段其实就是函数编译后生成的东西
	数据段：（.data），数据段就是C语言中有显式初始化为非0的全局变量
	bss段：（.bss），又叫ZI（zero initial）段，就是零初始化段，对应C语言中初始化为0的全局变量。
后天性段名：
	段名由程序员自己定义，段的属性和特征也由程序员自己定义。
	
分析一些问题，跟这里结合，然后试图明白一些本质：
1、C语言中全局变量如果未显式初始化，值是0。本质就是C语言把这类全局变量放在了bss段，从而保证了为0
2、C运行时环境如何保证显式初始化为非0的全局变量的值在main之前就被赋值了？就是因为它把这类变量放在了.data段中，而.data段会在main执行之前被处理（初始化）。

### 5.5.5、链接脚本的作用

​	链接脚本其实是个规则文件，他是程序员用来指挥链接器工作的。链接器会参考链接脚本，并且使用其中规定的规则来处理.o文件中那些段，将其链接成一个可执行程序。
​	链接脚本的关键内容有2部分：段名 + 地址（作为链接地址的内存地址）

```lds
//链接脚本实例
SECTIONS
{
	. = 0Xd0024000;   // . 在链接脚本中代表当前位置
					// = 是赋值，规定整个程序的其实地址
	.text : {		// . 段名 ：{} 就是一个段
		start.o		//特指明将start.o 放在最前面
		* (.text)    //将所有的括号内类型的段放到这里
	}
	.data : {
		* (.data)
	}
	
	bss_start = .;		//把当前位置的地址赋值给左值当前位置就是代码起始						//位置加上之前代码所占的位置就是当前位置
	.bss : {
		* (.bss)
	}
	
	bss_end = .;
}
```

链接脚本的理解：
	SECTIONS {}	这个是整个链接脚本
	. 点号在链接脚本中代表当前位置。
	= 等号代表赋值

****

## 5.6、代码重定位实战

### 5.6.1、任务：在SRAM中将代码从0xd0020010重定位到0xd0024000

​	任务解释：本来代码是运行在0xd0020010的，但是因为一些原因我们又希望代码实际是在0xd0024000位置运行的。这时候就需要重定位了。
注解：本练习对代码本身运行无实际意义，我们做这个重定位纯粹是为了练习重定位技能。但是某些情况重定位就是必须的，譬如在uboot中。

### 5.6.2、思路

​	第一点：通过链接脚本将代码链接到0xd0024000
​	第二点：dnw下载时将bin文件下载到0xd0020010

​	第一点加上第二点，就保证了：代码实际下载运行在0xd0020010，但是却被链接在0xd0024000。从而为重定位奠定了基础。
当我们把代码链接地址设置为0xd0024000时，实际隐含意思就是我这个代码将来必须放在0xd0024000位置才能正确执行。如果实际运行地址不是这个地址就要出事（除非代码是PIC位置无关码），当以上都明白了后，就知道重定位代码的作用就是：在PIC执行完之前（在代码中第一句位置有关码执行之前）必须将整个代码搬移到0xd0024000位置去执行，这就是重定位。

​			第三点：代码执行时通过代码前段的少量位置无关码将整个代码搬移到0xd0024000
​			第四点：使用一个长跳转跳转到0xd0024000处的代码继续执行，重定位完成

长跳转的含义：首先这句代码是一句跳转指令（ARM中的跳转指令就是类似于分支指令B、BL等作用的指令），跳转指令通过给PC（r15）赋一个新值来完成代码段的跳转执行。长跳转指的是跳转到的地址和当前地址差异比较大，跳转的范围比较宽广。

​	当我们执行完代码重定位后，实际上在SRAM中有2份代码的镜像（一份是我们下载到0xd0020010处开头的，另一份是重定位代码复制到0xd0024000处开头的），这两份内容完全相同，仅仅地址不同。重定位之后使用ldr pc, =led_blink这句长跳转直接从0xd0020010处代码跳转到0xd0024000开头的那一份代码的led_blink函数处去执行。（实际上此时在SRAM中有2个led_blink函数镜像，两个都能执行，如果短跳转bl led_blink则执行的就是0xd0020010开头的这一份，如果长跳转ldr pc, =led_blink则执行的是0xd0024000开头处的这一份）。这就是短跳转和长跳转的区别。

​	当链接地址和运行地址相同时，短跳转和长跳转实际效果是一样的；但是当链接地址不等于运行地址时，短跳转和长跳转就有差异了。这时候短跳转实际执行的是运行地址处的那一份，而长跳转执行的是链接地址处那一份。

总结：重定位实际就是在运行地址处执行一段位置无关码PIC，让这段PIC（也就是重定位代码）从运行地址处把整个程序镜像拷贝一份到链接地址处，完了之后使用一句长跳转指令从运行地址处直接跳转到链接地址处去执行同一个函数（led_blink），这样就实现了重定位之后的无缝连接。

### 5.6.3、adr与ldr伪指令的区别

ldr和adr都是伪指令，区别就是ldr是长加载，adr是短加载

==重点==：adr指令加载符号地址，加载的是运行时地址；ldr指令加载符号地址时，加载的是链接地址。

深入分析：只要知道adr和ldr分别用于加载运行地址和链接地址，从而可以判读是否需要重定位，根本不需知道为什么adr和ldr是这样子，但是我们还是给大家扩展讲下为什么adr和ldr可以加载不同的地址。

### 5.6.4、重定位（代码拷贝）

​	重定位就是汇编代码中的copy_loop函数，代码的作用是使用循环结构来逐句复制代码到链接地址。
​	复制的源地址是SRAM的0xd0020010，复制目标地址是SRAM的0xd0024000，复制长度是bss_start减去_start
​	所以复制的长度就是整个重定位需要重定位的长度，也就是整个程序中代码段+数据段的长度。
​	bss段（bss段中就是0初始化的全局变量）不需要重定位。

### 5.6.5、清bss段

​	清除bss段是为了满足C语言的运行时要求（C语言要求显式初始化为0的全局变量，或者未显式初始化的全局变量的值为0，实际上C语言编译器就是通过清bss段来实现C语言的这个特性的）。一般情况下我们的程序是不需要负责清零bss段的（C语言编译器和链接器会帮我们的程序自动添加一段头程序，这段程序会在我们的main函数之前运行，这段代码就负责清除bss）。但是在我们代码重定位了之后，因为编译器帮我们附加的代码只是帮我们清除了运行地址那一份代码中的bss，而未清除重定位地址处开头的那一份代码的bss，所以重定位之后需要自己去清除bss。

### 5.6.6、长跳转

清理完bss段后重定位就结束了。然后当前的状况是：

​	1、当前运行地址还在0xd0020010开头的（重定位前的）那一份代码中运行着。
​	2、此时SRAM中已经有了2份代码，1份在d0020010开头，另一份在d0024000开头的位置。
​	然后就要长跳转了。

```assembly
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-15 14:58:58
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-19 22:01:01
 * @FilePath     : \ubuntu share\x210\chongdingw\stack.S
 * @Description  : 分析重定位（在SRAM内部重定位）
 */

#define WTCON 0xE2700000

.global _start                 
_start:
   
    //设置看门狗为关闭
    ldr r0, =~(1<<5)
    ldr r1, =WTCON
    str r0, [r1]

    //设置栈
    ldr sp, =0xD0037D80         //sp是内存的栈指针

     //关闭iCache
    mrc p15,0,r0,c1,c0,0;			// 读出cp15的c1到r0中
	bic r0, r0, #(1<<12)			// bit12 置0  关icache
	//orr r0, r0, #(1<<12)			// bit12 置1  开icache
	mcr p15,0,r0,c1,c0,0;

    //重定位
    //adr指令用于加载_start当前运行地址
    adr r0, _start
    //ldr指令用于加载_start的链接地址：0xd00240000
    ldr r1, =_start
    //bss段的起始地址
    ldr r2, =bss_start        //这个就是我们重定位代码的结束地址，重定位							//只需重定位代码段和数据段即可
    cmp r0, r1                //比较_start的运行时地址和链接地址是否相等
    beq clean_bss            //如果相等说明不需要重定位所以跳过copy_loop 						//直接到 clean_bss程序段
                            //如果不相等就往下执行copy_loop进行重定位

//用汇编实现while循环
copy_loop:
    ldr r3, [r0], #4        // r0 运行时的地址 将r0所指向的地址的内容加4							//读到r3
    str r3, [r1], #4      //r1 就是链接地址  将r3里的内容加4放到r1所指向						//的地址 这两句话就完成了4个字节的拷贝 #4就是p++
    cmp r1, r2     //r1和r2都是用ldr加载的都是链接地址，所以r1+4总能等于r2
    bne copy_loop     //比较r1，r2是否相等不相等就继续指向

    //清bss段，其实就是在我们链接地址处把bss段清零
clean_bss:
    ldr r0, =bss_start
    ldr r1, =bss_end
    cmp r0, r1              //如果r0 == r1，说明bss段为空直接跳到run_on_dram程序段去
    beq run_on_dram         //清除完bss段之后的地址
    mov r2, #0
clear_loop:
    str r2, [r0], #4  //先将r2的值放入r0所指向的内存地址，然后再r0 = r0+4
    cmp r0, r1              //比较
    bne clear_loop

run_on_dram:
    //长跳转到led_blink开始第二阶段

    ldr pc, =led_blink              //这是个长跳转，到0xd002400的led_blink处
    //bl led_blink            //led_blink是C语言实现的一个函数，这里的是							//短跳转跳转到0xd0001000的led_blink处

    b .
```

****

## 5.7、SDRAM引入

### 5.7.1、SDRAM

SDRAM：Syncronized Dynamic Ramdam Access Memory，同步动态随机存储器
DDR：DDR就是DDR SDRAM，是SDRAM的升级版。（DDR：double rate，双倍速度的SDRAM）
DDR有好多代：DDR1 DDR2 DDR3 DDR4 LPDDR

### 5.7.2、SDRAM的特性

容量大、价格低、断电易丢失、随机读写、总线式访问

SDRAM/DDR都属于动态内存（相对于静态内存SRAM），都需要先运行一段初始化代码来初始化才能使用不像SRAM开机上电后就可以直接运行。
类似于SDRAM和SRAM的区别的，还有NorFlash和NandFlash（硬盘）这两个。
正是因为硬件本身特性有限制，所以才导致启动代码比较怪异、比较复杂。而我们研究裸机是为了研究uboot，在uboot中就充分利用了硬件的各种特性，处理了硬件复杂性。

### 5.7.3、SDRAM数据手册

SDRAM在系统中属于SoC外接设备（外部外设。以前说过随着半导体技术发展，很多东西都逐渐集成到SoC内部去了。现在还长期在外部的一般有：Flash、SDRAM/DDR、网卡芯片如DM9000、音频Codec。现在有一些高集成度的芯片也试图把这几个集成进去，做成真正的单芯片解决方案。）
SDRAM通过地址总线和数据总线接口（总线接口）与SoC通信。

开发板原理图上使用的是K4T1G164QQ，但是实际开发板上贴的不是这个，是另一款。但是这两款是完全兼容的，进行软件编程分析的时候完全可以参考K4T1G164QQ的文档。

全球做SDRAM的厂商不多，二线厂家做的产品参数都是向一线厂家（三星、KingSton）看齐，目的是兼容一线厂家的设计，然后让在意成本的厂商选择它的内存芯片替代一线厂家的内存芯片。SDRAM的这个市场特征就导致这个东西比较标准化，大部分时候细节参数官方（芯片原厂家）都会给你一个参考值。

K4T1G164QE：
K表示三星产品，4表示是DRAM，T表示产品号码，1G表示容量（1Gb，等于128MB，我们开发板X210上一共用了4片相同的内存，所以总容量是128×4=512MB）16表示单芯片是16位宽的，4表示是4bank，

三星官方的数据手册上其实没有芯片相关的参数设置信心，都是芯片选型与外观封装方面的信息，选型是给产品经理来看的，封装和电压等信息是给硬件工程师看的。软件工程师最关注的是工作参数信息，但是数据手册没有。

****

## 5.8、初始化SDRAM

### 5.8.1、原理图中SDRAM相关部分

S5PV210共有2个内存端口（就好象有2个内存插槽）。再结合查阅数据手册中内存映射部分，可知：两个内存端口分别叫DRAM0和DRAM1：

​	DRAM0：内存地址范围：0x20000000～0x3FFFFFFF（512MB），对应引脚是Xm1xxxx
​	DRAM1: 内存地址范围：0x40000000～0x7FFFFFFF（1024MB），对应引脚是Xm2xxxx

结论：

（1）整个210最多支持内存为1.5GB，如果给210更多的内存CPU就无法识别。

（2）210最多支持1.5GB内存，但是实际开发板不一定要这么多，譬如我们X210开发板就只有512MB内存，连接方法是在DRAM0端口分布256MB，在DRAM1端口分布了256MB。

（3）由2可知，X210开发板上内存合法地址是：0x20000000～0x2FFFFFFF（256MB） + 0x40000000～0x4FFFFFFF（256MB）。当板子上DDR初始化完成之后，这些地址都是可以使用的；如果使用了其他地址譬如0x30004000就是死路一条。

原理图中每个DDR端口都由3类总线构成：地址总线（Xmn_ADDR0~XMnADDR13共14根地址总线） + 控制总线（中间部分，自己看原理图） + 数据总线（Xmn_DATA0~XMnDATA31共32根数据线）
分析：从数据总线的位数可以看出，我们用的是32位的（物理）内存。

原理图中画出4片内存芯片的一页，可以看出：X210开发板共使用了4片内存（每片1Gb=128MB，共512MB），每片内存的数据总线都是16位的（单芯片是16位内存）。如何由16位内存得到32位内存呢？可以使用并联方法。在原理图上横向的2颗内存芯片就是并联连接的。并联时地址总线接法一样，但是数据总线要加起来。这样连接相当于在逻辑上可以把这2颗内存芯片看成是一个（这一个芯片是32位的，接在Xm1端口上）。

### 5.8.2、数据手册中SDRAM相关的部分

看数据手册《NT5TU64M16GG-DDR2-1G-G-R18-Consumer》第10页的block diagram。这个框图是128Bb×8结构的，这里的8指的是8bank，每bank128Mbit。
210的DDR端口信号中有BA0～BA2，接在内存芯片的BA0～BA2上，这些引脚就是用来选择bank的。
每个bank内部有128Mb，通过row address（14位） + column address（10位）的方式来综合寻址。
一共能寻址的范围是：2的14次方+2的10次方 = 2的24次方。对应16MB（128Mbit）内存。

*****

## 5.9、汇编初始化SDRAM详解1

### 5.9.1、初始化代码框架介绍（函数调用和返回值、步骤等）

SDRAM初始化使用一个函数sdram_asm_init，函数在sdram_init.S文件中实现，是一个汇编函数。
	强调：汇编实现的函数在返回时需要明确使用返回指令（mov pc, lr）

### 5.9.2、27步初始化DDR2

（1）首先，DDR初始化和SoC（准确说是和SoC中的DDR控制器）有关，也和开发板使用的DDR芯片有关，和开发板设计时DDR的连接方式也有关。

（2）S5PV210的DDR初始化步骤在SoC数据手册：1.2.1.3 DDR2这个章节。可知初始化DDR共需27个步骤。

（3）之前分析过X210的内存连接方式是：在DRAM0上连接256MB，在DRAM1上连接了256MB。所以初始化DRAM时分为2部分，第一部分初始化DRAM0，第二部分初始化DRAM1.

（4）我们的代码不是自己写的，这个代码来自于：第一，九鼎官方的uboot中；第二，参考了九鼎的裸机教程中对DDR的初始化；第三，有些参数是我根据自己理解修改过的。

### 5.9.3、设置IO端口驱动强度

​	因为DDR芯片和S5PV210之间是通过很多总线连接的，总线的物理表现就是很多个引脚，也就是说DDR芯片和S5PV210芯片是通过一些引脚连接的。DDR芯片工作时需要一定的驱动信号，这个驱动信号需要一定的电平水平才能抗干扰，所以需要设置这些引脚的驱动能力，使DDR正常工作。
DRAM控制器对应的引脚设置为驱动强度2X（我也不知道为什么是2X，什么时候设置成3X 4X?，这东西只能问DDR芯片厂商或者SoC厂商，我们一般是参考原厂给的代码）

### 5.9.4、DRAM port 时钟设置

从代码第128行到154行。主要是开启DLL（dram pll）然后等待锁存。
这段代码对应27步中的第2到第4步。

***

## 5.10、汇编初始化SDRAM详解2

### 5.10.1、DMC0_MEMCONTROL

burst length=4，1chip，······  对应值是0x00202400

### 5.10.2、DMC0_MEMCONFIG_0

DRAM0通道中memory chip0的参数设置寄存器

### 5.10.3、DMC0_MEMCONFIG_1

DRAM0通道中memory chip1的参数设置寄存器
总结：我猜测（推论）：三星设置DRAM0通道，允许我们接2片256MB的内存，分别叫memory chip0和memory chip1，分别用这两个寄存器来设置它的参数。按照三星的设计，chip0的地址应该是0x20000000到0x2FFFFFFF，然后chip1的地址应该是0x30000000~0x3FFFFFFF.各自256MB。
但是我们X210开发板实际在DRAM0端口只接了256MB的内存，所以只用了chip0，没有使用chip1.（我们虽然是2片芯片，然后这两片是并联形成32位内存的，逻辑上只能算1片）。按照这个推论，DMC0_MEMCONFIG_0有用，而DMC0_MEMCONFIG_1无用，所以我直接给他了默认值。

### 5.10.4、DMC_DIRECTCMD

这个寄存器是个命令寄存器，我们210通过向这个寄存器写值来向DDR芯片发送命令（通过命令总线），这些命令应该都是用来配置DDR芯片工作参数。

### 5.10.5、重定位代码到SDRAM中

DRAM初始化之后，实际上重定位代码过程和之前重定位到SRAM中完全相同。

****

# 6、时钟系统

## 6.1、SoC时钟系统简介

### 6.1.1、什么是时钟？SoC为什么需要时钟？

（1）时钟是同步工作系统的同步节拍。

（2）SoC内部有很多器件，譬如CPU、串口、DRAM控制器、GPIO等内部外设，这些东西要彼此协同工作，需要一个同步的时钟系统来指挥。这个就是我们SoC的时钟系统。

### 6.1.2、时钟一般如何获得

（1）SoC的时钟获得一般有：

  - 外部直接输入时钟信号，SoC有个引脚用来输入外部时钟信号，用的很少。
  - 外部晶振+内部时钟发生器产生时钟，大部分低频单片机都是这么工作的。
  - 外部晶振+内部时钟发生器+内部PLL产生高频时钟+内部分频器分频得到各种频率的时钟，210属于这种。 

（2）S5PV210属于第三种。为什么这么设计？

第一问：外什么不用外部高频晶振产生高频信号直接给CPU？
主要是因为芯片外部电路不适宜使用高频率，因为传导辐射比较难控制；高频率的晶振太贵了。
第二问：为什么要内部先高频然后再分频？
主要因为SoC内部有很多部件都需要时钟，而且各自需要的时钟频率不同，没法统一供应。因此设计思路是PLL后先得到一个最高的频率（1GHz、1.2GHz），然后各外设都有自己的分频器再来分频得到自己想要的频率。

### 6.1.3、时钟和系统性能的关系、超频、稳定性

（1）一般SoC时钟频率都是可以人为编程控制的，频率的高低对系统性能有很大影响。

（2）S5PV210建议工作频率800MHz～1.2GHz，一般我们都设置到1GHz主频。如果你设置到1.2GHz就叫超频。超频的时候系统性能会提升，但是发热也会增大，因此会影响系统稳定性。

### 6.1.4、时钟和外设编程的关系

（1）每个外设工作都需要一定频率的时钟，这些时钟都是由时钟系统提供的。时钟系统可以编程控制工作模式，因此我们程序员可以为每个外设指定时钟来源、时钟分频系统、从而制定这个外设的工作时钟。

### 6.1.5、时钟和功耗控制的关系

（1）SoC中各种设备工作时，时钟频率越高其功耗越大，发热越大，越容易不稳定，需要外部的散热条件越苛刻。

（2）SoC内部有很多外设，这些外设不用的时候最好关掉（不关掉会一定程度浪费电），开关外设不是通过开关，而是通过时钟。也就是说我们给某个外设断掉时钟，这个外设就不工作了。

****

## 6.2、x210的时钟系统简介

### 6.2.1、时钟域：MSYS、DSYS、PSYS

（1）因为S5PV210的时钟体系比较复杂，内部外设模块太多，因此把整个内部的时钟划分为3大块，叫做3个域。

（2）MSYS: CPU（Cortex-A8内核）、DRAM控制器（DMC0和DMC1）、IRAM&IROM······

（3）DSYS: 都是和视频显示、编解码等有关的模块

（4）PSYS: 和内部的各种外设时钟有关，譬如串口、SD接口、I2C、AC97、USB等。

（5）为什么内部要分为3个域，怎么划分的？因为210内部的这些模块彼此工作时钟速率差异太大了，所以有必要把高速的放一起，相对低速的放一起。

### 6.2.2、时钟的来源：晶振+时钟发生器+PLL+分频电路

（1）S5PV210外部有4个晶振接口，设计板子硬件时可以根据需要来决定在哪里接晶振。接了晶振之后上电相应的模块就能产生振荡，产生原始时钟。原始时钟再经过一系列的筛选开关进入相应的PLL电路生成倍频后的高频时钟。高频时钟再经过分频到达芯片内部各模块上。（有些模块，譬如串口内部还有进一步的分频器进行再次分频使用）

### 6.2.3、PLL：APLL、MPLL、EPLL、VPLL

APLL：Cortex-A8内核 MSYS域
MPLL&EPLL：DSYS PSYS
VPLL：Video视频相关模块

****

## 6.3、x210的时钟域详解

### 6.3.1、MSYS域

​	**ARMCLK：	给cpu内核工作的时钟，也就是所谓的主频。**（重要）
​	**HCLK_MSYS：	MSYS域的高频时钟，给DMC0和DMC1使用**（重要）
​	PCLK_MSYS：	MSYS域的低频时钟
​	HCLK_IMEM：给iROM和iRAM（合称iMEM）使用

### 6.3.2、DSYS域

​	HCLK_DSYS：DSYS域的高频时钟
​	PCLK_DSYS：DSYS域的低频时钟

### 6.3.3、PSYS域

​	HCLK_PSYS：PSYS域的高频时钟
​	PCLK_PSYS：PSYS域的低频时钟
​	SCLK_ONENAND：

总结：210内部的各个外设都是接在（内部AMBA总线）总线上面的，AMBA总线有1条高频分支叫AHB，有一条低频分支叫APB。上面的各个域都有各自对应的HCLK_XXX和PCLK_XXX，其中HCLK_XXX就是XXX这个域中AHB总线的工作频率；PCLK_XXX就是XXX这个域中APB总线的工作频率。
SoC内部的各个外设其实是挂在总线上工作的，也就是说这个外设的时钟来自于他挂在的总线，譬如串口UART挂在PSYS域下的APB总线上，因此串口的时钟来源是PCLK_PSYS。
我们可以通过记住和分析上面的这些时钟域和总线数值，来确定我们各个外设的具体时钟频率。

### 6.3.4、各时钟典型值（默认值、iROM中设置的值）

（1）当210刚上电时，默认是外部晶振+内部时钟发生器产生的24MHz频率的时钟直接给ARMCLK的，这时系统的主频就是24MHz，运行非常慢。

（2）iROM代码执行时第6步中初始化了时钟系统，这时给了系统一个默认推荐运行频率。这个时钟频率是三星推荐的210工作性能和稳定性最佳的频率。

（3）各时钟的典型值：
 - freq(ARMCLK) 			= 1000 MHz
 -  freq(HCLK_MSYS) 		= 200 MHz
 -  freq(HCLK_IMEM) 		= 100 MHz
 -  freq(PCLK_MSYS) 		= 100 MHz
 -  freq(HCLK_DSYS) 		= 166 MHz
 -  freq(PCLK_DSYS) 		= 83 MHz
 -  freq(HCLK_PSYS) 		= 133 MHz
 -  freq(PCLK_PSYS) 		= 66 MHz
 -  freq(SCLK_ONENAND) 	= 133 MHz, 166 MHz

***

## 6.4、x210时钟体系框架详解

（1）时钟体系框图的位置：数据手册P361&P362，Figure3-3

（2）两张图之间是渐进的关系。第一张图从左到右依次完成了原始时钟生成->PLL倍频得到高频时钟->初次分频得到各总线时钟；第二张图是从各中间时钟（第一张图中某个步骤生成的时钟）到各外设自己使用的时钟（实际就是个别外设自己再额外分频的设置）。可见，第一张图是理解整个时钟体系的关键，第二种图是进一步分析各外设时钟来源的关键。

（3）要看懂时钟体系框图，2个符号很重要：一个是MUX开关，另一个是DIV分频器。

- MUX开关就是个或门，实际对应某个寄存器的某几个bit位的设置，设置值决定了哪条通道通的，分析这个可以知道右边的时钟是从左边哪条路过来的，从而知道右边时钟是多少。
- DIV分频器，是一个硬件设备，可以对左边的频率进行n分频，分频后的低频时钟输出到右边。分频器在编程时实际对应某个寄存器中的某几个bit位，我们可以通过设置这个寄存器的这些对应bit位来设置分频器的分频系数（譬如左边进来的时钟是80MHz，分频系统设置为8，则分频器右边输出的时钟频率为10MHz）。
- 寄存器中的clock source x就是在设置MUX开关；clock divider control寄存器就是在设置分频器分频系数。

****

## 6.5、时钟设置的关键性寄存器

### 6.5.1、(x)PLL_LOCK

(x)PLL_LOCK寄存器主要控制PLL锁定周期的。PLL将输入频率进行倍频的时候PLL有一个锁定周期，在这个时间内不能输出一个稳定的频率

### 6.5.2、(x)PLL_CON、(x)PLL_CON1和(x)PLL_CON0

PLL_CON寄存器主要用来打开/关闭PLL电路，设置PLL的倍频参数，查看PLL锁定状态等

### 6.5.3、CLK_SRCn(n：0～6)

CLK_SRC寄存器是用来设置时钟来源的，对应时钟框图中的MUX开关。

### 6.5.4、CLK_SRC_MASKn

CLK_SRC_MASK决定MUX开关n选1后是否能继续通过。默认的时钟都是打开的，好处是不会因为某个模块的时钟关闭而导致莫名其妙的问题，坏处是功耗控制不精细、功耗高。

### 6.5.5、CLK_DIVn

各模块的分频器参数配置

### 6.5.6、CLK_GATE_x

类似于CLK_SRC_MASK，对时钟进行开关控制

### 6.5.7、CLK_DIV_STATn、CLK_MUX_STATn

这两类状态位寄存器，用来查看DIV和MUX的状态是否已经完成还是在进行中

总结：其中最重要的寄存器有3类：CON、SRC、DIV。其中CON决定PLL倍频到多少，SRC决定走哪一路，DIV决定分频多少。

****

## 6.6、汇编实现时钟设置代码详解

### 6.6.1、时钟设置的步骤分析

​	第1步：先选择不使用PLL。让外部24MHz原始时钟直接过去，绕过APLL那条路
​	第2步：设置锁定时间。默认值为0x0FFF，保险起见我们设置为0xFFFF
​	第3步：设置分频系统，决定由PLL出来的最高时钟如何分频得到各个分时钟
​	第4步：设置PLL，主要是设置PLL的倍频系统，决定由输入端24MHz的原始频率可以得到多
​			大的输出频率。我们按照默认设置值设置输出为ARMCLK为1GHz
​	第5步：打开PLL。前面4步已经设置好了所有的开关和分频系数，本步骤打开PLL后PLL开始
​			工作，锁定频率后输出，然后经过分频得到各个频率。
总结：以上5步，其实真正涉及到的寄存器只有5个而已。

### 6.6.2、CLK_SRC寄存器的设置分析

CLK_SRC寄存器其实是用来设置MUX开关的。在这里先将该寄存器设置为全0，主要是bit0和bit4设置为0，表示APLL和MPLL暂时都不启用。

### 6.6.3、CLK_LOCK寄存器的设置分析

设置PLL锁定延时的。官方推荐值为0xFFF，我们设置为0xFFFF。

### 6.6.4、CLK_DIV寄存器的设置分析

0x14131440这个值的含义分析：
	PCLK_PSYS = HCLK_PSYS / 2
	HCLK_PSYS = MOUT_PSYS / 5
	PCLK_DSYS = HCLK_DSYS / 2
	HCLK_DSYS = MOUT_DSYS / 4
	·······
	HCLK_MSYS = ARMCLK / 5
	ARMCLK = MOUT_MSYS / 1

### 6.6.5、PLL倍频的相关计算

（1）我们设置了APLL和MPLL两个，其他两个没有管。
（2）APLL和MPLL设置的关键都是M、P、S三个值，这三个值都来自于官方数据手册的推荐值
（3）M、P、S的设置依赖位运算技术。

***

# 7、串口通信

## 7.1、通信涉及的几个基本概念

### 7.1.1、通信的发展历史

（1）最早通信：烽火台、狼烟；信件；电子通信（电报、电话、网络信号）

（2）通信中最重要的两个方面：信息表示、解析方法 + 信息的传输方法

（3）通信双方事先需要约定好信息的表示方法和解析方法，做到一致，否则信息不能有效传递

（4）信号的传输方法是指经过编码后的通信信息如何在传输介质上传输的过程。

总结：通信过程其实分为3个步骤：首先发送方先按照信息编码方式对有效信息进行编码（编程成可以在通信线路上传输的信号形态），然后编码后的信息在传输介质上进行传输，输送给接收方；最后接收方接收到编码信息后进行解码，解码后得到可以理解的有效信息。

### 7.1.2、电子通信概念1：同步通信和异步通信

（1）同步和异步的区别：首先很多地方都有同步和异步的概念，简单来说就是发送方和接收方按照同一个时钟节拍工作就叫同步，发送方和接收方没有统一的时钟节拍、而各自按照自己的节拍工作就叫异步。

（2）同步通信中，通信双方按照统一节拍工作，所以配合很好；一般需要发送方给接收方发送信息同时发送时钟信号，接收方根据发送方给它的时钟信号来安排自己的节奏。同步通信用在通信双方信息交换频率固定，或者经常通信时。

（3）异步通信又叫异步通知。在双方通信的频率不固定时（有时3ms收发一次，有时3天才收发一次）不适合使用同步通信，而适合异步通信。异步通信时接收方不必一直在意发送方，发送方需要发送信息时会首先给接收方一个信息开始的起始信号，接收方接收到起始信号后就认为后面紧跟着的就是有效信息，才会开始注意接收信息，直到收到发送方发过来的结束标志。

### 7.1.3、电子通信概念2：电平信号和差分信号

（1）电平信号和差分信号是用来描述通信线路传输方式的。也就是说如何在通信线路上表达1和0.

（2）电平信号的传输线中有一个参考电平线（一般是GND），然后信号线上的信号值是由信号线电平和参考电平线的电压差决定。

（3）差分信号的传输线中没有参考电平，所有都是信号线。然后1和0的表达靠信号线之间的电压差。

总结：电平信号的2根通信线之间的电平差异容易受到干扰，传输容易失败；差分信号不容易受到干扰因此传输质量比较稳定，现代通信一般都使用差分信号，电平信号几乎没有了。
总结2：看起来似乎相同根数的通信线下，电平信号要比差分信号要快；但是实际还是差分信号快，因为差分信号抗干扰能力强，因此1个发送周期更短。

### 7.1.4、电子通信概念3：并行接口和串行接口

（1）串行、并行主要是考虑通信线的根数，就是发送方和接收方同时可以传递的信息量的多少

（2）譬如在电平信号下，1根参考电平线+1根信号线可以传递1位二进制；如果我们有3根线（2根信号线+1根参考线）就可以同时发送2位二进制；如果想同时发送8位二进制就需要9根线。

（3）在差分信号下，2根线（彼此差分）可以同时发送1位二进制；如果需要同时发送8位二进制，需要16根线。

总结：听起来似乎并行接口比串行接口要快（串行接口一次只能发送1位二进制，而并行接口一次可以发送多位二进制）要更优秀；但是实际上串行接口才是王道，用的比较广。因为更省信号线，而且对传输线的要求更低、成本更低；而且串行时可以通过提高通信速度来提高总体通信性能，不一定非得要并行。

总结：其实这么多年发展，最终胜出的是：异步、串行、差分，譬如USB和网络通信。

****

## 7.2、串口通信的基本概念

### 7.2.1、串口通信的特点：异步、电平信号、串行

（1）异步：串口通信的发送方和接收方之间是没有统一的时钟信号的。

（2）电平信号：串口通信出现的时间较早，速率较低，传输的距离较近，所以干扰还不太明显，因此当时使用了电平信号传输。后期出现的传输协议都改成差分信号传输了。

（3）串行通信：串口通信每次同时只能传输1个二进制位。

### 7.2.2、RS232电平和TTL电平

（1）电平信号是用信号线电平减去参考线电平得到电压差，这个电压差决定了传输值是1还是0.

（2）在电平信号时多少V代表1，多少V代表0不是固定的，取决于电平标准。譬如RS232电平中-3V～-15V表示1；+3～+15V表示0；TTL电平则是+5V表示1，0V表示0.

（3）不管哪种电平都是为了在传输线上表示1和0.区别在于适用的环境和条件不同。RS232的电平定义比较大，适合干扰大、距离远的情况；TTL电平电压范围小，适合距离近且干扰小的情况。

（4）我们台式电脑后面的串口插座就是RS232接口的，在工业上用串口时都用这个，传输距离小于15米；TTL电平一般用在电路板内部两个芯片之间。

（5）对编程来说，RS232电平传输还是TTL电平是没有差异的。所以电平标准对硬件工程师更有意义，而软件工程师只要略懂即可。（把TTL电平和RS232电平混接是不可以的）

### 7.2.3、波提率

（1）波特率（bandrate），指的是串口通信的速率，也就是串口通信时每秒钟可以传输多少个二进制位。譬如每秒种可以传输9600个二进制位（传输一个二进制位需要的时间是1/9600秒，也就是104us），波特率就是9600.

（2）串口通信的波特率不能随意设定，而应该在一些值中去选择。一般最常见的波特率是9600或者115200（低端单片机如51常用9600，高端单片机和嵌入式SoC一般用115200）.为什么波特率不可以随便指定？主要是因为：第一，通信双方必须事先设定相同的波特率这样才能成功通信，如果发送方和接收方按照不同的波特率通信则根本收不到，因此波特率最好是大家熟知的而不是随意指定的。第二，常用的波特率经过长久发展，就形成了共识，大家常用就是9600或者115200.

### 7.2.4、起始位、数据位、奇偶效验位、停止位

（1）串口通信时，收发是一个周期一个周期进行的，每周期传输n个二进制位。这一个周期就叫做一个通信单元，一个通信单元是由：起始位+数据位+奇偶校验位+停止位组成的。

（2）起始位表示发送方要开始发送一个通信单元；数据位是一个通信单元中发送的有效信息位；奇偶校验位是用来校验数据位，以防止数据位出错的；停止位是发送方用来表示本通信单元结束标志的。

（3）起始位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。

（4）数据位是本次通信真正要发送的有效数据，串口通信一次发送多少位有效数据是可以设定的（一般可选的有6、7、8、9，99%情况下我们都是选择8位数据位。因为我们一般通过串口发送的文字信息都是ASCII码编码的，而ASCII码中一个字符刚好编码为8位。）

（5）奇偶校验位是用来给数据位进行奇偶校验（把待校验的有效数据逐个位的加起来，总和为奇数奇偶校验位就为1，总和为偶数奇偶校验位就为0）的，可以在一定程度上防止位反转。

（6）停止位的定义是串口通信标准事先指定的，是由通信线上的电平变化来反映的。常见的有1位停止位，1.5位停止位，2位停止位等。99%情况下都是用1位停止位。

总结：串口通信时因为是异步通信，所以通信双方必须事先约定好通信参数，这些通信参数包括：波特率、数据位、奇偶校验位、停止位（串口通信中起始位定义是唯一的，所以一般不用选择）

***

## 7.3、串口通信的基本原理

### 7.3.1、单工方向和双工方向

（1）单工就是单方向，双工就是双方同时收发，同时只能但方向但是方向可以改变叫半双工

（2）如果只能A发B收则单工，A发B收或者B发A收（两个方向不能同时）叫半双工，A发B收同时B发A收叫全双工。

### 7.3.2、三根通信线：Rx Tx GND

（1）任何通信都要有信息传输载体，或者是有线的或者是无线的。

（2）串口通信是有线通信，是通过串口线来通信的。

（3）串口通信线最少需要2根（GND和信号线），可以实现单工通信，也可以使用3根通信线（Tx、Rx、GND）来实现全双工。

（4）一般开发板都会引出SoC上串口引脚直接输出的TTL电平的串口（X210开发板没有），插座用插针式插座，每个串口引出的都有3个线（Tx、Rx、GND），可以用这些插座直接连接外部的TTL电平的串口设备。

### 7.3.3、收发双方事先规定好通信参数

（1）串口通信属于基层基本性的通信规约，它自己本身不会去协商通信参数，需要通信前通信双方事先约定好通信参数（一般4个最重要的）

（2）串口通信的任何一个关键参数设置错误，都会导致通信失败。譬如波特率调错了，发送方发送没问题，接收方也能接收，但是接收到全是乱码···

### 7.3.4、信息以二进制流的方式在信道上传输

（1）串口通信的发送方每隔一定时间（时间固定为1/波特率，单位是秒）将有效信息（1或者0）放到通信线上去，逐个二进制位的进行发送。

（2）接收方通过定时（起始时间由读到起始位标志开始，间隔时间由波特率决定）读取通信线上的电平高低来区分发送给我的是1还是0。依次读取数据位、奇偶校验位、停止位，停止位就表示这一个通信单元（帧）结束，然后中间是不定长短的非通信时间（发送方有可能紧接着就发送第二帧，也可能半天都不发第二帧，这就叫异步通信），下来就是第二帧·····

总结：第一，波特率非常重要，波特率错了整个通信就乱套了；数据位、奇偶校验位、停止位也很重要，否则可能认不清数据。第三，通过串口不管发数字、还是文本还是命令还是什么，都要先对发送内容进行编码，编码成二进制再进行逐个位的发送。
(3)串口发送的一般都是字符，一般都是ASCII码编码后的字符，所以一般设置数据位都是8，方便刚好一帧发送1个字符。

### 7.3.5、DB9接口

（1）DB9接口是串口通信早期比较常用的一种规范化接口。

（2）串行通信在早期是计算机与外界通信的主要手段，那时候的计算机都有标准配置的串口以实现和外部通信。那时候就定义了一套标准的串口规约，DB9接口就是标准接口。

（3）DB9接口中有9根通信线，其中3根很重要，为GND、Tx、Rx，必不可少；剩余6根都是和流控有关的，现代我们使用串口都是用来做调试一般都禁用流控，所以这6根没用。

（4）现在一般使用串口时要记得把流控禁止掉，不然可能发生意想不到的问题。

****

## 7.4、x210串行通信接口详解

### 7.4.1、串口的名称

（1）S5PV210的数据手册中串口控制器在section8.1

（2）串口的官方名称叫：universal asynchronous reciver and transmitter，通用异步收发器
英文缩写是uart，中文简称串口。

### 7.4.2、S5PV210的串口控制器工作原理框图

（1）整个串口控制器包含transmitter和receiver两部分，两部分功能彼此独立，transmitter负责210向外部发送信息，receiver负责从外部接收信息到210内部。

（2）总线角度来讲，串口控制器是接在APB总线上的。对我们编程有影响的是：将来计算串口控制器的源时钟时是以APB总线来计算的。

（3）transmitter由发送缓冲区和发送移位器构成。我们要发送信息时，首先将信息进行编码（一般用ASCII码）成二进制流，然后将一帧数据（一般是8位）写入发送缓冲区（从这里以后程序就不用管了，剩下的发送部分是硬件自动的），发送移位器会自动从发送缓冲区中读取一帧数据，然后自动移位（移位的目的是将一帧数据的各个位分别拿出来）将其发送到Tx通信线上。

（4）receiver由接收缓冲区和接收移位器构成。当有人通过串口线向我发送信息时，信息通过Rx通信线进入我的接收移位器，然后接收移位器自动移位将该二进制位保存入我的接收缓冲区，接收完一帧数据后receiver会产生一个中断给CPU，CPU收到中断后即可知道receiver接收满了一帧数据，就会来读取这帧数据。

总结：发送缓冲区和接收缓冲区是关键。发送移位器和接收移位器的工作都是自动的，不用编程控制的，所以我们写串口的代码就是：首先初始化（初始化的实质是读写寄存器）好串口控制器（包括发送控制器和接收控制器），然后要发送信息时直接写入发送缓冲区，要接收信息时直接去接收缓冲区读取即可。可见，串口底层的工作（譬如怎么移位的、譬如起始位怎么定义的、譬如TTL电平还是RS232电平等）对程序员是隐藏的，程序员不用去管。软件工程师对串口操作的接口就是发送/接收缓冲区（实质就是寄存器，操作方式就是读写内存）

（5）串口控制器中有一个波特率发生器，作用是产生串口发送/接收的节拍时钟。波特率发生器其实就是个时钟分频器，它的工作需要源时钟（APB总线来），然后内部将源时钟进行分频（软件设置寄存器来配置）得到目标时钟，然后再用这个目标时钟产生波特率（硬件自动的）。

### 7.4.3、自动控流（AFC：Auto flow control）

（1）为什么需要流控？流控的目的是让串口通信非常可靠，在发送方速率比接收方快的时候流控可以保证发送和接收不会漏掉东西。

（2）现在为什么不用流控？现在计算机之间有更好更高级（usb、internet）的通讯方式，串口已经基本被废弃了。现在串口的用途更多是SoC用来输出调试信息的。由于调试信息不是关键性信息、而且由于硬件发展串口本身速度已经相对慢的要死了，所以硬件都能协调发送和接收速率，因此流控已经失去意义了，所以现在基本都废弃了。

### 7.4.4、FIFO模式和作用

（1）典型的串口设计，发送/接收缓冲区只有1字节，每次发送/接收只能处理1帧数据。这样在单片机中没什么问题，但是到复杂SoC中（一般有操作系统的）就会有问题，会导致效率低下，因为CPU需要不断切换上下文。

（2）解决方案就是想办法扩展串口控制器的发送/接收缓冲区，譬如将发送/接收缓冲器设置为64字节，CPU一次过来直接给发送缓冲区64字节的待发送数据，然后transmitter慢慢发，发完再找CPU再要64字节。但是串口控制器本来的发送/接收缓冲区是固定的1字节长度的，所以做了个变相的扩展，就是FIFO。

（3）FIFO就是first in first out，先进先出。fifo其实是一种数据结构，这里这个大的缓冲区叫FIFO是因为这个缓冲区的工作方式类似于FIFO这种数据结构。

### 7.4.5、DMA模式及其作用

（1）DMA direct memory access，直接内存访问。DMA本来是DSP中的一种技术，DMA技术的核心就是在交换数据时不需要CPU参与，模块可以自己完成。

（2）DMA模式要解决的问题和上面FIFO模式是同一个问题，就是串口发送/接收要频繁的折腾CPU造成CPU反复切换上下文导致系统效率低下。

（3）传统的串口工作方式（无FIFO无DMA）效率是最低的，适合低端单片机；高端单片机上CPU事物繁忙所以都需要串口能够自己完成大量数据发送/接收。这时候就需要FIFO或者DMA模式。FIFO模式是一种轻量级的解决方案，DMA模式适合大量数据迸发式的发送/接收时。

### 7.4.6、IrDA模式及其用法

（1）IrDA其实就是红外，红外就是红外线通信（电视机、空调遥控器就是红外通信的）。

（2）红外通信的原理是发送方固定间隔时间向接收方发送红外信号（表示1或0）或者不发送红外信号（表示0或者1），接收方每隔固定时间去判断有无红外线信号来接收1和0.

（3）分析可知，红外通信和串口通信非常像，都是每隔固定时间发送1或者0（判断1或0的物理方式不同）给接收方来通信。因此210就利用串口通信来实现了红外发送和接收。

（4）210的某个串口支持IrDA模式，开启红外模式后，我们只需要向串口写数据，这些数据就会以红外光的方式向外发射出去（当然是需要一些外部硬件支持的），然后接收方接收这些红外数据即可解码得到我们的发送信息。

### 7.4.7、串行通信与终端的关系

（1）串口通信分为发送/接收2部分。发送方一般不需要（也可以使用）中断即可完成发送，接收方必须（一般来说必须，也可以轮询方式接收）使用中断来接收。

（2）发送方可以选择使用中断，也可以选择不使用中断。使用中断的工作情景是：发送方先设置好中断并绑定一个中断处理程序，然后发送方丢一帧数据给transmitter，transmitter发送耗费一段时间来发送这一帧数据，这段时间内发送方CPU可以去做别的事情，等transmitter发送完成后会产生一个TXD中断，该中断会导致事先绑定的中断处理程序执行，在中断处理程序中CPU会切换回来继续给transmitter放一帧数据，然后CPU切换离开；不使用中断的工作情景是：发送方事先禁止TXD中断（当然也不需要给相应的中断处理程序了），发送方CPU给一帧数据到transmitter，然后transmitter耗费一段时间来发送这帧数据，这段时间CPU在这等着（CPU没有切换去做别的事情），待发送方发送完成后CPU再给它一帧数据继续发送直到所有数据发完。CPU是怎么知道transmitter已经发送完了？原来是有个状态寄存器，状态寄存器中有一个位叫发送缓冲区空标志，transmitter发送完成（发送缓冲区空了）就会给这个标志位置位，CPU就是通过不断查询这个标志位为1还是0来指导发送是否已经完成的。

（3）因为串口通信是异步的，异步的意思就是说发送方占主导权。也就是说发送方随时想发就能发，但是接收方只有时刻等待才不会丢失数据。所以这个差异就导致发送方可以不用中断，而接收方不得不使用中断模式。

### 7.4.8、210串行通信接口的时钟设计

（1）串口通信为什么需要时钟？因为串口通信需要一个固定的波特率，所以transmitter和receiver都需要一个时钟信号。

（2）时钟信号从哪里来？源时钟信号是外部APB总线（PCLK_PSYS，66MHz）提供给串口模块的（这就是为什么我们说串口是挂在APB总线上的），然后进到串口控制器内部后给波特率发生器（实质上是一个分频器），在波特率发生器中进行分频，分频后得到一个低频时钟，这个时钟就是给transmitter和receiver使用的。

（3）串口通信中时钟的设置主要看寄存器设置。重点的有：寄存器源设置（为串口控制器选择源时钟，一般选择为PCLK_PSYS，也可以是SCLK_UART），还有波特率发生器的2个寄存器。

（4）波特率发生器有2个重要寄存器：UBRDIVn和UDIVSLOTn，其中UBRDIVn是主要的设置波特率的寄存器，UDIVSLOTn是用来辅助设置的，目的是为了校准波特率的。

*****

## 7.5、S5PV210串行通信编程实战

### 7.5.1、整个程序流程分析

（1）整个串口通信相关程序包含2部分：uart_init负责初始化串口，uart_putc负责发送一个字节

### 7.5.2、串口控制器的初始化

（1）初始化串口的Tx和Rx引脚所对应的GPIO（查原理图可知Rx和Rx分别对应GPA0_1和GPA0_0）

（2）GPA0CON（0xE0200000），bit[3:0] = 0b0010	bit[7:4] = 0b0010	

（3）初始化这几个关键寄存器UCON0 ULCON0 UMCON0 UFCON0 UBRDIV0 UDIVSLOT0

### 7.5.3、主要的几个寄存器的初始化

（1）ULCON0 = 0x3		// 0校验位、8数据位、1停止位
（2）UCON = 0x5		// 发送和接收都是polling mode
（3）UMCON0 = 0x0		// 禁止modem、afc
（4）UFCON0 = 0x0		// 禁止FIFO模式
（5）UBRDIV0和UDIVSLOT0和波特率有关，要根据公式去算的

### 7.5.4、在C语言中定义访问寄存器的宏

定义好了访问寄存器的宏之后，将来写代码时直接使用即可。

### 7.5.5、串口Tx、Rx对应的GPIO的初始化

给GPA0CON的相应bit位赋值为相应值，用C语言位操作来完成。

### 7.5.6、UCON、ULCON、UMCON、UFCON等主要控制寄存器

依据7.5.3中分析的值进行依次设置即可。

### 7.5.7、波特率的计算和设置

（1）第一步，用PCLK_PSYS和目标波特率去计算DIV_VAL: DIV_VAL = (PCLK / (bps x 16)) ?1

（2）第二步，UBRDIV0寄存器中写入DIV_VAL的整数部分

（3）第三步，用小数部分*16得到1个个数，查表得uBDIVSLOT0寄存器的设置值

### 7.5.8、串口发送和接收函数的编写

（1）写发送函数，主要发送前要用while循环等待发送缓冲区为空才能发送。

### 7.5.9、综合调试

```c
/*
 * @Author       : Enos Ji
 * @Date         : 2021-05-30 12:48:02
 * @LastEditors  : Please set LastEditors
 * @LastEditTime : 2021-05-30 14:56:29
 * @FilePath     : \ubuntu share\x210\1.uart_c\uart.c
 * @Description  : 串口通信
 */
//定义寄存器宏
#define GPA0CON     0xE0200000
#define UCON0       0xE2900004
#define ULCON0      0xE2900000
#define UMCON0      0xE290000c
#define UFCON0      0xE2900008
#define UBRDIV0     0xE2900028
#define UDIVSLOT0   0xE290002c
#define UTRSTAT0    0xE2900010
#define UTXH0       0xE2900020
#define URXH0       0xE2900024

#define rGPA0CON     (*(volatile unsigned int *)GPA0CON)
#define rUCON0       (*(volatile unsigned int *)UCON0)
#define rULCON0      (*(volatile unsigned int *)ULCON0)
#define rUMCON0      (*(volatile unsigned int *)UMCON0)
#define rUFCON0      (*(volatile unsigned int *)UFCON0)
#define rUBRDIV0     (*(volatile unsigned int *)UBRDIV0)
#define rUDIVSLOT0   (*(volatile unsigned int *)UDIVSLOT0)
#define rUTRSTAT0    (*(volatile unsigned int *)UTRSTAT0)
#define rUTXH0       (*(volatile unsigned int *)UTXH0)
#define rURXH0       (*(volatile unsigned int *)URXH0)

//串口初始化程序
void uart_init(void)
{
    //初始化Tx、Rx对应的GPIO引脚
    rGPA0CON &= ~(0xff << 0);            //先将bit0~7清零 
    rGPA0CON |= 0x00000022;             //0b0010,Rx Tx

    //几个关键寄存器的初始化
    rULCON0 = 0x3;
    rUCON0 = 0x5;
    rUMCON0 = 0x0;
    rUFCON0 = 0x0;
    
    //波特率的设置  DIV_VAL = (PCLK / (bps x 16)) −1 
    //PCLk_PSYS 用66MHz算     余数是0.8     
    //rUBRDIV0 = 34;
    //rUDIVSLOT0 = 0xDFDD;        //计算过程就是用余数 0.8*16 = 12.8 就是有12|13个1

    //PCLk_PSYS 用66.7MHz算   余数是0.18
    rUBRDIV0 = 35;
    rUDIVSLOT0 = 0x0888;        //计算过程就是用余数 0.18*16 = 3 就是有3个1  查官方推荐表得出0x0888

    
}

//串口发送程序、发送一个自己
void uart_putc(char c)
{
    //串口发送一个字符，其实就是把一个字节丢到发送缓冲区去
    //因为串口控制器发送1个字节的速度远远低于CPU的速度，所以CPU发送1个字节前必须
    //确认串口控制器当前的缓冲区是空的（意思就是串口已经发完了上一个字节）
    //如果缓冲区非空位为0，此时应该循环
    while(!(rUTRSTAT0 & (1 << 1)));
    rUTXH0 = c;
}

//串口接收程序、轮询方式、接收一个字节
char uart_getc(void)
{
    while(!(rUTRSTAT0 & (1 << 0)));
    return rURXH0;
}
```

****

## 7.6、uart stdio的移植

### 7.6.1、什么是stdio

（1）#include <stdio.h>
（2）stdio：standard input output，标准输入输出
（3）标准输入输出就是操作系统定义的默认的输入和输出通道。一般在PC机的情况下，标准输入指的是键盘，标准输出指的是屏幕。
（4）printf函数和scanf函数可以和底层输入/输出函数绑定，然后这两个函数就可以和stdio绑定起来。也就是说我们直接调用printf函数输出，内容就会被从标准输出输出出去。
（5）在我们这里，标准输出当然不是屏幕了，而是串口。标准输出也不是键盘，而是串口。

### 7.6.2、printf函数的工作原理

（1）printf函数工作时内部实际调用了2个关键函数：一个是vsprintf函数（主要功能是格式化打印信息，最终得到纯字符串格式的打印信息等待输出），另一个就是真正的输出函数putc（操控标准输出的硬件，将信息发送出去）

### 7.6.3、移植printf函数的三种思路

（1）我们希望在我们的开发板上使用printf函数进行（串口）输出，使用scanf函数进行（串口）输入，就像在PC机上用键盘和屏幕进行输入输出一样。因此需要移植printf函数/scanf函数

（2）我们说的移植而不是编写，我们不希望自己完全从新编写而是想尽量借用也有的代码（叫移植）

（3）一般移植printf函数可以有3个途径获取printf的实现源码：最原始最原本的来源就是linux内核中的printk。难度较大、关键是麻烦；稍微简单些的方法是从uboot中移植printf；更简单的方法就是直接使用别人移植好的。

（4）我们课程中使用第三种方法，别人移植好的printf函数来自于友善之臂的Tiny210的裸机教程中提供的。

### 7.6.4、添加链接脚本

在移植后的uart stdio项目中添加link.lds链接脚本，指定连接地址到0xd0020010

### 7.6.5、gcc可变参数及va_arg介绍

（1）printf函数中首先使用了C语言的可变参数va_start/va_arg/va_end；

（2）建议大家先去baidu“C语言可变参数”，然后按照别人的教程、博客实际写几个简单的变参的使用示例，先明白可变参数怎么工作，然后再来分析这里。

### 7.6.6、vsprintf函数详解

printf
	vsprintf
		vsnprintf
			number
vsprintf函数的作用是按照我们的printf传进去的格式化标本，对变参进行处理，然后将之格式化后缓存在一个事先分配好的缓冲区中。
printf后半段调用putc函数将缓冲区中格式化好的字符串直接输出到标准输出。

****

# 8、按键和CPU的中断系统

## 8.1、什么是按键

### 8.1.1、按键的物理特性

（1）平时没人按的时候，弹簧把按键按钮弹开。此时内部断开的。

（2）有人按下的时候，手的力量克服弹簧的弹力，将按钮按下，此时内部保持接通（闭合）状态；如果手拿开，则弹簧作用下按钮又弹开，同时内部又断开。

（3）一般的按键都有4个引脚，这4个引脚成2对：其中一对是常开触点（像上面描述的不按则断开，按下则闭合）；一对是常闭触点（平时不按时是闭合的，按下后是断开的）

### 8.1.2、按键的电学原理（结合原理图分析）

（1）硬件接法：	SW5:GPH0_2	SW6:GPH0_3	SW78910:GPH2_0123

（2）按键的电路连接分析：平时按钮没有按下时，按钮内部断开，GPIO引脚处电压为高电平；当有人按下按钮时，按钮内部导通，外部VDD经过电阻和按钮连接到地，形成回路，此时GPIO引脚处电压就变成了低电平。此时VDD电压全部分压在了电阻上（这个电阻就叫分压电阻，这个电阻不能太小，因为电阻的功率是U*U/R）

（3）总结：按键的工作方法：其实就是按键的按下与弹开，分别对应GPIO的两种电平状态（按下则GPIO为低电平，弹开则GPIO为高电平）。此时SoC内部可以通过检测这个GPIO的电平高低来判断按键有没有被按下，这个判断结果即可作为SoC的输入信号。

### 8.1.3、按键属于输入类设备

（1）按键一般用来做输入设备（由人向SoC发送信息的设备，叫输入设备），由人向SoC发送按键信号（按键信号有2种：按下信号和弹开信号）。

（2）有些设备就是单纯的输入设备，譬如按键、触摸屏等；有些设备就是单纯的输出设备，譬如LCD；还有一些设备是既能输入又能输出的，叫输入输出设备（IO），譬如串口。

### 8.1.4、按键的两种响应方法

（1）SoC处理按键有2中思路：轮询方式和中断方式

（2）轮询方式，就是SoC主动的每隔一段时间就去读取（按键所对应的）GPIO的电平高低，以此获得按键信息

（3）中断方式，就是SoC事先设定好GPIO触发的中断所对应的中断程序ISR，当外部按键按下或者弹开时会自动触发GPIO对应的外部中断，导致ISR执行，从而自动处理按键信息。

****

## 8.2、轮询方式处理按键

### 8.2.1、x210开发板的按键接法

（1）查原理图，找到按键对应的GPIO：SW5:GPH0_2	SW6:GPH0_3	SW78910:GPH2_0123

（2）原理图上可以看出：按下时是低电平，弹起时是高电平

### 8.2.2、按键对应的GPIO的模式设置

（1）按键接到GPIO上，按键按下还是弹起，决定外部电路的接通与否，从而决定这个GPIO引脚的电压是高还是低；这个电压可以作为这个GPIO引脚的输入信号，此时GPIO配置为输入模式，即可从SoC内部读取该引脚的电平为1还是0（1对应高电平，0对应低电平）。

（2）GPH0CON(0xE0200C00) GPH2DAT(0xE0200C04) GPH2CON(0xE0200C40) GPH2DAT(0xE0200C44)

（3）应该在CON寄存器中将GPIO设置为input模式，然后去读取DAT寄存器（读取到的相应位的值为1表示外部是高电平（对应按键弹起），读取到的位的值为0表明外部是低电平（按键按下））

### 8.2.3、轮询方式处理按键的程序流程

（1）第一步，先初始化GPIO模式为input；
（2）第二步，循环读取GPIO的电平值，然后判断有无按键按下

### 8.2.4、程序详解

```c
//定义操作的寄存器的宏
#define GPH0CON		0xE0200C00
#define GPH0DAT		0xE0200C04

#define GPH2CON		0xE0200C40
#define GPH2DAT		0xE0200C44

#define rGPH0CON	(*(volatile unsigned int *)GPH0CON)
#define rGPH0DAT	(*(volatile unsigned int *)GPH0DAT)
#define rGPH2CON	(*(volatile unsigned int *)GPH2CON)
#define rGPH2DAT	(*(volatile unsigned int *)GPH2DAT)

//初始化按键
void key_init(void)
{
    //将GPH0CON寄存器的bit8~15设置为0，输入模式
    rGPH0CON &= ~(0xFF<<8);

    //将GPH2CON寄存器的bit0~15设置为0，输入模式
    rGPH2CON &= ~(0xFFFF<<0);

}

//轮询按键
void key_polling(void)
{
    //依次区读出每个GPIO的值，判断其值为1还是0，1则按键按下，2则按键弹起
    
    //反复循环判断有无按键
    while(1)
    {
        
        if(rGPH0DAT & (1<<2))
        {
            //为1，说明没有按键
            led_off();

        }
        else
        {
            //为0，说明有按键
            led1();
            
        }
        if(rGPH0DAT & (1<<3))
        {
            //为1，说明没有按键
            led_off();

        }
        else
        {
            //为0，说明有按键
            led2();
            
        }
    }

}
```

****

## 8.3、串口输出和按键消抖

### 8.3.1、基于串口标准输出的按键调试

（1）以之前的串口stdio的工程为基础来移植添加轮询方式按键处理。

（2）注意USB下载方式可能有错误（有可能不下载，也有可能下载了执行不对），解决方案是用SD卡启动来替代。

### 8.3.2、什么是按键消抖

（1）按键这种物理器件本身会有抖动信号，抖动信号指的是在电平由高到低（也就是按键按下时）或者电平由低到高（也就是按键弹起时）过程中，电平的变化不是立刻变化，而是经过了一段时间的不稳定期才完成变化，在这个不稳定期间电平可能会时高时低反复变化，这个不稳定期就叫抖动（抖动期内获取按键信息是不可靠的，要想办法消抖）。

（2）什么叫消抖？消抖就是用硬件或者软件方法来尽量减小抖动期对按键获取的影响。消抖常用2种思路：第一是硬件消抖，消抖思路就是尽量减小抖动时间，方法是通过硬件添加电容等元件来减小抖动；第二是软件消抖，消抖思路是发现一次按键按下/弹起事件后，不立即处理按键，而是延时一段时间（一般10～20ms，这就是消抖时间）后再次获取按键键值，如果此次获取和上次一样是按下/弹起，那就认为真的按下/弹起了。

（3）一般比较精密需要的时候，需要硬件消抖和软件消抖一起配合。

### 8.3.3、消抖的程序

```c
//定义操作的寄存器的宏
#define GPH0CON		0xE0200C00
#define GPH0DAT		0xE0200C04

#define GPH2CON		0xE0200C40
#define GPH2DAT		0xE0200C44

#define rGPH0CON	(*(volatile unsigned int *)GPH0CON)
#define rGPH0DAT	(*(volatile unsigned int *)GPH0DAT)
#define rGPH2CON	(*(volatile unsigned int *)GPH2CON)
#define rGPH2DAT	(*(volatile unsigned int *)GPH2DAT)

//初始化按键
void key_init(void)
{
    //将GPH0CON寄存器的bit8~15设置为0，输入模式
    rGPH0CON &= ~(0xFF<<8);

    //将GPH2CON寄存器的bit0~15设置为0，输入模式
    rGPH2CON &= ~(0xFFFF<<0);

}

//延时20ms
void delay20ms(void)
{
    //象征意义不是准确的20ms
    int i,j;
    for(i = 0; i < 100; i++)
    {
        for(j = 0; j < 100; j++)
        {
            i * j;
        }
    }
}


//轮询按键
void key_polling(void)
{
    //依次区读出每个GPIO的值，判断其值为1还是0，1则按键按下，2则按键弹起
    
    //反复循环判断有无按键
    while(1)
    {
        
        if(rGPH0DAT & (1<<2))
        {
            //为1，说明没有按键
            led_off();

        }
        else
        {   
            //先延时20ms
            delay20ms();
            //再次判断按键是否为0
            if(!(rGPH0DAT & (1<<2)))
            {
                //为0，说明有按键
                led1();
                printf("key left\n");
            }
            
        }
        if(rGPH0DAT & (1<<3))
        {
            //为1，说明没有按键
            led_off();
            printf("key down\n");
        }
        else
        {
            //为0，说明有按键
            led2();
            
        }

    }

}
```

***

## 8.4、S5PV210的中断体系介绍

### 8.4.1、什么是中断

（1）中断的发明是用来解决宏观上的并行需要的。宏观就是从整体上来看，并行就是多件事情都完成了。

（2）微观上的并行，就是指的真正的并行，就是精确到每一秒甚至每一刻，多个事情都是在同时进行的。宏观上面的并行并不等于微观的并行，有时候宏观上是并行的，微观上是串行的。

（3）例子中一个人在看电影，快递来了暂停电影跑去收快递，收完快递继续回来看电影，这个例子就是宏观上的并行和微观上的串行。例子中一个人等同于SoC中1个CPU（也就是单核CPU），这个CPU看电影就不能收快递，收快递就不能看电影（也就是说不能真正的并行）。单核心CPU在微观角度是串行的，但是因为CPU很快，所以在宏观看来可以并行。

（4）上例中大部分时间在看电影，中间少量时间去收快递，那么类比于CPU来说，看电影就应该是CPU的常规任务，而收快递则应该是中断例程。也就是说CPU平时一直在进行看电影任务，等快递来了（中断发生了）快递员（类似于中断源）会打电话叫人去收快递（中断源会触发中断通知CPU去处理中断），人收到电话（CPU收到中断信号）后会暂定电影（CPU保存常规任务的现场）跑去收快递（CPU去执行中断处理程序ISR处理中断），收完快递（执行完ISR）回来继续看电影（CPU恢复常规任务的现场，继续执行常规任务）

（5）为什么需要中断？因为单核CPU实际无法并行的，但是通过中断机制，可以实现假并行（宏观上的并行，微观上实际还是串行的）。

### 8.4.2、SoC堆对中断的实现机制：异常向量表

（1）异常向量表是CPU中某些特定地址的特定定义。当中断发生的时候，中断要想办法通知CPU去处理中断，怎么做到？这就要靠异常向量表。

（2）在CPU设计时，就事先定义了CPU中一些特定地址作为特定异常的入口地址（譬如定义0x00000000地址为复位异常向量地址，则发生复位异常时CPU会自动跳转到0x00000000地址去执行指令。又譬如外部中断对应的异常向量地址为0x30000008，则发生外部中断后，CPU会硬件自动跳转到0x30000008地址去执行指令。）如

（3）以上讲的是CPU硬件设计时对异常向量表的支持，下来就需要软件支持了。硬件已经决定了发生什么异常CPU自动跳转PC到哪个地址去执行，软件需要做的就是把处理这个异常的代码的首地址填入这个异常向量地址。

### 8.4.3、S5PV210的异常向量表

（1）异常向量表在2.14节讲过

（2）异常向量表中各个向量的相对位置是固定的，但是他们的起始地址是不固定的，各种SoC可以不一样，而且复杂ARM中还可以让用户来软件设置这个异常向量表的基地址。

（3）扩展到所有架构的CPU中：所有架构（譬如51单片机、PIC单片机）的CPU实现中断都是通过异常向量表实现的，这个机制是不变的；但是不同CPU异常向量表的构造和位置是不同的。

### 8.4.4、异常和中断的区别和联系

（1）针对SoC来说，发生复位、软中断、中断、快速中断、取指令异常、数据异常等，我们都统一叫异常。所以说：中断其实是异常的一种。

（2）异常的定义就是突发事件，打断了CPU的正常常规业务，CPU不得不跳转到异常向量表中去执行异常处理程序；中断是异常的一种，一般特指SoC内的内部外设产生的打断SoC常规业务，或者外部中断（SoC的GPIO引脚传回来的中断）。

****

## 8.5、异常向量表的编程处理

### 8.5.1、像内存一样去访问异常向量表

（1）S5PV210的异常向量表可以改变（在CP15协处理器中），以适应操作系统的需求。但是目前系统刚启动时，此时DRAM尚未初始化，程序都在SRAM中运行。210在iRAM中设置了异常向量表，供暂时性使用。

（2）查210的iROM application note文档中iRAM的地址分配，可知，iRAM中的异常向量表起始地址为0xD0037400。知道了异常向量表的起始地址后，各个异常对应的入口就很好知道了。

### 8.5.2、函数名的实质就是函数的首地址

（1）函数名在C语言中的理解方法和变量名其实没区别。编译器会把这个函数的函数体对应的代码段和这个函数的函数名（实质是符号）对应起来，等我们在使用这个函数名符号时，编译器会将函数的函数体实际上做替换。因为函数体都不止4字节，而函数名这个符号只能对应1个地址，所以实际对应的是函数体那一个代码段的首地址。

（2）拿C语言中的语法来讲，函数名就是这个函数的函数指针。

总结：当我们将异常处理程序的首地址和异常向量表绑定起来后，异常处理初步阶段就完成了。到目前可以保证相应异常发生后，硬件自动跳转到对应异常向量表入口去执行时，可以执行到我们事先绑定的函数。

### 8.5.3、中断处理要先在汇编中进行

（1）中断处理要注意保护现场（中断从SVC模式来，则保存SVC模式下的必要寄存器的值）和恢复现场（中断处理完成后，准备返回SVC模式前，要将保存的SVC模式下的必要寄存器的值恢复回去，不然到了SVC模式后寄存器的值乱了，SVC模式下原来正在进行的常规任务就被你搞坏了）

（2）保存现场包括：第一：设置IRQ栈；第二，保存LR；第三，保存R0～R12

（3）为什么要保存LR寄存器？要考虑中断返回的问题。中断ISR执行完后如何返回SVC模式下去接着执行原来的代码。中断返回其实取决于我们进入中断时如何保存现场。中断返回时关键的2个寄存器就是PC和CPSR。所以我们在进入IRQ模式时，应该将SVC模式下的下一句指令的地址（中断返回地址）和CPSR保存起来，将来恢复时才可以将中断返回地址给PC，将保存的CPSR给CPSR。

（4）中断返回地址就保存在LR中，而CPSR（自动）保存在（IRQ模式下的）SPSR中

### 8.5.4、汇编保存现场和恢复现场

（1）保护现场关键是保存：中断处理程序的返回地址，r0-r12（cpsr是自动保存的）

（2）恢复现场主要是恢复：r0-r12，pc，cpsr

****

## 8.6、S5PV210的向量中断控制器

### 8.6.1、异常处理的2个阶段

（1）可以将异常处理分为2个阶段来理解。第一个阶段是异常向量表跳转；第二个阶段就是进入了真正的异常处理程序irq_handler之后的部分。

### 8.6.2、中断处理的第一阶段（异常向量表阶段）处理。

（1）第一个阶段之所以能够进行，主要依赖于CPU设计时提供的异常向量表机制。第一个阶段的主要任务是从异常发生到响应异常并且保存/恢复现场、跳转到真正的异常处理程序处。

（2）第二个阶段的目的是识别多个中断源中究竟哪一个发生了中断，然后调用相应的中断处理程序来处理这个中断。SoC支持很多个（低端CPU列如2440中有30多个，210中有100多个）中断，这么多中断irq在第一阶段走的是一条路，都会进入irq_handler这个函数，我们在这个函数中要去区分究竟是哪个中断发生了，然后再去调用该中断对应的isr

### 8.6.2、对比S3C2440的第二阶段处理过程

（1）第一个问题，怎么找到具体是哪个中断：S3C2440的中断控制器中有一个寄存器（32位的），寄存器的每一个位对应一个中断源（为了解决支持更多中断源，2440又设计了一个子中断机制。在一级中断寄存器中有一些中断是共用的一个bit位，譬如AC97和WDT。对于共用中断，用子中断来区分究竟是哪一个发生了中断）

（2）第二个问题，怎么找到对应的isr的问题：首先给每个中断做了个编号，进入isr_handler之后先通过查阅中断源寄存器和子中断寄存器（中哪一位为1）确定中断的编号，然后用这个编号去isr数组（isr数组是中断初始化时事先设定好的，就是把各个中断的isr的函数名组成一个数组，用中断对应的编号作为索引来查询这个数组）中查阅得到isr地址。

评价：2440的中断处理设计不是特别优秀：第一个过程中使用子中断搞成2级的很麻烦；第二个过程中计算中断编号是个麻烦事，很耗费时间。而中断处理的时间是很宝贵的（系统有一个性能指标，叫实时性。实时性就是中断发生到响应的时间，这个时间越短越好。）

### 8.6.3、S5PV210的第二阶段处理过程

（1）第一个问题，怎么找到具体是哪个中断：S5PV210中因为支持的中断源很多，所以直接设计了4个中断寄存器，每个32位，每位对应一个中断源。（理论上210最多支持128个中断，实际支持不足128个，有些位是空的）；210没有子中断寄存器，每个中断源都是并列的。当中断发生时，在irq_handler中依次去查询4个中断源寄存器，看哪一个的哪一位被置1，则这个位对应的寄存器就发生了中断，即找到了中断编号。

（2）第二个问题，怎么找到对应的isr的问题：210中支持的中断源多了很多，如果还使用2440的那一套来寻找isr地址就太慢了，太影响实时性了。于是210开拓了一种全新的寻找isr的机制。210提供了很多寄存器来解决每个中断源对应isr的寻找问题，具体寻找过程和建立过程见下节，实现的效果是当发生相应中断时，硬件会自动的将相应isr推入一定的寄存器中，我们软件只要去这个寄存器中执行函数就行了。

### 8.6.4、总结：第一阶段都相同，第二阶段各不同

（1）第一阶段（异常向量表阶段）2440和210几乎是完全相同的。实际上几乎所有的CPU在第一阶段都是相同的。

（2）第二阶段就彼此不同了。各个SoC根据自己对实时性的要求，和支持的中断源的多少，各自发明了各自处理中断，找到中断编号，进一步找到对应isr地址的方式。

****

## 8.7、S5PV210中断处理的主要寄存器

### 8.71、VICnINTENABLE和VICnINTENCLEAR

（1）VICnINTENABLE 对应interrupt enable，INTENCLEAR对应interrupt enable clear

（2）INTENABLE寄存器负责相应的中断的使能，INTENCLEAR寄存器负责相应的中断的禁止。

（2）当我们想使能（意思就是启用这个中断，意思就是当硬件产生中断时CPU能接收的到）某个中断时，只要在这个中断编号对应的VICnINTENABLE的相应bit位写1即可（注意这个位写1其他位写0对其他位没有影响）；如果我们想禁止某个中断源时，只要向VICnINTENCLEAR中相应的位写1即可。

注意：这里的设计一共有2种：有些CPU是中断使能和禁止是一个寄存器位，写1就使能写0就静止（或者反过来写1就进制写0就使能），这样的中断使能设计就要非常小心，要使用我们之前说过的读改写三部曲来操作；另一种就是使能和禁止分开为2个寄存器，要使能就写使能寄存器，要禁止就写禁止寄存器。这样的好处是我们使能/禁止操作时不需要读改写，直接写即可。

### 8.7.2、VICnINTSELECT

（1）设置各个中断的模式为irq还是fiq。一般都设置成irq

（2）IRQ和FIQ究竟有何区别。210中支持2种中断，irq和fiq。irq是普通中断，fiq是快速中断。快速中断提供一种更快响应处理的中断通道，用于对实时性要求很高的中断源。fiq在CPU设计时预先提供了一些机制保证fiq可以被快速处理，从而保证实时性。fiq的限制就是只能有一个中断源被设置为fiq，其他都是irq。

（3）CPU如何保证fiq比irq快？有2个原因：第一，fiq模式有专用的r8～r12，因此在fiq的isr中可以直接使用r8-r12而不用保存，这就能节省时间；第二，异常向量表中fiq是最后一个异常向量入口。因此fiq的isr不需要跳转，可以直接写在原地，这样就比其他异常少跳转一次，省了些时间。

### 8.7.3、VICnIRQSTATUS和VICnFIQSTATUS

（1）中断状态寄存器，是只读的。当发生了中断时，硬件会自动将该寄存器的对应位置为1，表示中断发生了。软件在处理中断第二阶段的第一阶段，就是靠查询这个寄存器来得到中断编号的。

### 8.7.4、VICnVECTPRIORITY0～VICnVECTPRIORITY31

（1）中断优先级设置寄存器，设置多个中断同时发生时先处理谁后处理谁的问题。一般来说高优先级的中断可以打断低优先级的中断，从而嵌套处理中断。当然了有些硬件/软件可以设置不支持中断嵌套。

### 8.7.5、VICnVECTADDR0～VICnVECTADDR31、VICnADDR

（1）这三个寄存器和210中断处理第二阶段的第二阶段有关。

（2）VICnVECTADDR0到31这32个寄存器分别用来存放真正的各个中断对应的isr的函数地址。相当于每一个中断源都有一个VECTADDR寄存器，程序员在设置中断的时候，把这个中断的isr地址直接放入这个中断对应的VECTADDR寄存器即可。

（3）VICnADDR这个寄存器是只需要读的，它里面的内容是由硬件自动设置的。当发生了相应中断时，硬件会自动识别中断编号，并且会自动找到这个中断的VECTADDR寄存器，然后将其读出复制到VICnADDR中，供我们使用。这样的设计避免了软件查找中断源和isr，节省了时间，提高了210的中断响应速度。

****

## 8.8、S5PV210中断处理的编程实践

### 8.8.1、中断控制器初始化

主要工作有：第一阶段绑定异常向量表到异常处理程序；禁止所有中断源；选择所有中断类型为IRQ；清理VICnADDR寄存器为0.

### 8.8.2、中断的禁止与使能

思路是先根据中断号判断这个中断属于VIC几，然后在用中断源减去这个VIC的偏移量，得到这个中断号在本VIC中的偏移量，然后1<<x位，写入相应的VIC的INTENABLE/INTENCLEAR寄存器即可。

### 8.8.3、绑定自己实现的isr到VICnVECTADDR

（1）搞清楚2个寄存器的区别：VICnVECTADDR和VICnADDR

（2）VICVECTADDR寄存器一共有4×32个，每个中断源都有一个VECTADDR寄存器，我们应该将自己为这个中断源写的isr地址丢到这个中断源对应的VECTADDR寄存器中即可。

### 8.8.4、真正的中断处理程序如何获取isr

（1）当发生中断时，硬件会自动把相应中断源的isr地址从VICnVECTADDR寄存器中推入VICnADDR寄存器中，所以我们第二阶段的第二阶段isr_handler中，只需要到相应的VICnADDR中去拿出isr地址，调用执行即可。

总结：第4步绑定isr地址到VICnVECTADDR和第5步中断发生时第二阶段的第二阶段如何获取isr地址，这两步是相关的。这两个的结合技术，就是我们一直在说的210的硬件自动寻找isr的机制。

整个中断的流程梳理：
整个中断的工作分为2部分：
第一部分是我们为中断响应而做的预备工作：
	1. 初始化中断控制器
	2. 绑定写好的isr到中断控制器
	3. 相应中断的所有条件使能
	第二部分是当硬件产生中断后如何自动执行isr：
	1. 第一步，经过异常向量表跳转入IRQ/FIQ的入口
	2. 第二步，做中断现场保护（在start.S中），然后跳入isr_handler
	3. 第三步，在isr_handler中先去搞清楚是哪个VIC中断了，然后直接去这个VIC的ADDR
				寄存器中取isr来执行即可。
	4. 第四步，isr执行完，中断现场恢复，直接返回继续做常规任务。

****

## 8.9、外部中断

### 8.9.1、什么是外部中断？数据手册在哪里？

（1）SoC支持的中断类型中有一类叫外部中断。内部中断就是指的中断源来自于SoC内部（一般是内部外设），譬如串口、定时器等部件产生的中断；外部中断是SoC外部的设备，通过外部中断对应的GPIO引脚产生的中断。

（2）按键在SoC中就使用外部中断来实现。具体实现方法是：将按键电路接在外部中断的GPIO上，然后将GPIO配置为外部中断模式。此时人通过按按键改变按键电路的电压高低，这个电压高低会触发GPIO对应的外部中断，通过引脚传进去给CPU处理。

（3）外部中断相关的介绍和寄存器都在2.2.6章节（属于GPIO部分）

### 8.9.2、电平触发和边沿触发

（1）外部中断的触发模式主要有2种：电平触发和边沿触发。

（2）电平触发就是说GPIO上的电平只要满足条件，就会不停触发中断。电平触发分为高电平触发和低电平触发。电平触发的特点是，只要电平满足条件就会不停触发中断。

（3）边沿触发分为上升沿触发、下降沿触发和双边沿触发三种。边沿触发不关心电平常规状态，只关心电平变化的瞬间（边沿触发不关心电平本身是高还是低，只关心变化是从高到低还是从低到高的这个过程）。

分析按键的工作：如果我们关注的是按键按下和弹起这两个事件本身，那么应该用边沿触发来处理按键；如果我们关心的是按键按下/弹起的那一段时间，那么应该用电平触发。

### 8.9.3、关键寄存器：CON、PEND、MASK

（1）外部中断的主要配置寄存器有3个：EXT_CON、EXT_PEND、EXT_MASK

（2）EXT_CON配置外部中断的触发方式。触发方式就是说外部电平怎么变化就能触发中断，也就是说这个外部中断产生的条件是什么

（3）EXT_PEND寄存器是中断挂起寄存器。这个寄存器中每一位对应一个外部中断，平时没有中断时值为0。当发生了中断后，硬件会自动将这个寄存器中该中断对应的位置1，我们去处理完这个中断后应该手工将该位置0。这个PEND寄存器的位就相当于是一个标志，如果发生了中断但是我们暂时忙来不及去处理时，这个位一直是1（这就是挂起），直到我有空了去处理了这个中断才会手工清除（写代码清除）这个挂起位表示这个中断被我处理了。

（4）EXT_MASK寄存器就是各个外部中断的使能/禁止开关。

分析X210开发板的按键对应的EINT编号：
EINT2、EINT3、EINT16、EINT17、EINT18、EINT19

*****

## 8.10、中断方式处理按键编程实践

### 8.10.1、外部中断对应的GPIO模式设置

### 8.10.2、中断触发模式设置

### 8.10.3、中断允许、清挂起

### 8.10.4、中断处理程序isr编写

### 8.10.5、总结对比：轮询方式处理按键和中断方式的差异

*****

# 9、定时器、看门狗和RTC

## 9.1、什么是定时器（timer）

### 9.1.1、定时器是SoC中常见外设

（1）定时器与计数器。计数器是用来计数的（每隔一个固定时间会计一个数）；因为计数器的计数时间周期是固定的，因此到了一定时间只要用计数值×计数时间周期，就能得到一个时间段，这个时间段就是我们定的时间（这就是定时器了）。

（2）定时器/计数器作为SoC的外设，主要用来实现定时执行代码的功能。定时器相对于SoC来说，就好象闹钟相对于人来说意义一样。

### 9.1.2、定时器有什么用

（1）定时器可以让SoC在执行主程序的同时，可以（通过定时器）具有计时功能，到了一定时间（计时结束）后，定时器会产生中断提醒CPU，CPU会去处理中断并执行定时器中断的ISR。从而去执行预先设定好的事件。

（2）定时器就好象是CPU的一个秘书一样，这个秘书专门管帮CPU来计时，并到时间后提醒CPU要做某件事情。所以CPU有了定时器之后，只需预先把自己xx时间之后必须要做的事情绑定到定时器中断ISR即可，到了时间之后定时器就会以中断的方式提醒CPU来处理这个事情。

### 9.1.3、定时器的原理

（1）定时器计时其实是通过计数来实现的。定时器内部有一个计数器，这个计数器根据一个时钟（这个时钟源来自于ARM的APB总线，然后经过时钟模块内部的分频器来分频得到）来工作。每隔一个时钟周期，计数器就计数一次，定时器的时间就是计数器计数值×时钟周期。

（2）定时器内部有1个寄存器TCNT，计时开始时我们会把一个总的计数值（譬如说300）放入TCNT寄存器中，然后每隔一个时钟周期（假设为1ms）TCNT中的值会自动减1（硬件自动完成，不需要CPU软件去干预），直到TCNT中减为0的时候，TCNT就会触发定时器中断。

（3）定时时间是由2个东西共同决定的：一个是TCNT中的计数值，一个是时钟周期。譬如上例中，定时周期就为300×1ms = 300ms。

### 9.1.4、定时器和看门狗、RTC、蜂鸣器的关系

（1）这几个东西都是和时间有关的部件。

（2）看门狗其实就是一个定时器，只不过定时时间到了之后不只是中断，还可以复位CPU

（3）RTC是实时时钟，它和定时器的差别就好象闹钟（定时器）和钟表（RTC）的差别一样。

（4）蜂鸣器是一个发声设备，在ARM里面蜂鸣器是用定时器模块来驱动的。

****

## 9.2、S5PV210中的定时器

在S5PV210内部，一共有4类定时器件。这4类定时器件的功能、特征是不同的。

### 9.2.1、PWM定时器

（1）这种是最常用的，平时所说的定时器一般指的是这个。像简单单片机（譬如51单片机）中的定时器也是这类。

（2）为什么叫PWM定时器，因为一般SoC中产生PWM信号都是靠这个定时器模块的。

### 9.2.2、系统定时器

（1）系统（指的是操作系统）定时器，系统定时器也是用来产生固定时间间隔（TCNT×时钟周期）信号的，称为systick，这个systick用来给操作系统提供tick信号。

（2）产生systick作为操作系统的时间片（time slice）的。

（3）一般做操作系统移植的时候，这里不会由我们自己来做，一般原厂提供的基础移植部分就已经包含了。

### 9.2.3、看门狗定时器

（1）看门狗定时器本质上也是一个定时器，和上面2个没有任何本质区别。

（2）看门狗定时器可以设置在时间到了的时候产生中断，也可以选择发出复位信号复位CPU。

（3）看门狗定时器在实践中应用很多，尤其是工业领域（环境复杂、干扰多）机器容易出问题，而且出问题后后果很严重，此时一般都会用看门狗来进行系统复位。

### 9.2.4、实时时钟RTC（real time clock）

（1）区分时间段和时间点。时间段是相对的，两个时间点相减就会得到一个时间段；而时间点是绝对的，是绝无仅有的一个时间点。

（2）定时器关注的是时间段（而不是时间点），定时器计时从开启定时器的那一刻开始，到定的时间段结束为止产生中断；RTC中工作用的是时间点（xx年x月x日x时x分x秒星期x）。

（3）RTC和定时器的区别，就相当于是钟表和闹钟的区别。

*****

## 9.3、S5PV210的PWM定时器

### 9.3.1、为什么叫PWM定时器

（1）叫定时器说明它本质上的原理是定时器

（2）叫PWM定时器，是因为这个定时器天然是用来产生PWM波形的。

### 9.3.2、PWM定时器介绍

（1）S5PV210有5个PWM定时器。其中0、1、2、3各自对应一个外部GPIO，可以通过这些对应的GPIO产生PWM波形信号并输出；timer4没有对应的外部GPIO（因此不是为了生成PWM波形而是为了产生内部定时器中断而生的）

（2）S5PV210的5个PWM定时器的时钟源为PCLK_PSYS，timer0和timer1共同使用一个预分频器、timer2、3、4共同使用一个预分频器；每个timer有一个专用的独立的分频器；预分频器和分频器构成了2级分频系统，将PCLK_PSYS两级分频后生成的时钟供给timer模块作为时钟周期。

### 9.3.3、S5PV210的PWM定时器框图简介

（1）关键点：时钟源、预分频器、分频器、TCMPB&TCNTB、dead zone

### 9.3.4、预分频器和分频器

（1）两级分频是串联（级联）的，所以两级分频的分频数是相乘的。

（2）两级分频的分频系数分别在TCFG0和TCFG1两个寄存器中设置。

（3）预分频器有2个，prescaler0为timer0&timer1共用；prescaler1为timer2、3、4共用；两个prescaler都是8个bit位，因此prescaler value范围为0～255；所以预分频器的分频值范围为1～256（注意实际分频值为prescaler value + 1）。

（4）分频器实质上是一个MUX开关，多选一开关决定了走哪个分频系数路线。可以选择的有1/1，1/2，1/4，1/8，1/16等。

（5）计算一下，两级分频下来，分频最小为1/1（也可能是1/2），最大分频为1/256×16（1/4096）.

（6）在PCLK_PSYS为66MHz的情况下（默认时钟设置就是66MHz的），此时两级分频后的时钟周期范围为0.03us到62.061us；再结合TCNTB的值的设置（范围为1～2的32次方），可知能定出来的时间最长为266548.27s（折合74小时多，远远够用了）。

### 9.3.5、TCNT&TCMP、TCNTB&TCMPB、TCNTO

（1）TCNT和TCNTB是相对应的，TCNTB是有地址的寄存器，供程序员操作；TCNT在内部和TCNTB相对应，它没有寄存器地址，程序员不能编程访问这个寄存器。

（2）TCNT寄存器功能就是用来减1的，它是内部的不能读写；我们向TCNT中写要通过TCNTB往进写；读取TCNT寄存器中的值要通过读取相对应的TCNTO寄存器。

（3）工作流程就是：我们事先算好TCNT寄存器中开始减的那个数（譬如300），然后将之写入TCNTB寄存器中，在启动timer前，将TCNTB中的值刷到TCNT寄存器中（有一位寄存器专门用来操作刷数据过去的），刷过去后就可以启动定时器开始计时；在计时过程中如果想知道TCNT寄存器中的值减到多少了，可以读取相应的TCNTO寄存器来得知。

（4）定时功能只需要TCNT、TCNTB两个即可；TCNTO寄存器用来做一些捕获计时；TCMPB用来生成PWM波形。

### 9.3.6、自动重载和双缓冲（auto-reload and double buffering）

（1）定时器工作的时候，一次定时算一个工作循环。定时器默认是单个循环工作的，也就是说定时一次，计时一次，到期中断一次就完了。下次如果还要再定时中断，需要另外设置。

（2）但是现实中用定时器来做的时候往往是循环的，最简单最笨的方法就是写代码反复重置定时器寄存器的值（在每次中断处理的isr中再次给TCNTB中赋值，再次刷到TCNT中再次启动定时器），早期的单片机定时器就是这样的；但是现在的高级SoC中的定时器已经默认内置了这种循环定时工作模式，就叫自动装载（auto-reload）机制。

（3）自动装载机制就是当定时器初始化好开始计时后再不用管了，他一个周期到了后会自己从TCNTB中再次装载值到TCNT中，再次启动定时器开始下个循环。

### 9.3.7、什么是PWM？

（1）PWM(pulse wide modulation 脉宽调制)

（2）PWM波形是一个周期性波形，周期为T，在每个周期内波形是完全相同的。每个周期内由一个高电平和一个低电平组成。

（3）PWM波形有2个重要参数：一个是周期T，另一个是占空比duty（占空比就是一个周期内高电平的时间除以周期时间的商）。

（4）对于一个PWM波形，知道了周期T和占空比duty，就可以算出这个波形的所有细节。譬如高电平时间为T*duty，低电平时间为T*(1-duty)。

（5）PWM波形有很多用处，譬如通信上用PWM来进行脉宽调制对基波进行载波调制；在发光二极管LED照明领域可以用PWM波形来调制电流进行调光；用来驱动蜂鸣器等设备。

### 9.3.8、PWM波形的生成原理

（1）PWM波形其实就是用时间来控制电平高低，所以用定时器来实现PWM波形是天经地义的。

（2）早期的简单单片机里（譬如51单片机）是没有专用的PWM定时器的，那时候我们需要自己结合GPIO和定时器模块来手工生产PWM波形（流程是这样：先将GPIO引脚电平拉高、同时启动定时器定T*duty时间，时间到了在isr中将电平拉低，然后定时T*(1-duty)后再次启动定时器，然后时间到了后在isr中将电平拉高，然后再定时T*duty时间再次启动定时器····如此循环即可得到周期为T，占空比为duty的PWM波形）。

（3）后来因为定时器经常和PWM产生纠结一起，所以设计SoC的时候就直接把定时器和一个GPIO引脚内部绑定起来了，然后在定时器内部给我们设置了PWM产生的机制，可以更方便的利用定时器产生PWM波形。此时我们利用PWM定时器来产生PWM波形再不用中断了。绑定了之后坏处就是GPIO引脚是固定的、死板的、不能随便换的；好处是不用进入中断isr中，直接可以生成PWM。

（4）在S5PV210中，PWM波形产生有2个寄存器很关键，一个是TCNTB、一个是TCMPB。其中，TCNTB决定了PWM波形的周期，TCMPB决定了PWM波形的占空比。

（5）最终生成的PWM波形的周期是：TCNTB×时钟周期（PCLK_PSYS经过两极分频后得到的时钟周期）。注意这个周期是PWM中高电平+低电平的总时间，不是其中之一。

（6）最终生成的PWM波形的占空比是：TCMPB/TCNTB

### 9.3.9、输出电平翻转器

（1）PWM定时器可以规定：当TCNT>TCMPB时为高电平，当TCNT<TCMPB时为低电平。也可以规定：当TCNT>TCMPB时为低电平，当TCNT<TCMPB时为高电平。在这两种规定下，计算时TCMP寄存器的值会变化。

（2）基于上面讲的，当duty从30%变到70%时，我们TCMPB寄存器中的值就要改（譬如TCNTB中是300时，TCMPB就要从210变化到90）。这样的改变可以满足需要，但是计算有点麻烦。于是乎210的PWM定时器帮我们提供了一个友好的工具叫做电平翻转器。

（3）电平翻转器在电路上的实质就是一个电平取反的部件，在编程上反映为一个寄存器位。写0就关闭输出电平反转，写1就开启输出电平反转。开启后和开启前输出电平刚好高低反转。（输出电平一反转30%的duty就变成70%了）

（4）实战中到底是TCNT和TCMPB谁大谁小时高电平还是低电平，一般不用理论分析，只要写个代码然后用示波器实际看一下出来的波形就知道了；如果反了就直接开启电平翻转器即可。

### 9.3.10、死区生成器

（1）PWM有一个应用就是用在功率电路中用来对交流电压进行整流。整流时2路整流分别在正电平和负电平时导通工作，不能同时导通（同时导通会直接短路，瞬间的同时导通都会导致电路烧毁）。大功率的开关电源、逆变器等设备广泛使用了整流技术。特别是逆变器，用SoC的GPIO输出的PWM波形来分别驱动2路整流的IGBT。

（2）PWM波形用来做整理时要求不能同时高或低，因为会短路。但是实际电路是不理想的，不可能同时上升/下降沿，所以比较安全的做法是留死区。

（3）死区这东西离不了也多不了。死区少了容易短路，死区多了控制精度低了不利于产品性能的提升。

（4）S5PV210给大家提供了自带的死区生成器，只要开启死区生成器，生产出来的PWM波形就自带了死区控制功能，用户不用再自己去操心死区问题。

（5）大部分人工作是用不到这个的，直接关掉死区生成器即可。

*****

## 9.4、蜂鸣器和PWM定时器编程实践

### 9.4.1、蜂鸣器的工作原理

（1）蜂鸣器里面有2个金属片，离的很紧但没挨着；没电的时候两个片在弹簧本身张力作用下分开彼此平行；有电的时候两边分别充电，在异性电荷的吸力作用下两个片挨着；

（2）我们只要以快速的频率给蜂鸣器的正负极：供电、断电。进行这样的循环，蜂鸣器的两个弹簧片就会挨着分开挨着分开···形成敲击，发出声音。

（3）因为人的耳朵能听见的声音频率有限制（20Hz-20000Hz），我们做实验时一般给个2KHz的频率，大部分人都能听到。

（4）频率高低会影响声音的音频，一般是音频越低声音听起来越低沉、音频越高听起来越尖锐。

（5）根据以上的分析，可以看出，只要用PWM波形的电压信号来驱动蜂鸣器，把PWM波形的周期T设置为要发出的声音信号的1/频率即可；PWM的占空比只要确保能驱动蜂鸣器即可（驱动能力问题，一般引脚驱动能力都不够，所以蜂鸣器会额外用三极管来放大流来供电）。

### 9.4.2、原理图和硬件信息

（1）查阅原理图可知，开发板底板上的蜂鸣器通过GPD0_2（XpwmTOUT2）引脚连接在SoC上。

（2）GPD0_2引脚通过限流电阻接在三极管基极上，引脚有电蜂鸣器就会有电（三极管导通）；引脚没电蜂鸣器就会没电（三极管关闭）。这些都是硬件问题，软件工程师不用管，软件工程师只要写程序控制GPD0_2引脚的电平产生PWM波形即可。

（3）GPD0CON(0xE02000A0)，要把bit8～bit11设置为0b0010（功能选择为TOUT_2，就是把这个引脚设置为PWM输出功能）

（4）从GPD0_2引脚可以反推出使用的是timer2这个PWM定时器。

### 9.4.3、PWM定时器的主要寄存器详解

（1）相关的寄存器有TCFG0、TCFG1、CON、TCNTB2、TCMPB2、TCNTO2

注意：PWM定时器来产生PWM波形时是不需要中断干预的。

****

## 9.5、看门狗定时器

### 9.5.1、什么是看门狗

（1）看门狗定时器和普通的定时器并无本质区别。定时器可以设定一个时间，在这个时间完成之前定时器不断计时，时间到的时候定时器会复位CPU（重启系统）。

（2）系统正常工作的时候当然不希望被重启，但是系统受到干扰、极端环境等可能会产生异常工作或者不工作，这种状态可能会造成不良影响（至少是不工作），此时解决方案就是重启系统。

（3）普通设备重启不是问题，但是有些设备人工重启存在困难。这时候我们希望系统能够自己检验自己是否已经跑飞，并且在意识到自己跑飞的时候，可以很快的（几个ms或者更短）自我重启。这个功能就要靠看门狗定时器来实现。

（4）典型应用的情景是：我们在应用程序中打开看门狗设备，初始化好给它一个时间，然后应用程序使用一个线程来喂狗，这个线程的执行时间安全短于看门狗的复位时间。当系统（或者应用程序）异常后，喂狗线程自然就不工作了，然后到时候看门狗就会复位。

（5）补充：实战中有时候为了绝对的可靠，我们并不会用SoC中自带的看门狗，而是使用专门的外置的看门狗芯片来实现看门狗。

### 9.5.2、S5PV210看门狗定时器的结构框图

（1）PCLK_PSYS经过两级分频后生成WDT（watchdog timer）的时钟周期，然后把要定的时间写到WTDAT寄存器中，刷到WTCNT寄存器中去减1，减到0时（定时时间到）产生复位信号或中断信号。

（2）典型应用中是配置为产生复位信号，我们应该在WTCNT寄存器减到0之前给WTDAT寄存器中重新写值以喂狗。

### 9.5.3、看门狗定时器的主要寄存器

WTCON WTDAT WTCNT WTCLRINT

****

## 9.6、实时时钟RTC

### 9.6.1、何为实时时钟

（1）real time clock，真实时间，就是所谓的xx年x月x日x时x分x秒星期x

（1）RTC是SoC中一个内部外设，RTC有自己独立的晶振提供RTC时钟源（32.768KHz），内部有一些寄存器用来记录时间（年月日时分秒星期）。一般情况下为了在系统关机时时间仍然在走，还会给RTC提供一个电池供电。

### 9.6.2、S5PV210实时时钟的结构框图

（1）时间寄存器7个

（2）闹钟发生器

### 9.6.3、闹钟发生器

（1）可以定闹钟时间，到时间会产生RTC alarm interrupt，通知系统闹钟定时到了。

（2）闹钟定时是定的时间点，而timer定时是定的时间段。

### 9.6.4、S5PV210实时时钟的主要寄存器

（1）INTP 中断挂起寄存器

（2）RTCCON	RTC控制寄存器

（3）RTCALM ALMxxx	闹钟功能有关的寄存器

（4）BCDxxx   时间寄存器

### 9.6.5、BCD码

（1）RTC中所有的时间（年月日时分秒星期，包括闹钟）都是用BCD码编码的。

（2）BCD码本质上是对数字的一种编码。用来解决这种问题：由56得到0x56（或者反过来）。也就是说我们希望十进制的56可以被编码成56（这里的56不是十进制56，而是两个数字5和6）.

（3）BCD码的作用在于可以将十进制数拆成组成这个十进制数的各个数字的编码，变成编码后就没有位数的限制了。譬如我有一个很大的数123456789123456789，如果这个数纯粹当数字肯定超出了int的范围，计算机无法直接处理。要想让计算机处理这个数，计算机首先得能表达这个数，表达的方式就是先把这个数转成对应的BCD码（123456789123456789）

（4）BCD码在计算机中可以用十六进制的形式来表示。也就是说十进制的56转成BCD码后是56，在计算机中用0x56来表达（暂时存储与运算）。

（5）需要写2个函数，一个是bcd转十进制，一个是十进制转bcd。当我们要设置时间时（譬如要设置为23分），我们需要将这个23转成0x23然后再赋值给相应的寄存器BCDMIN；当我们从寄存器BCDMIN中读取一个时间时（譬如读取到的是0x59），需要将之当作BCD码转成十进制再去显示（0x59当作BCD码就是59，转成十进制就是59，所以显示就是59分）。

***

## 9.6、RTC编程

### 9.6.1、设置时间与读取显示时间

（1）为了安全，默认情况下RTC读写是禁止的，此时读写RTC的时间是不允许的；当我们要更改RTC时间时，应该先打开RTC的读写开关，然后再进行读写操作，操作完了后立即关闭读写开关。

（2）读写RTC寄存器时，一定要注意BCD码和十进制之间的转换。

（3）年的问题。S5PV210中做了个设定，BCDYEAR寄存器存的并不是完整的年数（譬如今年2015年），而是基于2000年的偏移量来存储的，譬如今年2015年实际存的就是15（2015-2000）.还有些RTC芯片是以1970年（貌似）为基点来记录的。

****

# 10、**SD卡启动详解**

## 10.1、主流外存设备介绍

​	内存和外存的区别：一般是把这种RAM(random access memory,随机访问存储器，特点是任意字节读写，掉电丢失)叫内存，把ROM（read only memory，只读存储器，类似于Flash SD卡之类的，用来存储东西，掉电不丢失，不能随机地址访问，只能以块为单位来访问）叫外存

### 10.1.1、软盘、硬盘、光盘、CD、磁带

（1）存储原理大部分为磁存储，缺点是读写速度、可靠性等。优点是技术成熟、价格便宜。广泛使用在桌面电脑中，在嵌入式设备中几乎无使用。

（2）现代存储的发展方向是Flash存储，闪存技术是利用电学原理来存储1和0，从而制成存储设备。所以闪存设备没有物理运动（硬盘中的磁头），所以读写速度可以很快，且无物理损耗。

### 10.1.2、纯粹的Flash：NandFlash、NorFlash

（1）这些是最早出现的、最原始的Flash颗粒组成芯片。也就是说NandFlash、NorFlash芯片中只是对存储单元做了最基本的读写接口，然后要求外部的SoC来提供Flash读写的控制器以和Flash进行读写时序。

（2）缺陷：1、读写接口时序比较复杂。2、内部无坏块处理机制，需要SoC自己来管理Flash的坏块；3、各家厂家的Flash接口不一致，甚至同一个厂家的不同型号、系列的Flash接口都不一致，这就造成产品升级时很麻烦。

（3）NandFlash分MLC和SLC两种。SLC技术比较早，可靠性高，缺点是容量做不大（或者说容量大了太贵，一般SLC Nand都是512MB以下）；MLC技术比较新，不成熟，可靠性差，优点是容量可以做很大很便宜，现在基本都在发展MLC技术。

### 10.1.3、SD卡、MMC卡、MicroSD、TF卡

（1）这些卡其实内部就是Flash存储颗粒，比直接的Nand芯片多了统一的外部封装和接口。

（2）卡都有统一的标准，譬如SD卡都是遵照SD规范来发布的。这些规范规定了SD卡的读写速度、读写接口时序、读写命令集、卡大小尺寸、引脚个数及定义。这样做的好处就是不同厂家的SD卡可以通用。

### 10.1.4、iNand、MoviNand、eSSD

（1）电子产品如手机、相机等，前些年趋势是用SD卡/TF卡等扩展存储容量；但是近年来的趋势是直接内置大容量Flash芯片而不是外部扩展卡。

（2）外部扩展卡时间长了卡槽可能会接触不良导致不可靠。

（3）现在主流的发展方向是使用iNand、MoviNand、eSSD（还有别的一些名字）来做电子产品的存储芯片。这些东西的本质还是NandFlash，内部由Nand的存储颗粒构成，再集成了块设备管理单元，综合了SD卡为代表的各种卡的优势和原始的NandFlash芯片的优势。

（4）优势：1、向SD卡学习，有统一的接口标准（包括引脚定义、物理封装、接口时序）。2、向原始的Nand学习，以芯片的方式来发布而不是以卡的方式；3、内部内置了Flash管理模块，提供了诸如坏块管理等功能，让Nand的管理容易了起来。

****

## 10.2、SD卡的特点和背景知识

### 10.2.1、SD卡和MMC卡的关系

（1）MMC标准比SD标准早，SD标准兼容MMC标准。
（2）MMC卡可以被SD读卡器读写，而SD卡不可以被MMC读卡器读写。

### 10.2.2、SD卡和Nand、Nor等Flash芯片差异

SD卡/MMC卡等卡类有统一的接口标准，而Nand芯片没有统一的标准（各家产品会有差异）

### 10.2.3、SD卡与MicroSD的区别

体积大小区别而已，传输与原理完全相同。

### 10.2.4、SD卡与TF卡的区别

（1）外观上，SD卡大而TF卡小；用途上，SD卡用于数码相机等而TF卡广泛用于手机、GPS等；

（2）时间上，SD卡1999年推出，TF卡于2004年推出；SD卡由日本松下、东芝与美国SanDisk共同推出，而TF卡由Motorola与SanDisk共同推出。

（3）SD卡有写保护而TF卡没有，TF卡可以通过卡套转成SD卡使用。

***

## 10.3、SD卡的编程接口

### 10.3.1、SD卡的物理接口

SD卡由9个针脚与外界进行物理连接，这9个脚中有2个地，1个电源，6个信号线。

### 10.3.2、SD协议与SPI协议

（1）SD卡与SRAM/DDR/SROM之类的东西的不同：SRAM/DDR/SROM之类的存储芯片是总线式的，只要连接上初始化好之后就可以由SoC直接以地址方式来访问；但是SD卡不能直接通过接口给地址来访问，它的访问需要按照一定的接口协议（时序）来访问。

（2）SD卡虽然只有一种物理接口，但是却支持两种读写协议：SD协议和SPI协议。

### 10.3.3、SPI协议特点（低速、接口操作时序简单、适合单片机）

（1）SPI协议是单片机中广泛使用的一种通信协议，并不是为SD卡专门发明的。

（2）SPI协议相对SD协议来说速度比较低。

（3）SD卡支持SPI协议，就是为了单片机方便使用。

### 10.3.4、SD协议特点（高速、接口时序复杂，适合有SDIO接口的SoC）

（1）SD协议是专门用来和SD卡通信的。

（2）SD协议要求SoC中有SD控制器，运行在高速率下，要求SoC的主频不能太低。

### 10.3.5、S5PV210的SD/MMC控制器

（1）数据手册Section8.7，为SD/MMC控制器介绍。

（2）SD卡内部除了存储单元Flash外，还有SD卡管理模块，我们SoC和SD卡通信时，通过9针引脚以SD协议/SPI协议向SD卡管理模块发送命令、时钟、数据等信息，然后从SD卡返回信息给SoC来交互。工作时每一个任务（譬如初始化SD卡、譬如读一个块、譬如写、譬如擦除····）都需要一定的时序来完成（所谓时序就是先向SD卡发送xx命令，SD卡回xx消息，然后再向SD卡发送xx命令····）

****

## 10.4、S5PV210的SD卡启动详解

### 10.4.1、SoC为何要支持SD卡启动

（1）一个普遍性的原则就是：SoC支持的启动方式越多，将来使用时就越方便，用户的可选择性就越大，SoC的适用面就越广。

（2）SD卡有一些好处：譬如可以在不借用专用烧录工具（类似Jlink）的情况下对SD卡进行刷机，然后刷机后的SD卡插入卡槽，SoC既可启动；譬如可以用SD卡启动进行量产刷机（量产卡）。像我们X210开发板，板子贴片好的时候，内部iNand是空的，此时直接启动无启动；板子出厂前官方刷机时是把事先做好的量产卡插入SD卡卡槽，然后打到iNand方式启动；因为此时iNand是空的所以第一启动失败，会转而第二启动，就从外部SD2通道的SD卡启动了。启动后会执行刷机操作对iNand进行刷机，刷机完成后自动重启（这回重启时iNand中已经有image了，所以可以启动了）。刷机完成后SD量产卡拔掉，烧机48小时，无死机即可装箱待发货。

### 10.4.2、SD卡启动的难点在哪里（SRAM、DDR、SDCard）

（1）SRAM、DDR都是总线式访问的，SRAM不需初始化既可直接使用而DDR需要初始化后才能使用，但是总之CPU可以直接和SRAM/DRAM打交道；而SD卡需要时序访问，CPU不能直接和SD卡打交道；NorFlash读取时可以总线式访问，所以Norflash启动非常简单，可以直接启动，但是SD/NandFlash不行。

（2）以前只有Norflash可以作为启动介质，台式机笔记本的BIOS就是Norflash做的。后来三星在2440中使用了SteppingStone的技术，让Nandflash也可以作为启动介质。SteppingStone（翻译为启动基石）技术就是在SoC内部内置4KB的SRAM，然后开机时SoC根据OMpin判断用户设置的启动方式，如果是NandFlash启动，则SoC的启动部分的硬件直接从外部NandFlash中读取开头的4KB到内部SRAM作为启动内容。

（3）启动基石技术进一步发展，在6410芯片中得到完善，在210芯片时已经完全成熟。210中有96KB的SRAM，并且有一段iROM代码作为BL0，BL0再去启动BL1（210中的BL0做的事情在2440中也有，只不过那时候是硬件自动完成的，而且体系没有210中这么详细）。

### 10.4.3、S5PV210的启动过程回顾

（1）210启动首先执行内部的iROM（也就是BL0），BL0会判断OMpin来决定从哪个设备启动，如果启动设备是SD卡，则BL0会从SD卡读取前16KB（不一定是16，反正16是工作的）到SRAM中去启动执行（这部分就是BL1，这就是steppingstone技术）

（2）BL1执行之后剩下的就是软件的事情了，SoC就不用再去操心了。

### 10.4.4、SD卡启动流程（bin文件小于16KB时和大于16KB时）

（1）启动的第一种情况是整个镜像大小小于16KB。这时候相当于我的整个镜像作为BL1被steppingstone直接硬件加载执行了而已。

（2）启动的第二种情况就是整个镜像大小大于16KB。（只要大于16KB，哪怕是17KB，或者是700MB都是一样的）这时候就要把整个镜像分为2部分：第一部分16KB大小，第二部分是剩下的大小。然后第一部分作为BL1启动，负责去初始化DRAM并且将第二部分加载到DRAM中去执行（uboot就是这样做的）。

### 10.4.5、iROM究竟是怎样读取SD卡/NandFlash的

（1）三星在iROM中事先内置了一些代码去初始化外部SD卡/NandFlash，并且内置了读取各种SD卡/NandFlash的代码在iROM中。BL0执行时就是通过调用这些device copy function来读取外部SD卡/NandFlash中的BL1的。

### 10.4.6、SoC支持SD卡启动的秘密（iROM代码）

（1）三星系列SoC支持SD卡/NandFlash启动，主要是依靠SteppingStone技术，具体在S5PV210中支持steppingstone技术的是内部的iROM代码。

### 10.4.7、扇区和块的概念

（1）早期的块设备就是软盘硬盘这类磁存储设备，这种设备的存储单元不是以字节为单位，而是以扇区为单位。磁存储设备读写的最小单元就是扇区，不能只读取或写部分扇区。这个限制是磁存储设备本身物理方面的原因造成的，也成为了我们编程时必须遵守的规律。

（1）一个扇区有好多个字节（一般是512个字节）。早期的磁盘扇区是512字节，实际上后来的磁盘扇区可以做的比较大（譬如1024字节，譬如2048字节，譬如4096字节），但是因为原来最早是512字节，很多的软件（包括操作系统和文件系统）已经默认了512这个数字，因此后来的硬件虽然物理上可能支持更大的扇区，但是实际上一般还是兼容512字节扇区这种操作方法。

（3）一个扇区可以看成是一个块block（块的概念就是：不是一个字节，是多个字节组成一个共同的操作单元块），所以就把这一类的设备称为块设备。常见的块设备有：磁存储设备硬盘、软盘、DVD和Flash设备（U盘、SSD、SD卡、NandFlash、Norflash、eMMC、iNand）

（4）linux里有个mtd驱动，就是用来管理这类块设备的。

（5）磁盘和Flash以块为单位来读写，就决定了我们启动时device copy function只能以整块为单位来读取SD卡。

### 10.4.8、用函数指针方式调用device copy function

（1）第一种方法：宏定义方式来调用。好处是简单方便，坏处是编译器不能帮我们做参数的静态类型检查。

`#define CopySDMMCtoMem(z,a,b,c,e)(((bool(*)(int, unsigned int, unsigned short, unsigned int*, bool))(*((unsigned  int *)0xD0037F98)))(z,a,b,c,e))`

（2）第二种方法：用函数指针方式来调用。

```c
//重定义定义bool类型
typedef unsigned int bool;

//重定义一个函数指针
typedef bool(*pCopySDMMC2Mem)(int, unsigned int, unsigned short, unsigned int*, bool);

//实际使用时
pCopySDMMC2Mem p1 = (pCopySDMMC2Mem)0xD0037F98;
//函数传参
p1(z,a,b,c,e);				//第一种方法

(*p)(z,a,b,c,e);			//第二种方法
   
```

****

## 10.5、.S5PV210的SD卡启动实战

### 10.5.1、任务：大于16KB的bin文件使用SD卡启动

（1）总体思路：将我们的代码分为2部分：第一部分BL1小于等于16KB，第二部分为任意大小，iROM代码执行完成后从SD卡启动会自动读取BL1到SRAM中执行；BL1执行时负责初始化DDR，然后手动将BL2从SD卡copy到DDR中正确位置，然后BL1远跳转到BL2中执行BL2.

（2）细节1：程序怎么安排？程序整个分为2个文件夹BL1和BL2，各自管理各自的项目。

（3）细节2：BL1中要完成：关看门狗、设置栈、开iCache、初始化DDR、从SD卡复制BL2到DDR中特定位置，跳转执行BL2.

（4）细节3：BL1在SD卡中必须从Block1开始（Block0不能用，这个是三星官方规定的），长度为16KB内，我们就定为16KB（也就是32个block）；BL1理论上可以从33扇区开始，但是实际上为了安全都会留一些空扇区作为隔离，譬如可以从45扇区开始，长度由自己定（实际根据自己的BL2大小来分配长度，我们实验时BL2非常小，因此我们定义BL2长度为16KB，也就是32扇区）。

（5）细节4：DDR初始化好之后，整个DDR都可以使用了，这时在其中选择一段长度足够BL2的DDR空间即可。我们选0x23E00000（地址的选用是因为uboot也是选用这个地址的）（因为我们BL1中只初始化了DDR1，地址空间范围是0x20000000～0x2FFFFFFF）。

### 10.5.2、代码划分为2部分（BL1和BL2）

### 10.5.3、BL1中的重定位

### 10.5.4、BL2远跳转

（1）因为我们BL1和BL2其实是2个独立的程序，链接时也是独立分开链接的，所以不能像以前一样使用ldr pc, =main这种方式来通过链接地址实现元跳转到BL2.

（2）我们的解决方案是使用地址进行强制跳转。因为我们知道BL2在内存地址0x23E00000处，所以直接去执行这个地址即可。

### 10.5.5、代码分为2部分启动的缺陷

（1）代码分为2部分，这种技术叫分散加载。这种分散加载的方法可以解决问题，但是比较麻烦。

（2）分散加载的缺陷：第一，代码完全分2部分，完全独立，代码编写和组织上麻烦；第二，无法让工程项目兼容SD卡启动和Nand启动、NorFlash启动等各种启动方式。

### 10.5.6、uboot中的做法

第二种思路：程序代码仍然包括BL1和BL2两部分，但是组织形式上不分为2部分而是作为一个整体来组织。它的实现方式是：iROM启动然后从SD卡的扇区1开始读取16KB的BL1然后去执行BL1，BL1负责初始化DDR，然后从SD卡中读取整个程序（BL1+BL2）到DDR中，然后从DDR中执行（利用ldr pc, =main这种方式以远跳转从SRAM中运行的BL1跳转到DDR中运行的BL2）。

### 10.5.7、再来分析uboot的SD卡启动细节

（1）uboot编译好之后有200多KB，超出了16KB。uboot的组织方式就是前面16KB为BL1，剩下的部分为BL2.

（2）uboot在烧录到SD卡的时候，先截取uboot.bin的前16KB（实际脚本截取的是8KB）烧录到SD卡的block1～bolck32；然后将整个uboot烧录到SD卡的某个扇区中（譬如49扇区）

（3）实际uboot从SD卡启动时是这样的：iROM先执行，根据OMpin判断出启动设备是SD卡，然后从S卡的block1开始读取16KB（8KB）到SRAM中执行BL1，BL1执行时负责初始化DDR，并且从SD卡的49扇区开始复制整个uboot到DDR中指定位置（0x23E00000）去备用；然后BL1继续执行直到ldr pc, =main时BL1跳转到DDR上的BL2中接着执行uboot的第二阶段。

总结：uboot中的这种启动方式比上节讲的分散加载的好处在于：能够兼容各种启动方式。

****

## 10.6、解决X210开发板的软开关按键问题

### 10.6.1、X210开发板的软启动电路详解

（1）210供电需要的电压比较稳定，而外部适配器的输出电压不一定那么稳定，因此板载了一个文稳压器件MP1482.这个稳压芯片的作用就是外部适配器电压在一定范围内变化时稳压芯片的输出电压都是5V。

（2）MP1482芯片有一个EN（Enable）引脚，这个引脚可以让稳压芯片输出或关闭输出。EN为高电平时有输出电压，EN引脚为低电平时稳压芯片无输出。

（3）两个因素可以影响EN引脚的电平：第一个是POWER按键（SW1），POWER按键按下时EN为高电平，POWER按键弹起时EN为低电平；第二个是POWER_LOCK（EINT0）引脚，这个引脚为POWER_LOCK模式下高电平，则EN为高；若这个引脚为EINT0模式或者为POWER_LOCK模式但输出为低电平，则EN为低。

（4）图中还有EINT1引脚，这个引脚的作用是用来做中断，提供给CPU用来唤醒的。

### 10.6.2、为什么要软启动

（1）一般的电路设计都是用拨码开关来做电源开关的（打到一侧则接通，打到另一侧则关闭）。这种方式的优点是设计简单，缺点是电路太简单，整个主板要么有电要么没电无法做休眠模式、低功耗模式等。

（2）软启动电路是比较接近于实际产品的，其他开发板的硬开关其实是简化版的，和实际产品还有差异。

### 10.6.3、开发板供电置锁原理和分析

（1）软开关在设计时有一个置锁电路，用EINT0（也就是GPH0_2）引脚来控制的。

（2）EINT0这个引脚是有复用设计（两个完全不相干的功能挤在同一个引脚上，同时我们只能让这个引脚用于其中一种功能，这就叫复用）的，一个是GPIO（也就是GPH0_2引脚）、一个是PS_HOLD_CONTROL。（注意：EINT0功能算是GPIO下的一个子功能）

（3）PS_HOLD在Section2.4 Power Management章节下的4.10.5.8节下。

（4）PS_HOLD_CONTROL寄存器（0xE010E81C），共有3个位有用。
	bit0, 0表示这个引脚为GPIO功能，1表示这个引脚为PS_HOLD功能
	bit9，0表示这个引脚方向为输入，1表示这个引脚方向为输出
	bit8，0表示这个引脚输出为低电平，1表示输出为高电平。

分析：我们要使用软启动置锁，则需要将bit0、8、9都置为1即可。

### 10.6.4、写代码+实验验证

（1）要想让开发板和普通的开发板一样，一按下按键程序运行后即可松手不会断电，则只要在程序的开头部分添加代码去置锁开关板即可。

（2）置锁代码的方法是：给PS_HOLD_CONTROL寄存器的bit0、8、9均写入1即可。

（3）注意：此时开发板已经置锁，POWER按键已经失效，关机时需要按下复位按键。

*****

# 11、NandFlash和iNand

## 11.1、NandFlash的接口

### 11.1.1、Nand的型号与命名

（1）Nand的型号命名都有含义，就拿K9F2G08来示例分析一下：K9F表示是三星公司的NandFlash系列。2G表示Nand的大小是2Gbit（256MB）。08表示Nand是8位的（8位就是数据线有8根）

（2）Nand命名中可以看出：厂家、系列型号、容量大小、数据位数。

### 11.1.2、Nand的数据位

（1）Nand有8位数据位的，有16位数据位的。做电路时/写软件时应该根据自己实际采购的Nnad的位数来设计电路/写软件。

（2）说明Nand是并行接口的（8/16位）

（3）Nand的数据线上传递的不一定全部是有效数据，也可能有命令、地址等。

### 11.1.3、Nand的功能框图

（1）Nand的结构可以看成是一个矩阵式存储器，其中被分成一个一个的小块，每一小块可以存储一个bit位，然后彼此以一定单位组合成整个Nand。

（2）Nand中可以被单次访问的最小单元（就是说对Nand进行一次读写至少要读写这么多，或者是这么多的整数倍）叫做Page（页），在K9F2G08芯片中，Page的大小是2KB+64B。也就是说我们要读写K9F2G08，每次至少要读写2KB或者n*2KB，即使我们只是想要其中的一个字节。这就是我们说的典型的块设备（现在有些块设备为了方便，提供了一种random read模式，可以只读取1个字节）。

（3）页往上还有个Block（块）的概念，1个块等于若干个页（譬如在K9F2G08中1个块等于64页）。

（4）块往上就是整个Nand芯片了，叫做Device。一个Device是若干个Block，譬如K9F2F08一个Device有2048个block。所以整个Device大小为：2048×64×2K = 256MB

（5）块设备分page、block有什么意义？首先要明白，块设备不能完全按字节访问而必须块访问是物理上的限制，而不是人为设置的障碍。其次，Page和Block各有各的意义，譬如Nand中：Page是读写Nand的最小单位；Block是擦除Nand的最小单位。（这些规则都是Nand的物理原理和限制要求的，不是谁想要这样的，所以对于我们做软件的来说，只能去想办法适应硬件，不是想着超越硬件）。

（6）Nand芯片中主要包含2部分：Nand存储颗粒+Nand接口电路。存储颗粒就是纯粹的Nand原理的存储单元，类似于仓库；Nand接口电路是用来管理存储颗粒，并且给外界提供一个统一的Nand接口规格的访问接口的。

（7）Nand中有多个存储单元，每个单元都有自己的地址（地址是精确到字节的）。所以Nand是地址编排精确到字节，但是实际读写却只能精确到页（所以Nand的很多操作都要求给的地址是页对齐的，譬如2K、4K、512K等这样的地址，不能给3000B这样的地址）。Nand读写时地址传递是通过IO线发送的，因为地址有30位而IO只有8位，所以需要多个cycle才能发送完毕。一般的Nand都是4cycle或者5cycle发送地址（从这里把Nand分为了4cycle Nand和5cycle Nand）。

总结：Nand芯片内部有存储空间，并且有电路来管理这些存储空间，向外部提供统一的Nand接口的访问规则，然后外部的SoC可以使用Nand接口时序来读写这个Nand存储芯片。Nand接口是一种公用接口，是一种标准，理论上来说外部SoC可以直接模拟Nand接口来读写Nand芯片，但是实际上因为nand接口对时序要求非常严格，而且时序很复杂，所以一般的SoC都是通过专用的硬件的Nand控制器（这些控制器一般是作为SoC的内部外设来存在的）来操控Nand芯片的。

****

## 11.2、NandFlash的结构

### 11.2.1、Nand的单元组织：block与page（大页Nand与小页Nand）

（1）Nand的页和以前讲过的块设备（尤其是硬盘）的扇区是类似的。扇区最早在磁盘中是512字节，后来也有些高级硬盘扇区不是512字节而是1024字节/2048字节/4096字节等。Nand也是一样，不同的Nand的页的大小是不同的，也有512字节/1024字节/2048字节/4096字节等。

（2）一个block等于多少page也是不定的，不同的Nand也不同。一个Nand芯片有多少block也是不定的，不同的Nand芯片也不同。

总结：Nand的组织架构挺乱的，接口时序也不同，造成结构就是不同厂家的Nand芯片，或者是同一个厂家的不同系列型号存储容量的nand接口也不一样。所以nand有一个很大的问题就是一旦升级容量或者换芯片系列则硬件要重新做、软件要重新移植。

### 11.2.2、带内数据和带外数据（ECC与坏块标记）

（1）Nand的每个页由2部分组成，这2部分各自都有一定的存储空间。譬如K9F2G08中为2K+64字节。其中的2K字节属于带内数据，是我们真正的存储空间，将来存储在Nand中的有效数据就是存在这2K范围内的（我们平时计算nand的容量时也是只考虑这2KB）；64字节的带外数据不能用来存储有效数据，是作为别的附加用途的（譬如用来存储ECC数据、用来存储坏块标志等····）

（2）什么是ECC：（error correction code，错误校验码）。因为nand存储本身出错（位反转）概率高（Nand较Nor最大的缺点就是稳定性），所以当我们将有效信息存储到Nand中时都会同时按照一定算法计算一个ECC信息（譬如CRC16等校验算法），将ECC信息同时存储到Nand这个页的带外数据区。然后等将来读取数据时，对数据用同样的算法再计算一次ECC，并且和从带外数据区读出的ECC进行校验。如果校验通过则证明Nand的有效数据可信，如果校验不通过则证明这个数据已经被损坏（只能丢弃或者尝试修复）。

（3）坏块标志：Nand芯片用一段时间后，可能某些块会坏掉（这些块无法擦除了，或者无法读写了），nand的坏块非常类似于硬盘的坏道。坏块是不可避免的，而且随着Nand的使用坏块会越来越多。当坏块还不算太多时这个Nand都是可以用的，除非坏块太多了不划算使用了才会换新的。所以我们为了管理Nand发明了一种坏块标志机制。Nand的每个页的64字节的带外数据中，我们（一般是文件系统）定义一个固定位置（譬如定位第24字节）来标记这个块是好的还是坏的。文件系统在发现这个块已经坏了没法用了时会将这个块标记为坏块，以后访问nand时直接跳过这个块即可。

### 11.2.3、Nand的地址时序

（1）nand的地址有多位，分4/5周期通过IO引脚发送给Nand芯片来对Nand进行寻址。寻址的最小单位是字节，但是读写的最小单位是页。

（2）nand的地址在写代码时要按照Nand要求的时序和顺序去依次写入。

### 11.2.4、Nand的命令码

（1）外部SoC要想通过Nand控制器来访问Nand（实质就是通过Nand接口），就必须按照Nand接口给nand发送命令、地址、数据等信息来读写Nand。

（2）Nand芯片内部的管理电路本身可以接收外部发送的命令，然后根据这些命令来读写Nand内容与外部SoC交互。所以我们对nand进行的所有操作（擦除、读、写···）都要有命令、地址、数据的参与才能完成，而且必须按照Nand芯片规定的流程来做。

*****

## 11.3、NandFlash的常见操作及流程分析

### 11.3.1、坏块检查

（1）Flash使用之前要先统一擦除（擦除的单位是块）。Flash类设备擦除后里面全是1，所以擦干净之后读出来的值是0xff。

（2）检查坏块的思路就是：先块擦除，然后将整块读出来，依次检测各自节是否为0xff，如果是则表明不是坏块，如果不是则表明是坏块。

### 11.3.2、页写（program）操作

（1）写之前确保这个页是被擦除干净的。如果不是擦除干净的（而是脏的、用过的）页，写进去的值就是错的，不是你想要的结果。

（2）写操作（write）在flash的操作中就叫编程（program）

（3）SoC写Flash时通过命令线、IO线依次发送写命令、写页地址、写数据等进入NandFlash。

（4）写的过程：SOC通过Nand控制器和Nand芯片完成顺序对接，然后按照时序要求将一页数据发给Nand芯片内部的接口电路。接口电路先接收收据到自己的缓冲区，然后再集中写入Nand芯片的存储区域中。Nand接口电路将一页数据从缓冲区中写入Nand存储系统中需要一定的时间，这段时间Nand芯片不能再响应SOC发过来的其他命令，所以SoC要等待Nnad接口电路忙完。等待方法是SoC不断读取状态寄存器（这个状态寄存器有2种情况：一种是SoC的Nand控制器自带的，另一种是SoC通过发命令得到命令响应得到的），然后通过检查这个状态寄存器的状态位就能知道Nand接口电路刚才写的那一页数据写完了没、写好了没。直到SoC收到正确的状态寄存器响应才能认为刚才要写的那一页数据已经ok。（如果SoC收到的状态一直不对，可以考虑重写或者认为这一页所在的块已经是坏块，或者整个Nand芯片已经挂掉了）。

（5）正常情况下到了第四步就已经完了。但是因为Nand的读写有不靠谱情况，因此我们为了安全会去做ECC校验。ECC校验有硬件式校验和软件式校验2种。软件式校验可以采用的策略有很多，其中之一（Nand芯片手册上推荐的方式是）：将刚才写入的1页数据读出来，和写入的内容进行逐一对比。如果读出的和写入的完全一样，说明刚才的写入过程正确完成了；如果读出来的和写入的不完全一样那就说明刚才的写入有问题。

（6）硬件式ECC：SoC的Nand控制器可以提供硬件式ECC（这个也是比较普遍的情况）。硬件式ECC就是在Nand的控制器中有个硬件模块专门做ECC操作。当我们操作Nand芯片时，只要按照SoC的要求按时打开ECC生成开关，则当我们写入Nand芯片时SoC的Nand控制器的ECC模块会自动生成ECC数据放在相应的寄存器中，然后我们只需要将这生成的ECC数据写入Nand芯片的带外数据区即可；在将来读取这块Nand芯片时，同样要打开硬件ECC开关，然后开始读，在读的过程当中硬件ECC会自动计算读进来的一页数据的ECC值并将之放到相应的寄存器中。然后我们再读取带外数据区中原来写入时存入的ECC值，和我们刚才读的时候得到的ECC值进行校验。校验通过则说明读写正确，校验不通过则说明不正确（放弃数据或者尝试修复）。

### 11.3.3、擦除（erase）操作

（1）擦除时必须给块对齐的地址。如果给了不对齐的地址，结果是不可知的（有些Nand芯片没关系，它内部会自动将其对齐，而有些Nand会返回地址错误）。

（2）读写时给的地址也是一样，要求是页对齐地址。如果给了不对齐的，也是有可能对有可能错。

*****

## 11.4、S5PV210的NandFlash控制器

### 11.4.1、SoC的Nand控制器的作用

（1）Nand芯片本身通过Nand接口电路来存取数据，Nand接口电路和SOC之间通过Nand接口时序来通信。Nand接口时序相对复杂，如果要SoC完全用软件来实现Nand接口时序有一些不好（主要是：第一很难保证时序能满足、容易不稳定；第二代码很难写）。解决方案是：在SoC内部集成一个Nand控制器（实质就是一块硬件电路，这个硬件电路完全满足Nand接口时序的操作，然后将接口时序的操作寄存器化）。

（2）SOC和Nand芯片之间通信，在SoC没有Nand控制器时需要SoC自己来处理接口时序，编程很麻烦，需要程序员看Nand芯片的接口时序图，严格按照接口时序图中编程（尤其要注意各个时间参数）；在SoC有Nand控制器时SoC只需要编程操控Nand控制器的寄存器即可，Nand控制器内部硬件会根据寄存器值来生成合适的Nand接口时序和Nand芯片通信。所以在有Nand控制器时编程要简单很多，我们读写Nand芯片时再也不用关注Nand接口时序了，只要关注SoC的Nand控制器的寄存器即可。

（3）扩展来讲，现在的技术趋势就是：几乎所有的外设在SoC内部都有对应的控制器来与其通信，那么SoC内部集成的各种控制器（也就是各种内部外设）越多，则SoC硬件能完成的功能越多，将来用这个SoC来完成相应任务时软件编程越简单。譬如说图形处理和图像处理领域，2D图像编码（jpeg编码）、视频编码（h.264编码），现在大部分的application级别的SoC都有集成的内部编码器（像S5PV210就有、更复杂的譬如4418、6818就更不用说了，只会更多更先进），我们可以利用这些硬件编码器来进行快速编解码，这样软件工作量和难度降低了很多（这就是所谓的硬件加速）。

### 11.4.2、结构框图分析

(1)结构框图中关键点：SFR（我们后续编程的关键，编程时就是通过读写SFR来产生Nand接口时序以读写Nand芯片的） + Nand interface（硬件接口，将来和Nand芯片的相应引脚进行连接） + ECC生成器

### 11.4.3、S5PV210的Nand控制器的主要寄存器

NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFMECCD0&NFMECCD1、NFSECCD、NFSTAT

****

## 11.5、Nand操作代码解析

### 11.5.1、擦除函数

总结：
（1）像NandFlash这类芯片，通过专用的接口时序和SoC内部的控制器相连（这种连接方式是非常普遍的，像LCD、DDR等都是类似的连接）。这种接法和设计对我们编程来说，关键在于两点：SoC的控制器的寄存器理解和Nand芯片本身的文档、流程图等信息。

（2）对于我们来说，学习NandFlash，要注意的是：
第一，要结合SoC的数据手册、Nand芯片的数据手册、示例代码三者来理解。
第二，初学时不要尝试完全不参考自己写出Nand操作的代码，初学时应该是先理解实例代码，知道这些代码是怎么写出来的，必要时对照文档来理解代码。代码理解之后去做实践，实践成功后以后再考虑自己不参考代码只参考文档来写出nand操作的代码。

****

## 10.6、iNand介绍

### 10.6.1、iNand/eMMC/SDCard/MMCCard的关联

（1）最早出现的是MMC卡，卡片式结构，按照MMC协议设计。（相较于NandFlash芯片来说，MMC卡有2个优势：第一是卡片化，便于拆装；第二是统一了协议接口，兼容性好。）

（2）后来出现SD卡，兼容MMC协议。SD卡较MMC有一些改进，譬如写保护、速率、容量等。

（3）SD卡遵守SD协议，有多个版本。多个版本之间向前兼容。

（4）iNand/eMMC在SD卡的基础上发展起来，较SD卡的区别就是将SD卡芯片化了（解决卡的接触不良问题，便于设备迷你化）。

（5）iNand和eMMC的关联：eMMC是协议，iNand是Sandisk公司符合eMMC协议的一种芯片系列名称。

### 10.6.2、iNand/eMMC的结构框图及其与NandFlash的区别

（1）iNand内部也是由存储系统和接口电路构成（和Nand结构特性类似，不同之处在于接口电路功能不同）。

（2）iNand的接口电路挺复杂，功能很健全。譬如：
第一，提供eMMC接口协议，和SoC的eMMC接口控制器通信对接。
第二，提供块的ECC校验相关的逻辑，也就是说iNand本身自己完成存储系统的ECC功能，SoC使用iNand时自己不用写代码来进行ECC相关操作，大大简化了SoC的编程难度。（NandFlash分2种：SLC和MLC，SLC更稳定，但是容量小价格高；MLC容易出错，但是容量大价格低）
第三，iNand芯片内部使用MLC Nand颗粒，所以性价比很高。
第四，iNand接口电路还提供了cache机制，所以inand的操作速度很快。

### 10.6.3、iNand/eMMC的物理接口和SD卡物理接口的对比

（1）S5PV210芯片本身支持4通道的SD/MMC，在X210中实际是在SD/MMC0通道接了iNand芯片，而SD/MMC2接了SD卡（SD/MMC3也接了SD卡）。

（2）对比inand和SD卡接线，发现：这两个接线几乎是一样的，唯一的区别就是SD卡IO线有4根，而iNand的IO线有8根。

（3）这个告诉我们，我们在实际操作iNand芯片时和操作SD卡时几乎是一样的（物理接线几乎一样，软件操作协议几乎一样）。

结论：iNand/eMMC其实就是芯片化的SD/MMC卡，软件操作和SD卡相同。
分析iNand芯片的操作代码时，其实就是以前的SD卡的操作代码。一些细节的区别就是为了区分各种不同版本的SD卡、iNand的细节差异。

*****

## 10.7、SD卡/iNand操作

### 10.7.1、硬件接口：DATA、CLK、CMD

（1）iNand的IO线有8根，支持1、4、8线并行传输模式；SD卡IO线有4根，支持1、4线并行传输模式。

（2）CMD线用来传输命令、CLK线用来传输时钟信号。

（3）接口有CLK线，工作时主机SoC通过CLK线传输时钟信号给SD卡/iNand芯片，说明：SD/iNand是同步的，SD/iNand的工作速率是由主机给它的CLK频率决定的。

### 10.7.2、命令相应的操作模式

（1）SD协议事先定义了很多标准命令（CMD0、CMD1·····），每个命令都有它的作用和使用条件和对应的响应。SD卡工作的时候就是一个一个的命令周期组合起来的，在一个命令周期中，主机先发送CMD给SD卡，然后SD卡解析这个命令并且执行这个命令，然后SD卡根据结果回发给主机SoC一个响应。（有些命令是不需要响应的，这时SD卡不会给主机回发响应，主机也不用等待响应）。标准的命令+响应的周期中，主机发完一个命令后应该等待SD卡的响应而不是接着发下一条命令。

### 10.7.3、SD/iNand的体系结构图

（1）SD卡内部有一个接口控制器，这个控制器类似于一个单片机，这个单片机的程序功能就是通过CMD线接收外部主机SoC发给SD卡的命令码，然后执行这个命令并且回发响应给主机SoC。这个单片机处理命令及回发响应遵循的就是SD协议。这个单片机同时可以控制SD卡内部的存储单元，可以读写存储单元。

### 10.7.4、SD/iNand的寄存器（重点是RCA寄存器）

（1）注意这里说的是SD卡内部的寄存器，而不是主机SoC的SD控制器的寄存器。（很多外置芯片内部都是有寄存器的，这些寄存器可以按照一定的规则访问，访问这些寄存器可以得知芯片的一些信息）。

（2）RCA（relative address，相对地址寄存器）。我们在访问SD卡时，实际上SD卡内部每个存储单元的地址没有绝对数字，都是使用相对地址。相对地址由SD卡自己决定的，存放在RCA寄存器中。

### 10.7.5、SoC的SD/MMC/iNand控制器简介

（1）不同的SoC可能在SD/MMC/iNand等支持方面有差异，但是如果支持都是通过内部提供SD控制器来支持的。

（2）S5PV210的SD卡控制器在Section8.7部分

*****

## 10.8、SD/iNand代码实战分析

### 10.8.1、命令码CMD和ACMD

（1）SD卡工作在命令+响应的模式下。

（2）SD协议的命令分2种：CMDx和ACMDx。CMD是单命令命令，就是单独发一个CMD即可表示一个意思。ACMD是一种扩展，就是发2个CMD加起来表示一个意思。可以认为ACMDx = CMDy+CMDz（y一般是55）

### 10.8.2、卡类型识别SD or MMC

（1）MMC协议、SD协议、eMMC协议本身是一脉相承的，所以造成了一定的兼容性，所以当我们SoC控制器工作时连接到SoC上的可能是一个MMC卡、也可能是SD卡、也可能是iNand芯片。主机SoC需要去识别这个卡到底是什么版本的卡

（2）SoC如何区分卡种类？因为不同版本的卡内部协议不同的，所以对卡识别命令的响应也是不同的。SoC通过发送一些命令、听取响应就可以根据不同的响应判定卡的版本。

### 10.8.3、卡状态

（1）SD卡内部的接口控制器类似于一个单片机，这个单片机其实是一个状态机。所以SD卡任何时候都属于某一种状态（空闲状态、准备好状态、读写状态、出错状态····都是事先定义好的），在这种状态下能够接受的命令是一定的，接受到命令之后执行一定的操作然后根据操作结果会跳转为其他状态。如果主机发过来的命令和当前状态不符状态机就不响应，如果收到命令和当前状态相符就会执行相应操作，执行完之后根据结果跳转为其他状态。

### 10.8.4、卡回复类型

（1）一般来说，SD卡的命令都属于：命令+响应的模式。也有极少数的SD卡命令是不需要回复的。

（2）卡回复有R1、R7、R1B等8种类型，每种卡回复类型都有自己的解析规则。然后卡在特定状态下响应特定命令时有可能回复哪种响应都是SD协议事先规定好的，详细细节要查阅协议文档。

### 10.8.5、linux内核风格的寄存器定义

（1）定义一个基地址，然后定义要访问的寄存器和基地址之间的偏移量，在最终访问寄存器时地址就等于基地址+偏移量。

（2）给大家提供的代码中宏定义是不完整的，很多宏定义只能从字面意思来理解对应，无法通过语法完全获得。这样写代码的好处是可以见名知意，就算代码不全都能读。

### 10.8.6、SD/iNand相关的GPIO初始化

（1）GPG0相关的GPIO初始化，参考LED部分的设置技术

（2）时钟设置参考裸机第六部分时钟那一章，设置时使用到了位操作技巧，参考C高级第二部分

（3）要求能够在两三分钟之内完全看懂这些代码涉及到的知识，要能够在数据手册、原理图中找到相对应的点，要能够瞬间明白代码中涉及到的C语言语法技巧，这样才叫融会贯通，才能够从代码中学到东西。

### 10.8.7、SD/iNand的时钟设置

（1）SD卡本身工作需要时钟，但是自己又没有时钟发生单元，依靠主机SoC的控制器通过SD接口中的CLK线传一个时钟过来给SD卡内部使用。所以主机SD卡控制器先初始化好自己的时钟，然后将自己的时钟传给SD卡。

（2）因为此时刚开始和SD卡通信，主机不清楚SD卡属于哪个版本（高版本和低版本的SD卡的读写速率不同，高版本的可以工作在低版本的速率下，低版本的SD卡不能工作在高版本速率下），所以先给SD卡发400KHz的低速率时钟，SD卡拿到这个时钟后就能工作了。然后在后面和SD卡进行进一步通信时去识别SD卡的版本号，识别后再根据SD卡的版本进一步给它更合适的时钟。

****

# 12、I2C通信详解

## 12.1、什么是I2C通信

### 12.1.1、物理接口：SCL + SDA

（1）SCL(serial clock)：时钟线，传输CLK信号，一般是I2C主设备向从设备提供时钟的通道。

（2）SDA(serial data): 数据线，通信数据都通过SDA线传输

### 12.1.2、通信特征：串行、同步、非差分、低速率

（1）I2C属于串行通信，所有的数据以位为单位在SDA线上串行传输。

（2）同步通信就是通信双方工作在同一个时钟下，一般是通信的A方通过一根CLK信号线传输A自己的时钟给B，B工作在A传输的时钟下。所以同步通信的显著特征就是：通信线中有CLK

（3）非差分。因为I2C通信速率不高，而且通信双方距离很近，所以使用电平信号通信。

（4）低速率。I2C一般是用在同一个板子上的2个IC之间的通信，而且用来传输的数据量不大，所以本身通信速率很低（一般几百KHz，不同的I2C芯片的通信速率可能不同，具体在编程的时候要看自己所使用的设备允许的I2C通信最高速率，不能超过这个速率）

### 12.1.3、突出特征1：主设备+从设备

（1）I2C通信的时候，通信双方地位是不对等的，而是分主设备和从设备。通信由主设备发起，由主设备主导，从设备只是按照I2C协议被动的接受主设备的通信，并及时响应。

（2）谁是主设备、谁是从设备是由通信双方来定的（I2C协议并无规定），一般来说一个芯片可以只能做主设备、也可以只能做从设备、也可以既能当主设备又能当从设备（软件配置）。

### 12.1.4、突出特征2：可以多个设备挂在一条总线上（从设备地址）

（1）I2C通信可以一对一（1个主设备对1个从设备），也可以一对多（1个主设备对多个从设备）。

（2）主设备来负责调度总线，决定某一时间和哪个从设备通信。注意：同一时间内，I2C的总线上只能传输一对设备的通信信息，所以同一时间只能有一个从设备和主设备通信，其他从设备处于“冬眠”状态，不能出来捣乱，否则通信就乱套了。

（3）每一个I2C从设备在通信中都有一个I2C从设备地址，这个设备地址是从设备本身固有的属性，然后通信时主设备需要知道自己将要通信的那个从设备的地址，然后在通信中通过地址来甄别是不是自己要找的那个从设备。（这个地址是一个电路板上唯一的，不是全球唯一的）

主要用途：SoC和周边外设之间的通信（典型的如EEPROM、电容触摸IC、各种sensor等）

****

## 12.2、由I2C学通信时序

### 12.2.1、什么是时序？

（1）时序：字面意思，时序就是时间顺序，实际上在通信中时序就是通信线上按照时间顺序发生的电平变化，以及这些变化对通信的意义就叫时序。

### 12.2.2、I2C的总线空闲状态、起始位、结束位

（1）I2C总线上有1个主设备，n（n>=1）个从设备。I2C总线上有2种状态；空闲态（所有从设备都未和主设备通信，此时总线空闲）和忙态（其中一个从设备在和主设备通信，此时总线被这一对占用，其他从设备必须歇着）。

（2）整个通信分为一个周期一个周期的，两个相邻的通信周期是空闲态。每一个通信周期由一个起始位开始，一个结束位结束，中间是本周期的通信数据。

（3）起始位并不是一个时间点，起始位是一个时间段，在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从高到低的下降沿。

（4）与起始位相似，结束位也是一个时间段。在这段时间内总线状态变化情况是：SCL线维持高电平，同时SDA线发生一个从低到高的上升沿。

### 12.2.3、I2C数据传输格式（数据位&ACK）

（1）每一个通信周期的发起和结束都是由主设备来做的，从设备只有被动的响应主设备，没法自己自发的去做任何事情。

（2）主设备在每个通信周期会先发8位的从设备地址（其实8位中只有7位是从设备地址，还有1位表示主设备下面要写入还是读出）到总线（主设备是以广播的形式发送的，只要是总线上的所有从设备其实都能收到这个信息）。然后总线上的每个从设备都能收到这个地址，并且收到地址后和自己的设备地址比较看是否相等。如果相等说明主设备本次通信就是给我说话，如果不想等说明这次通信与我无关，不用听了不管了。

（3）发送方发送一段数据后，接收方需要回应一个ACK。这个响应本身只有1个bit位，不能携带有效信息，只能表示2个意思（要么表示收到数据，即有效响应；要么表示未收到数据，无效响应）

（4）在某一个通信时刻，主设备和从设备只能有一个在发（占用总线，也就是向总线写），另一个在收（从总线读）。如果在某个时间主设备和从设备都试图向总线写那就完蛋了，通信就乱套了。

### 12.2.4、数据在总线上的传输协议

（1）I2C通信时的基本数据单位也是以字节为单位的，每次传输的有效数据都是1个字节（8位）。

（2）起始位及其后的8个clk中都是主设备在发送（这设备掌控总线），此时从设备只能读取总线，通过读总线来得知主设备发给从设备的信息；然后到了第9周期，按照协议规定从设备需要发送ACK给主设备，所以此时主设备必须释放总线（主设备把总线置为高电平然后不要动，其实就类似于总线空闲状态），同时从设备试图拉低总线发出ACK。如果从设备拉低总线失败，或者从设备根本就没有拉低总线，则主设备看到的现象就是总线在第9周期仍然一直保持高，这对主设备来说，意味着我没收到ACK，主设备就认为刚才给从设备发送的8字节不对（接收失败）

****

## 12.3、S5PV210的I2C控制器

通信双方本质上是通过时序在工作，但是时序会比较复杂不利于SoC软件完成，于是乎解决方案是SoC内部内置了硬件的控制器来产生通信时序。这样我们写软件时只需要向控制器的寄存器中写入配置值即可，控制器会产生适当的时序在通信线上和对方通信。

### 12.3.1、结构框图

（1）时钟部分，时钟来源是PCLK_PSYS，经过内部分频最终得到I2C控制器的CLK，通信中这个CLK会通过SCL线传给从设备。

（2）I2C总线控制逻辑（前台代表是I2CCON、I2CSTAT这两个寄存器），主要负责产生I2C通信时序。实际编程中要发送起始位、停止位、接收ACK等都是通过这两个寄存器（背后所代表的电路模块）实现的。

（3）移位寄存器（shift register），将代码中要发送的字节数据，通过移位寄存器变成1个位一个位的丢给SDA线上去发送/接收。学过数字电路的同学应该对移位寄存器不陌生。

（4）地址寄存器+比较器。本I2C控制器做从设备的时候用。(我没用过，理论分析)

### 12.3.2、系统分析I2C的时钟

（1）I2C时钟源头来源于PCLK（PCLK_PSYS，等于65MHz），经过了2级分频后得到的。

（2）第一级分频是I2CCON的bit6，可以得到一个中间时钟I2CCLK（等于PCLK/16或者PCLK/512）

（3）第二级分频是得到最终I2C控制器工作的时钟，以I2CCLK这个中间时钟为来源，分频系数为[1,16]

（4）最终要得到时钟是2级分频后的时钟，譬如一个可用的设置是：65000KHz/512/4=31KHz

### 12.3.3、主要寄存器I2CCON、I2CSTAT、I2CADD、I2CDS

I2CCON + I2CSTAT：主要用来产生通信时序和I2C接口配置。
I2CADD：用来写自己的slave address
I2CDS：发送/接收的数据都放在这里

****

## 12.4、X210板载gsensor介绍

### 12.4.1、原理图查阅

（1）gsensor的供电由PWMTOUT3引脚控制。当PWMTOUT3输出低电平时gsensor无电不工作；当输出高电平时gsensor才会工作。

（2）gsensor的SDA和SCL接的是S5PV210的I2C端口0

（3）将来编程时在gsensor_init函数中要去初始化相关的GPIO。要把相应的GPIO设置为正确的模式和输入输出值。

### 12.4.2、重力加速度传感器简介

（1）用在手机、平板、智能手表等设备上，用来感受人的手的移动，获取一些运动的方向性信息用来给系统作为输入参量。

（2）可以用来设计智能手表的计步器功能。

（3）重力加速度传感器、地磁传感器、陀螺仪等三个传感器结合起来，都是用来感谢运动的速度、方位等信息的，所以现在最新的有9轴传感器，就是把三者结合起来，并且用一定的算法进行综合得出结论，目的是更加准确。

（4）一般传感器的接口有2种：模拟接口和数字接口。模拟接口是用接口电平变化来作为输出的（譬如模拟接口的压力传感器，在压力不同时输出电平在0～3.3V范围内变化，每一个电压对应一个压力。），SOC需要用AD接口来对接这种传感器对它输出的数据进行AD转换，转换得到数字电压值，再用数字电压值去校准得到压力值；数字接口是后来发展出来的，数字接口的sensor是在模拟接口的sensor基础上，内部集成了AD，直接（通过一定的总线接口协议，一般是i2C）输出一个数字值的参数，这样SoC直接通过总线接口初始化、读取传感器输出的参数即可（譬如gsensor、电容触摸屏IC）。

### 12.4.3、I2C从设备的设备地址

（1）KXTE9的I2C地址固定为0b0001111（0x0f）

（2）I2C从设备地址本身是7位的，但是在I2C通信中发送I2C从设备地址时实际发送的是8位，这8位中高7位（bit7-bit1）对应I2C从设备的7位地址，最低一位（LSB）存放的是R/W信息（就是说下一个数据是主设备写从设备读（对应0），还是主设备读从设备写（对应1））

（3）基于上面讲的，对于KXTE9来说，主设备（SoC）发给gsensor信息时，SAD应该是：0b00011110(0x1E)
如果是主设备读取gsensor信息时，SAD应该是：0b00011111（0x1F）

### 12.4.4、I2C从设备的通信速率

（1）I2C协议本身属于低速协议，通信速率不能太高。

（2）实际上通信的主设备和从设备本身都有最高的通信速率限制（属于各个芯片本身的参数），实际编程时怎么确定最终的通信速率？只要小于两个即可。

（3）一般来说只能做从设备的sensor芯片本身i2c通信速率偏低，像KXTE9最高支持400KHz的频率。

***

## 12.5、I2C总线的通信流程

### 12.5.1、S5PV210的主发送流程图

![image-20210619160826063](ARM裸机.assets/image-20210619160826063.png)

### 12.5.2、S5PV210的主接收流程图

![image-20210619164634373](ARM裸机.assets/image-20210619164634373.png)

### 12.5.3、gsensor的写寄存器流程图

![image-20210619165626800](ARM裸机.assets/image-20210619165626800.png)

### 12.5.4、gsensor的读寄存器流程图

![image-20210619165849422](ARM裸机.assets/image-20210619165849422.png)

***

## 12.6、I2C通信代码分析–I2C层

### 12.6.1、I2C控制器初始化：s3c24xx_i2c_init

（1）初始化做的事情：初始化GPIO，设置IRQEN和ACKEN，初始化I2C时钟

### 12.6.2、I2C控制器主模式开始一次读写：s3c24xx_i2c_message_start

### 12.6.3、I2C控制器主模式结束一次读写：s3c24xx_i2c_stop

***

## 12.7、I2C通信代码分析–gsensor层

（1）框架分析：我们最终目的是通过读写gsensor芯片的内部寄存器来得到一些信息。为了完成这个目的，我们需要能够读写gsensor的寄存器，根据gsensor的规定我们需要按照一定的操作流程来读写gsensor的内部寄存器，这是一个层次（姑且叫做传输层、协议层、应用层）；我们要按照操作流程去读写寄存器，就需要考虑I2C接口协议（这就是所谓的物理层，本质就是那些时序）。此时主机SoC有或者没有控制器，有控制器时考虑控制器的寄存器，没控制器时要自己软件模拟时序。

（2）协议层的代码主要取决于gsensor芯片；物理层代码主要取决于主机SoC。

### 12.7.1、gsensor写寄存器：gsensor_i2c_write_reg

### 12.7.2、gsensor读寄存器：gsensor_i2c_read_reg

### 12.7.3、gsensor编程：gsensor_initial等

****

# 13、ADC

## 13.1、ADC的引入

### 13.1.1、什么是ADC

（1）ADC:analog digital converter,AD转换，模数转换（也就是模拟转数字）

（2）CPU本身是数字的，而外部世界变量（如电压、温度、高度、压力···）都是模拟的，所以需要用CPU来处理这些外部的模拟变量的时候就需要做AD转换。

### 13.1.2、为什么需要ADC

（1）为了用数字技术来处理外部的模拟物理量。

### 13.1.3、关于模拟量和数字量

（1）模拟的就是连续的，现实生活当中的时间、电压、高度等都是模拟的（连续分布的，划分的话可以无限的更小划分）。模拟量反映在数学里面就是无限小数位（从0到1之间有无数个数）

（2）数字的就是离散的，离散的就是不连续的。这种离散处理实际上是从数学上对现实中的模拟量的一种有限精度的描述。数字化就是离散化，就是把连续分布的模拟量按照一定精度进行取点（采样）变成有限多个不连续分布的数字值，就叫数字量。

（3）数字化的意义就在于可以用（离散）数学来简化描述模拟量，这东西是计算机技术的基础。

（4）计算机处理参量的时候都是数字化的，计算机需要数字化的值来参与运算。如果系统输入参数中有模拟量，就需要外加AD转换器将模拟量转成数字量再给计算机。

### 13.1.4、有AD自然就有DA

（1）AD是analog to digital，DA自然就是digital to analog，数字转模拟。

（2）纯粹用cpu是不可能实现数字转模拟，因为cpu本身就是数字的。使用一些（具有一些积分或微分效果的）物理器件就可实现数字转模拟。

（3）数字转模拟的作用。譬如可以用来做波形发生器。

****

## 13.2、ADC的主要相关概念

### 13.2.1、量程（模拟量输入范围）

（1）AD转换器是一个电子器件，所以他只能输入电压信号。其他种类的模拟信号要先经过传感器（Sensor）的转换变成模拟的电压信号然后才能给AD。

（2）AD输入端的模拟电压要求有一个范围，一般是0～3.3V或0～5V或者是0～12V等等。模拟电压的范围是AD芯片本身的一个参数。实际工作时给AD的电压信号不能超过这个电压范围。

### 13.2.2、精度（分辨率resolution）

（1）AD转换输出的数字值是有一定的位数的（譬如说10位，意思就是输出的数字值是用10个二进制位来表示的，这种就叫10位AD）。这个位数就表示了转换精度。

（2）10位AD就相当于把整个范围分成了1024个格子，每个格子之间的间隔就是电压的表示精度。假如AD芯片的量程是0～3.3V，则每个格子代表的电压值是3.3V/1024=0.0032265V。如果此时AD转换后得到的数字量是447，则这个数字量代表的模拟值是：447×0.0032265V=1.44V。

（3）AD的位数越多，则每个格子表示的电压值越小，将来算出来的模拟电压值就越精确。

（4）AD的模拟量程一样的情况下，AD精度位数越多精度越高，测出来的值越准。但是如果AD的量程不一样。譬如2个AD，A的量程是0～50V，B的量程是0～0.5V，A是12位的，B是10位的，可能B的精度比A的还要高。（A的精度：50/1024=0.04883，B的精度：0.5/4096=0.000122）

### 13.2.3、转换速率（MSPS与conventor clock的不同）

（1）首先要明白：AD芯片进行AD转换是要耗费时间的。这个时间需要多久，不同的芯片是不一样的，同一颗芯片在配置不一样（譬如说精度配置为10位时时间比精度配置为12位时要小，譬如说有些AD可以配转换时钟，时钟频率高则转换时间短）时转换时间也不一样。

（2）详细的需要时间可以参考数据手册。一般数据手册中描述转换速率用的单位是MSPS（第一个M是兆，S是sample，就是采样；PS就是per second，总的意思就是兆样本每秒，每秒种转出来多少M个数字值）

（3）AD工作都需要一个时钟，这个时钟有一个范围，我们实际给他配置时不要超出这个范围就可以了。AD转换是在这个时钟下进行的，时钟的频率控制着AD转换的速率。注意：时钟频率和MSPS不是一回事，只是成正比不是完全相等。譬如S5PV210中的AD转换器，MSPS = 时钟频率/5

### 13.2.4、通道数

（1）AD芯片有多少路analog input通道，代表了将来可以同时进行多少路模拟信号的输入。

****

## 13.3、S5PV210的ADC控制器

### 13.3.1、ADC和（电阻式）触摸屏的关系

（1）ADC在210的数据手册的Section10.7

（2）电阻式触摸屏本身工作时依赖于AD转换，所以在210的SoC中电阻触摸屏接口本身和ADC接口是合二为一的。或者说电阻触摸屏接口使用了（复用了）ADC的接口。

### 13.3.2、ADC的工作时钟框图

（1）ADCCLK是ADC控制器工作的时钟，也就是1.13.2.3节中讲到的conventor clock。从时钟框图可以看出，它是PCLK（当然是PCLK_PSYS）经过了一次分频后得到的。所以将来初始化ADC控制器时一定有一个步骤是初始化这里的分频器。

### 13.3.3、210的10个ADC通道（注意ADC引脚和GPIO的区别）

（1）210一共支持10个ADC通道，分别叫AIN[0]~AIN[9]。理论上可以同时做10路AD转换。

（2）SoC的引脚至少分2种：digit数字引脚和analog模拟引脚。我们以前接触的GPIO都属于数字引脚，ADC channel通道引脚属于模拟引脚。数字引脚和模拟引脚一般是不能混用的。

### 13.3.4、ADC控制器的主要寄存器

TSADCCON0
TSDATX0  TSDATY0		转出来的AD值存在这里，我们读也是读这里
CLRINTADC0				清中断
ADCMUX					选择当前正在操作的AD通道

（1）等待触摸屏转换完毕的方法有2种：一种是检查标志位，第二种是中断。第一种方式下我们先开启一次转换然后循环不停检查标志位直到标志位为1表明已经转换完可以去读了；第二种方式下就是设置好中断，写好中断isr来读取AD转换数据。然后开启中断后CPU就不用管了，等AD转换完成后会生成一个中断信号给CPU，就会进入中断处理流程。第一种方法是同步的，第二种方式是异步的。

（2）AD转换都是需要反复进行的，那么转完一次一般要立即开启下一次转换，所以需要有一种机制能够在一次转完时自动开启下一次。这个机制就叫start by read，这个机制的工作方法是：当我们读取本次AD转换的AD值后，硬件自动开启下一次AD转换。

****

## 13.4、AD转换的编程实践1

### 13.4.1、AD控制器初始化

### 13.4.2、循环进行AD采样

*****

## 13.5、AD转换的编程实践2

### 13.5.1、编译运行调试

### 13.5.2、start by read模式介绍

（1）应用方法：开启start by read模式，第一次先读一次丢掉，这次读就能开启下一次AD转换，然后以后就可以不停的读取AD值了。

****

# 14、LCD显示器

## 14.1、LCD简介

### 14.1.1、什么是LCD

（1）LCD(Liquid Crystal Display)俗称液晶.

（2）液晶是一种材料，液晶这种材料具有一种特点：可以在电信号的驱动下液晶分子进行旋转，旋转时会影响透光性，因此我们可以在整个液晶面板后面用白光照（称为背光），可以通过不同电信号让液晶分子进行选择性的透光，此时在液晶面板前面看到的就是各种各样不同的颜色，这就是LCD显示。

（3）被动发光和主动发光。有些显示器（譬如LED显示器、CRT显示器）自己本身会发光称为主动发光，有些（LCD）本身不会发光只会透光，需要背光的协助才能看起来是发光的，称为被动发光。

（4）液晶应用领域：电视机、电脑显示屏、手机显示屏、工业显示屏等····

### 14.1.2、其他主流显示设备（LED、CRT、等离子、OLED）

（1）CRT：阴极摄像管显示器。

（2）等离子显示：未成为主流

（3）OLED：目前未成为主流，但是很有市场潜力

（4）LED：主要用在户外大屏幕

（5）LCD：目前是主流显示器

### 14.1.3、LCD的显示原理和特点(液晶分子透光+背光)

（1）白光其实是由各种不同颜色的光组成的，所以白光被选择性透光之后可以产生各种不同颜色的光。

### 14.1.4、LCD的发展史和种类(TN/STN/TFT)

（1）TN最早。坏处是响应性不够好，有拖尾现象。

（2）STN是TN的升级版。有效解决拖尾现象，显示更清晰。

（3）TFT的最大特点就是超薄。

（4）TFT技术之上发展出来很多更新的技术。

****

## 14.2、LCD的接口技术

### 14.2.1、从电平角度来讲本质上都是TTL信号

（1）什么是TTL接口。+5V表示逻辑1，0V表示逻辑0.这种就叫TTL电平，和CMOS电平相对比。

（2）SoC的LCD控制器硬件接口是TTL电平的，LCD这边硬件接口也是TTL电平的。所以他们俩本来是可以直接对接的，手机、平板、开发板都是这样直接对接的（一般用软排线连接）。

（3）TTL电平的缺陷就是不能传递太远，如果LCD屏幕和主板控制器太远（1米甚至更远）就不能直接TTL连接了，要进行转换。转换方式：主机SoC(TTL) ->VGA-> LCD屏幕(TTL)

### 14.2.2、各种接口（TTL、LVDS、EDP、MIPI）

在传输速率、距离、适配性方面不同，参考资料：http://blog.csdn.net/wocao1226/article/details/23870149）

### 14.2.3、RGB接口详解(参考数据手册P1207页时序图)

（1）VD[23:0]：24根数据线，用来传输图像信息。可见LCD是并行接口，速率才够快。

（2）HSYNC(水平同步信号) 

（3）VSYNC(垂直同步信号)：时序信号线，为了让LCD能够正常显示给的控制信号

（4）VCLK(像素时钟)：LCD工作时需要主板控制器给LCD模组一个工作时钟信号，就是VCLK。

（5）VDEN(数据有效标志)：时序信号，和HSYNC、VSYNC结合使用。

（6）LEND(行结束标志，不是必须的)：时序信号，非必须，譬如X210接口就没有。

****

## 14.3、LCD如何显示图像

### 14.3.1、像素(pixel)

（1）像素就是组成图像的最基本元素，或者说显示中可以被控制的最小单位，整个图像就是由很多个像素组成的。

（2）像素可以被单独控制，或控制其亮或不亮（单色屏）、或控制其亮度强弱（譬如亮50%，35%，这样叫灰度屏，以前的黑白电视机）、或控制其显示一定的颜色（这就是我们现在最常用的彩色显示屏）。

总结：像素很重要，整个显示图像是由一个个的像素组成的。我们要在显示器上显示一个图像，就是把这个图像离散化成一个一个的点，然后把各个点的颜色对应在显示器的像素上。

### 14.3.2、扫描

（1）扫描是一个动作而不是一个名字，扫描就是依次将颜色数值放入屏幕中所有的像素的这个过程。

（2）扫描这个词是由最早的CRT显示器遗留下来的，到LCD显示器的年代本来已经失去意义了，但是我们还是延续着这么叫。

（3）显示器的扫描显示原理依赖于人眼的视觉暂留。只要显示器扫描频率大于人眼的发现频率，人眼看到的图像就是恒定的。如果扫描频率偏小人眼就会看到闪动。（扫描频率的概念就叫做刷新率）

### 14.3.3、驱动器&控制器

（1）LCD驱动器一般和LCD显示面板集成在一起（本来是分开的，做面板的是只做面板的，譬如说三星、LG、台湾的友达、奇美都是做面板的；驱动器也由专门的IC厂商生产；集成厂商买来面板和驱动器后集成在一起做成LCD屏幕），面板只负责里面的液晶分子旋转透光，面板需要一定的模拟电信号来控制液晶分子；LCD驱动器芯片负责给面板提供控制液晶分子的模拟电信号，驱动器的控制信号（数字信号）来自于自己的数字接口，这个接口就是LCD屏幕的外部接口（第二节中讲到的接口）

（2）LCD控制器一般集成在SoC内部，他负责通过数字接口向远端的LCD驱动器提供控制像素显示的数字信号。LCD控制器的关键在于时序，它必须按照一定的时序和LCD驱动器通信；LCD控制器受SoC控制，SoC会从内存中拿像素数据给LCD控制器并最终传给LCD驱动器。

### 14.3.4、显示内存(简称：显存)

（1）SoC在内存中挑选一段内存（一般来说是程序员随便挑选的，但是挑选的时候必须符合一定规矩），然后通过配置将LCD控制器和这一段内存（以后称为显存）连接起来构成一个映射关系。一旦这个关系建立之后，LCD控制器就会自动从显存中读取像素数据传输给LCD驱动器。这个显示的过程不需要CPU的参与。

（2）显示体系建立起来后，CPU就不用再管LCD控制器、驱动器、面板这些东西了；以后CPU就只关心显存了，因为我只要把要显示的图像的像素数据丢到显存中，硬件就会自动响应（屏幕上就能自动看到显示的图像了）。

总结：LCD显示是分为2个阶段的：第一个阶段就是建立显示体系的过程，目的就是CPU初始化LCD控制器使其和显存联系起来构成映射；第二个阶段就是映射建立之后，此阶段主要任务是将要显示的图像丢到显存中去。

*****

## 14.4、LCD的六个主要时序参数

### 14.4.1、LCD显示单位：帧（frame）

（1）显示器上一整个画面的内容成为一个帧(frame)，整个显示器工作时是一帧一帧的在显示。

（2）电影实际就是以每秒种24帧的速度在播放图片。

（3）帧内数据：一帧分为多行，一行分为多像素，因此一帧图像其实就是多个像素组成的矩阵。

（4）帧外数据：整个视频由很多个帧构成，最终播放视频时逐个播放各个图像帧即可。

### 14.4.2、LCD显示一帧图像的过程

（1）首先把帧分为行，然后再把行分为像素，然后逐个像素去显示。（显示像素：其实就是LCD驱动器按照接收到的LCD控制器给的显示数据，驱动一个像素的液晶分子旋转，让这个像素显示出相应的颜色值的过程）

（2）关键点：LCD控制器和驱动器之间一次只能传一个像素点的显示数据。所以一帧图像在屏幕上其实是串行的依次被显示上去的，不是同一时间显示出来的。

### 14.4.3、为了向前兼容出现的六个时序参数

HSPW 水平同步信号脉宽
HBPD 水平同步信号前肩
HFPD 水平同步信号后肩
VSPW 垂直同步信号脉宽
VBPD 垂直同步信号前肩
VFPD 垂直同步信号后肩

（1）一行的通信过程是这样的：LCD控制器先发送一个HSYNC高电平脉冲（脉冲宽度是HSPW），脉冲告诉驱动器下面的信息是一行信息。然后开始这一行信息，这一行信息包括3部分：HBPD+有效行信息+HFPD。其中前肩和后肩都属于时序信息（和LCD屏幕具体有关），有效行信息就是横向分辨率。所以你可以认为一行总共包含4部分：HSPW+HBPD+有效行信息+HFPD。

（2）一帧图像其实就是一列，一列图像由多个行组成，每行都是上面讲的这个时序。

（3）一帧图像的通信过程是这样的：整个帧图像信号分为4部分：VSPW+VBPD+帧有效信号+VFPD。VSPW是帧同步信号宽度，用来告诉驱动器一帧图像要开始了；VBPD和VFPD分别是垂直同步信号前后肩。

（4）必须说明：这6个参数对于LCD显示器其实本来是没用的，这些信号其实是老式的CRT显示器才需要的，LCD本身不需要，但是出于历史兼容性要求，LCD选择了兼容CRT显示器的这些时序要求，所以理解LCD显示器时序和编程时，用CRT的方式来理解不会错。

（5）要注意，这几个时序参数本身是LCD屏幕本身的参数，与LCD控制器无关。所以同一个主板如果接的屏幕不一样则时序参数设置也会不同。这些参数的来源一般是：第一，厂家会直接给出，一般以实例代码的形式给出；第二，来自于LCD的数据手册。

第一种方式，查看九鼎的210裸机教程（x210v3裸机开发教程\src\template-framebuffer-font\source\hardware\s5pv210-fb.c的第774行）

>    	 .h_fp			= 210,		// 160-210-354
> 		.h_bp			= 38,		// 46
> 		.h_sw			= 10,		// 1-40
> 		.v_fp			= 22,		// 7-22-147
> 		.v_fpe			= 1,
> 		.v_bp			= 18,		// 23
> 		.v_bpe			= 1,		
> 		.v_sw			= 7,		// 1-20

第二种方式，查看LCD数据手册（X210光盘资料\A盘\DataSheet\AT070TN92.pdf）

补充：
1、注意这些数字的单位。H开头的三个单位都是DCLK(像素时钟),V开头的三个单位是TH。这样设置的好处是我们改变了像素时钟的设置时，不用改变这里的时序参数。
2、这些时序参数如果没设置好会影响什么？屏幕会跑偏。

****

## 14.5、LCD显示的主要相关概念

### 14.5.1、像素（pixel）

（1）整个图像是由一个个的像素组成的，像素就是一个显示点。

### 14.5.2、像素间距（pitch）

（1）pitch是连续2个像素的像素中心的距离。一般的像素是方形的，所以横向pitch和纵向的pitch一样的。但是也有不一样的。

（2）像素间距会影响屏幕的最佳观看距离。像素间距大的适合远距离看，像素间距小的适合近距离看。

### 14.5.3、分辨率（resolution）

（1）整个屏幕的横向和纵向的像素个数就叫分辨率，譬如X210开发板用的屏幕是800×480.

（2）屏幕尺寸和分辨率无关的，像开发板的屏幕尺寸是7寸的（纯屏幕对角线尺寸是7英寸）。

（3）屏幕尺寸和分辨率和像素间距三者之间有关联。

### 14.5.4、清晰度

（1）清晰度是一个主观概念，是人眼对显示效果的一个主观判断。说白了就是人看起来感觉清晰不清晰。

（2）客观来讲，清晰度由分辨率和像素间距共同决定。一般的，屏幕尺寸固定时分辨率越高越清晰，分辨率越低就越不清晰；分辨率固定下，屏幕尺寸越小越清晰，越大越不清晰。

（3）清晰度还由其他很多因素共同决定。

### 14.5.5、像素深度（bits per pixel，简称bpp）

（1）一个像素在计算机中由多少个字节数据来描述。

（2）计算机中用二进制位来表示一个像素的数据，用来表示一个像素的数据位越多，则这个像素的颜色值更加丰富、分的更细，颜色深度就更深。

（3）一般来说像素深度有这么几种：1位、8位、16位、24位、32位。

****

## 14.6、颜色在计算机中的表示

### 14.6.1、颜色的本质

（1）颜色是主观存在，颜色其实是自然光在人的眼睛中和大脑中产生的一种映像。

（2）颜色的本质决定于光的波长。

### 14.6.2、自然光的颜色是连续的

（1）光的波长是连续的，导致颜色也是连续的。理论上，只要你的眼睛分辨能力足够好，可以在自然界中发现无数中颜色。

### 14.6.3、计算机中的颜色是离散的

（1）计算机中不可能存储无数种颜色，所以必须将颜色有限化，所以就用有限种颜色来代表自然界中的无限种颜色。这个理论非常类似于之前学过的AD转换。

（2）这种离散化表达颜色的缺点是不够真实，漏掉了很多种颜色。因此计算机中所能表达的颜色没有自然界中丰富（计算机屏幕上显示的图像和真实图像有差别）

（3）计算机所能表达的颜色种类个数，这个参数叫：像素深度bpp。

### 14.6.4、常见像素深度：1位、8位、16位、24位、32位

1位：用1个二进制位来表示颜色，这种就叫单色显示。示例就是小饭店、理发店门口的LED屏。

8位：用8个二进制位来表示颜色，此时能表示256种颜色。这种叫灰度显示。这时候是黑白的，没有彩色，我们把纯白到纯黑分别对应255到0，中间的数值对应不同的灰。示例就是以前的黑白电视机。

16位：用16个二进制位表示颜色，此时能表示65536种颜色。这时候就可以彩色显示了，一般是RGB565的颜色分布（用5位二进制表示红色、用6位二进制表示绿色、用5位二进制表示蓝色）。这种红绿蓝都有的颜色表示法就是一种模拟自然界中所有颜色的表示方式。但是因为RGB的颜色表达本身二进制位数不够多（导致红绿蓝三种颜色本身分的都不够细致），所以这样显示的彩色失真比较重，人眼能明显看到显示的不真实。

24位：用24个二进制位来表示颜色，此时能表示16777216种颜色。这种表示方式和16位色原理是一样的，只是RGB三种颜色各自的精度都更高了（RGB各8位），叫RGB888。此时颜色比RGB565更加真实细腻，虽然说比自然界无数种颜色还是少了很多，不过由于人眼的不理想性所以人眼几乎不能区分1677万种颜色和无数种颜色的差别了。于是乎就把这种RGB888的表示方法叫做真彩色。（RGB565就是假彩色）

32位：总共用32位二进制来表示颜色，其中24位表示红绿蓝三元色（还是RGB888分布），剩下8位表示透明度。这种显色方式就叫ARGB（A是阿尔法，表示透明度），现在PC机中一般都用ARGB表示颜色。

补充：颜色的组成，三元色（三基色）是RGB，也就是说所有的颜色都可以由红绿蓝三种颜色组成。

****

## 14.7、S5PV210的LCD控制器

### 14.7.1、FIMD结构框图

（1）210的LCD控制器叫FIMD，FIMD是210内部和图像处理相关的一些部件，在摄像头等和图像处理有关的部分都可以有关联。

（3）FIMD在内部与AHB总线等相连接，在外部提供RGB接口、I80接口、YUV接口与外部相连接，我们实际使用的是RGB接口。

### 14.7.2、虚拟屏幕叠加（数据手册P1194）

（1）虚拟屏幕的意思是，我们平时看到的屏幕上显示出来的场景实际是很多个屏幕显示叠加在一起的效果（譬如新闻图像、电视台台标、下方飘动的字幕新闻）

（2）像S5PV210的LCD控制器中有5个虚拟屏幕Window0到Window4，虚拟屏幕不存在于真实而存在于内存中。（之前讲过，LCd显示时实际是显示的是对应的内存中的显存区域的数值）虚拟屏幕其实就是一个内存中的显存区域，有几个显存区域就有几个虚拟屏幕，但是这些虚拟屏幕都被映射到一个真实的显示屏上面，所以将来真实的现实效果实际是这几个虚拟屏幕的显示内容的叠加。（叠加时要注意上面一层会覆盖下面一层，所以要注意谁在前谁在后，设置寄存器时有这个选项）

（3）使用虚拟屏幕而不是整个LCD使用一个显存是有一定好处的：第一，可以保证不污染源图像，方便程序处理；第二，可以减少屏幕刷新，提高显示效率，减少CPU工作量。

### 14.7.3、虚拟显示（数据手册P1206）

（1）如何实现在小分辨率的屏幕上（真实）显示大分辨率的图像

（2）细节上，我们需要屏幕上看到不同图像时，需要对显存区域进行刷新。即使我们只需要屏幕显示移动一点点，整个屏幕对应的显存空间也需要整个重新刷新，工作量和完全重新显示一幅图像是一样的。这个显然不好，这样CPU刷新屏幕的工作量太大了，效率很低。

（3）如何能够在显示一个大图片的不同区域时让CPU刷新屏幕工作量减少？有，方法就是虚拟显示。具体做法就是在内存中建立显示缓存的时候实际建立一个很大的区域，然后让LCD去对应其中的一部分区域作为有效的显示区域。将来要显示大图像时，直接将大图像全部一次性加载入显示缓存区，然后通过移动有效显示区域就可以显示大图像的不同区域了。

****

## 14.8、LCD编程实战1-LCD控制器初始化

参考代码lcd_init函数详解
（1）要想LCD工作，必须给LCD屏幕和显存之间建立一个映射（映射是在CPU初始化LCD控制器来完成的）。本部分就是在完成这个过程（这也是LCD显示的2个阶段的第一阶段，第二阶段中我们只需要给显存中丢入相应的数据，LCD屏幕就会自动显示相应内容）。

```c
#include "main.h"

#define GPF0CON			(*(volatile unsigned long *)0xE0200120)
#define GPF1CON			(*(volatile unsigned long *)0xE0200140)
#define GPF2CON			(*(volatile unsigned long *)0xE0200160)
#define GPF3CON			(*(volatile unsigned long *)0xE0200180)

#define GPD0CON			(*(volatile unsigned long *)0xE02000A0)
#define GPD0DAT			(*(volatile unsigned long *)0xE02000A4)

#define CLK_SRC1		(*(volatile unsigned long *)0xe0100204)
#define CLK_DIV1		(*(volatile unsigned long *)0xe0100304)
#define DISPLAY_CONTROL	(*(volatile unsigned long *)0xe0107008)

#define VIDCON0			(*(volatile unsigned long *)0xF8000000)
#define VIDCON1			(*(volatile unsigned long *)0xF8000004)
#define VIDTCON2		(*(volatile unsigned long *)0xF8000018)
#define WINCON0 		(*(volatile unsigned long *)0xF8000020)
#define WINCON2 		(*(volatile unsigned long *)0xF8000028)
#define SHADOWCON 		(*(volatile unsigned long *)0xF8000034)
#define VIDOSD0A 		(*(volatile unsigned long *)0xF8000040)
#define VIDOSD0B 		(*(volatile unsigned long *)0xF8000044)
#define VIDOSD0C 		(*(volatile unsigned long *)0xF8000048)

#define VIDW00ADD0B0 	(*(volatile unsigned long *)0xF80000A0)
#define VIDW00ADD1B0 	(*(volatile unsigned long *)0xF80000D0)

#define VIDTCON0 		(*(volatile unsigned long *)0xF8000010)
#define VIDTCON1 		(*(volatile unsigned long *)0xF8000014)

#define HSPW 			(40)				// 1~40 DCLK
#define HBPD			(10 - 1)			// 46
#define HFPD 			(240 - 1)			// 16 210 354
#define VSPW			(20)				// 1~20 DCLK
#define VBPD 			(10 - 1)			// 23
#define VFPD 			(30 - 1)			// 7 22 147



// FB地址
#define FB_ADDR			(0x23000000)
#define ROW				(600)
#define COL				(1024)
#define HOZVAL			(COL-1)
#define LINEVAL			(ROW-1)

#define XSIZE			COL
#define YSIZE			ROW

u32 *pfb = (u32 *)FB_ADDR;


// 常用颜色定义
#define BLUE	0x0000FF
#define RED		0xFF0000
#define GREEN	0x00FF00
#define WHITE	0xFFFFFF


// 初始化LCD
static void lcd_init(void)
{
	// 配置引脚用于LCD功能
	GPF0CON = 0x22222222;
	GPF1CON = 0x22222222;
	GPF2CON = 0x22222222;
	GPF3CON = 0x22222222;

	// 打开背光	GPD0_0（PWMTOUT0）
	GPD0CON &= ~(0xf<<0);
	GPD0CON |= (1<<0);			// output mode
	GPD0DAT &= ~(1<<0);			// output 0 to enable backlight

	// 10: RGB=FIMD I80=FIMD ITU=FIMD
	DISPLAY_CONTROL = 2<<0;

	// bit[26~28]:使用RGB接口
	// bit[18]:RGB 并行
	// bit[2]:选择时钟源为HCLK_DSYS=166MHz
	VIDCON0 &= ~( (3<<26)|(1<<18)|(1<<2) );

	// bit[1]:使能lcd控制器
	// bit[0]:当前帧结束后使能lcd控制器
	VIDCON0 |= ( (1<<0)|(1<<1) );

	// bit[6]:选择需要分频
	// bit[6~13]:分频系数为5，即VCLK = 166M/(4+1) = 33M
	VIDCON0 |= 4<<6 | 1<<4;


	// H43-HSD043I9W1.pdf(p13) 时序图：VSYNC和HSYNC都是低脉冲
	// s5pv210芯片手册(p1207) 时序图：VSYNC和HSYNC都是高脉冲有效，所以需要反转
	VIDCON1 |= 1<<5 | 1<<6;

	// 设置时序
	VIDTCON0 = VBPD<<16 | VFPD<<8 | VSPW<<0;
	VIDTCON1 = HBPD<<16 | HFPD<<8 | HSPW<<0;
	// 设置长宽(物理屏幕)
	VIDTCON2 = (LINEVAL << 11) | (HOZVAL << 0);

	// 设置window0
	// bit[0]:使能
	// bit[2~5]:24bpp（RGB888）
	WINCON0 |= 1<<0;
	WINCON0 &= ~(0xf << 2);
	WINCON0 |= (0xB<<2) | (1<<15);

#define LeftTopX     0
#define LeftTopY     0
#define RightBotX   1023
#define RightBotY   599

	// 设置window0的上下左右
	// 设置的是显存空间的大小
	VIDOSD0A = (LeftTopX<<11) | (LeftTopY << 0);
	VIDOSD0B = (RightBotX<<11) | (RightBotY << 0);
	VIDOSD0C = (LINEVAL + 1) * (HOZVAL + 1);


	// 设置fb的地址
	VIDW00ADD0B0 = FB_ADDR;
	VIDW00ADD1B0 = (((HOZVAL + 1)*4 + 0) * (LINEVAL + 1)) & (0xffffff);

	// 使能channel 0传输数据
	SHADOWCON = 0x1;
}
```



*****

## 14.9、LCD编程实战2-显示像素&刷背景

（1）显示像素
（2）刷背景色

****

## 14.10、LCD编程实战3-横线竖线斜线&画圆

（1）画横线&竖线
（2）斜线

****

## 14.11、LCD编程实战4–写英文中文字符

****

## 14.12、LCD编程实战5-画图

### 14.12.1、图片显示分析

（1）图像是彩色的，而之前的文字、图形都是单色的。之前的图形文字绘制函数都有个color参数，就是传给显存告诉它这个像素的显示颜色。

（2）一副分辨率是800×480，BPP是24的图片，实际上就是800×480×3字节的数据。将来写代码将图片显示到LCD中时，图片将会以 unsigned char pic_data[800×480×3]的形式出现。

### 14.12.2、Image2LCD使用简介

（2）如何由一副图片得到它对应的数据的数组？要用取模工具，如Image2LCD。

****

## 14.13、LCD编程实战6-画图测试及调试

### 14.13.1、画图函数的显示效果测试

### 14.13.2、RGB的像素顺序调整

（1）图片中红色的变成了蓝色、蓝色的变成了红色，这就说明RGB顺序反了。

（2）解决方案一：重新使用Image2LCD来取模，取模时RGB顺序对调。

（3）解决方案二：不重新取模，改代码，在color形成的时候调换顺序。

### 14.13.3、小分辨率图片显示

（1）本质上大小分辨率的图像显示都是一样的，都是：都是在图像的每个像素点对应的显存中填入相应的颜色值即可。

****

## 14.14、未完成事项展望

### 14.14.1、RGB565和RGB888

（1）单片机等性能和资源有限的平台会用RGB565，嵌入式平台习惯用RGB888.

（2）有时候手头只有RGB888的颜色值，但是显示部分却只接受RGB565的（有时候反过来），这时候就需要在2种颜色之间做转换。

### 14.14.2、不同分辨率、不同起点坐标下的显示

（1）屏幕分辨率和图像分辨率不同时的显示。我们现在写的代码都是没有考虑的。

（2）图像起点坐标（左上角坐标）不一定在屏幕左上角，也可能在屏幕的任何其他区域，这种情况下画图的函数要做处理来支持。

（3）分辨率不同而且起始坐标不同下，这两个问题组合起来也对画图函数提出了更高要求。

### 14.14.3、bmp图片格式解析及显示

（1）我们当前的图像数据是用Image2LCD工具转过来的。实践中是不可能手工用工具来转的（你想一下Image2LCD也是一个软件，既然它能转，我们也应该可以用软件来转）

（2）bmp格式的图片本身遵照一定的格式来存储的，我们只需按照bmp的解析格式来读取文件就可得到这幅图片的图像数据的二进制，直接拿去显示。（这就是图片文件的本质）

### 14.14.4、jgp、png、gif等压缩图片的解码和显示

（1）对于以上压缩格式的图片是不能直接解析的，必须用相应的库来解压缩图片之后才能拿来显示。

（2）不同的格式的图片其压缩算法不同，解压缩算法自然也不同。开源社区中每种压缩格式都有个对应的库，库里提供了这种格式的压缩和解压缩函数，我们只需要移植这个库并且调用它来压缩或解压缩即可。

### 14.14.5、图片缩小和放大显示

（1）图片数据源本来是400×200的，但是显示时我希望显示成100×50的，这时候就要显示函数后台对源图像进行先缩小，然后再显示。这时候就需要一个缩小算法。（譬如最简单的算法就是抽点采样）

（2）图片数据源是100×50的，但是显示时希望全屏显示（800×480），这时候就需要对源图像进行放大然后再显示（当然了显示出来图像清晰度肯定比较低），这时候就需要一种放大算法（譬如插点方式）

### 14.14.6、显示动画

（1）动态刷屏形成动画
（2）立体3D图像显示（伪3D）

****

# 15、触摸屏Touchscreen

## 15.1、输入类设备简介

### 15.1.1、input/output

（1）IO输入输出，是计算机系统中的一个概念。计算机的主要功能就是从外部获取数据然后进行计算加工得到输出数据并输出给外部（计算机可以看成数据处理器）。计算机和外部交互就是通过IO。每一台计算机都有个标准输入和标准输出。

### 15.1.2、常见输入类设备

（1）键盘、鼠标、触摸屏、游戏摇杆、传感器、（摄像头并不是一个典型的输入类设备）

### 15.1.3、触摸屏的特点

（1）触摸屏和人的关系很紧密，尤其是电容式触摸屏。

（2）触摸屏和显示器关系很紧密。

（3）典型应用：手机、平板电脑、收银机、工业领域。

### 15.1.4、触摸屏的分类

（1）常见的触摸屏分为2种：电阻式触摸屏和电容式触摸屏。早期用电阻式触摸屏，后来发明了电容式触摸屏。

（2）这两种的特性不同、接口不同、编程方法不同、原理不同。

### 15.1.5、触摸屏和显示屏的联系与区别

（1）首先要搞清楚：触摸屏是触摸屏，用来响应人的触摸事件的；显示屏是显示屏，用来显示的。现在用的显示屏一般都是LCD。

（2）为什么很多人会搞混这两个概念，主要是因为一般产品上触摸屏和显示屏是做在一起的。一般外层是一层触摸屏，触摸屏是透明的，很薄；底下是显示屏用来显示图像，平时看到的图像是显示屏显示并且透过触摸屏让人看到的。

****

## 15.2、电阻式触摸屏的原理

### 15.2.1、薄膜+玻璃（需要尖锐硬物点击）

（1）要点是薄、透明。前面板硬度稍弱，可以被硬物按下弯曲，后面板硬度很高，不会弯曲。

（2）前面板和后面板在平时没有挨住，在外力按下之下，前面板发生（局部）形变，在这一点上前后面板会挨住。

### 15.2.2、ITO（导电+透明+均匀压降）

（1）ITO是一种材料，其实是一种涂料，特点就是透明、导电、均匀涂抹。

（2）本来玻璃和塑料都是不导电的，但是涂上ITO之后就变成导电了（同时还保持着原来透明的特性）。

（3）ITO不但导电而且有电阻，所以中间均匀涂抹了ITO之后就相当于在x1和y1之间接了一个电阻，在x2和y2之间也接了一个电阻。因为ITO形成的等效电阻在整个板上是均匀分布的，所在在板子上某一点的电压值和这一点的位置值成正比。

（4）触摸屏经过操作，按下之后要的就是按下的坐标，坐标其实就是位置信息，这个位置信息和电压成正比了，而这一点的电压可以通过AD转换得到。这就是整个电阻式触摸屏的工作原理。

### 15.2.3、X/Y轴分时AD转换

（1）下面要研究如何得到按下的这点的电压。

（2）在第一个面板的一对电极上加电压，然后在另一个面板的一个电极和第一个面板的地之间去测量。在没有按下时测试无结果，但是在有人按下时在按下的那一点2个面板接触，接触会导致第二个面板上整体的电压值和接触处的电压值相等，所以此时测量到的电压就是接触处在第一个面板上的电压值。

（3）以上过程在一个方向进行一次即可测得该方向的坐标值，进行完之后撤掉电压然后在另一个方向的电极上加电压，故伎重施，即可得到另一个方向的坐标。至此一次触摸事件结束。

### 15.2.4、电压值对应坐标值（校准）

（1）电压值和坐标值成正比的，所以需要去校准它。校准就是去计算(0, 0)坐标点的电压值是多少。

### 15.2.5、思考：为什么电阻式触摸屏不支持多点触摸

当两点同时受压时，屏幕的压力变得不平衡，导致触控出现误差，因而多点触控的实现程度较难。

****

## 15.3、S5PV210的电阻触摸屏控制器

### 15.3.1、ADC与触摸控制器结构框图

（1）S5PV210一共支持10路模拟输入，分别为AIN0-AIN9.其中AIN0和AIN1是只做模拟输入的，AIN2-AIN9分别可以支持2个电阻式触摸屏。所以4个模拟输入引脚负责一个电阻式触摸屏。

（2）AD转换和触摸屏控制部分有2个附属单元。其中一个是反向控制AINn引脚的逻辑，主要作用是在触摸屏获取坐标的过程中分时给xy方向供电和测量；第二个是中断产生部件，如果AD转换完成（主要针对AIN0和AIN1这两路的）或者触摸屏被人按下/弹起时，中断产生部件会产生一个中断通知CPU来处理事件，这样就不用轮询监测触摸屏事件了。

### 15.3.2、Normal Operation Mode & Separate X/Y Position Convertion Mode

（1）AD转换器有2种工作模式：正常操作模式和分时X/Y位置转换模式。

（2）正常操作模式用作普通的AD转换，分时X/Y位置转换模式用作电阻式触摸屏。正常AD转换下将AD转换值放在TSDATX中，在分时X/Y模式下会将X/Y坐标分别放在TSDATX和TSDATY中。

（3）对于AIN0和AIN1来说没有这么多模式，他们只能工作在普通模式；对于AIN2-AIN9来说，因为被复用，所以才有2种模式。如果我们将这几个引脚用作普通AD转换则配置为普通模式，如果用作电阻式触摸屏检测，则配置成分时X/Y模式。

### 15.3.3、中断参与

（1）其实普通AD转换和触摸屏AD转换本身都可以不在中断参与下完成。

（2）普通AD转换如果不要中断，那就去查询。开启一次转换后然后不断查询标志位，直到AD转换完硬件自动置位标志位后我们才去读取转换值就不会错。当然也可以用中断，控制器提供了一个相应的中断给普通AD转换。

（3）触摸屏也可以用或者不用中断。对于SoC来说永远不知道人会什么时候按下或者弹起触摸屏，所以触摸屏的按下/弹起对SoC来说是纯粹的异步事件。对于这种情况SOC只有2种解决方案：轮询和中断。

****

## 15.4、电容触摸屏的原理

### 15.4.1、人体电流感应

（1）利用人体电流感应现象，在手指和屏幕之间形成一个电容，手指触摸时吸走一个微小电流，这个电流会导致触摸板上4个电极上发生电流流动，控制器通过计算这4个电流的比例就能算出触摸点的坐标（这个计算过程中涉及到AD转换）。

### 15.4.2、专用电路计算坐标

（1）电阻式触摸屏本身是一个完全被动器件，里面没有任何IC和电路，它的工作逻辑完全在SoC控制器上；但是电容式触摸屏不同，电容式触摸屏需要自带一个IC进行坐标计算。因此电容式触摸屏工作时不需要主机SoC控制器参与。

（2）为什么这样设计？主要原因是因为电容式触摸屏的坐标计算太复杂，普通程序员无法写出合适的代码解决这个问题，因此在电容式触摸屏中除了触摸板之外还附加了一个IC进行专门的坐标点计算和统计。这个IC全权负责操控触摸板得到触摸操作信息，然后再通过数字接口和主机SoC进行通信。

### 15.4.3、多个区块支持多点触摸

（1）电阻触摸屏不支持多点触摸，这是它本身的原理所限制，无法改变无法提升。

（2）电容式触摸屏可以支持多点触摸（也可以单点触摸）。按照之前讲的电容式触摸屏的原理，单个电容式触摸屏面板也无法支持多点触摸，但是可以将一个大的触摸面板分成多个小的区块，每个区块相当于是一个独立的小的电容式触摸屏面板。

（3）多个区块支持多点触摸让电容触摸屏坐标计算变复杂了，但是这个复杂性被电容触摸IC吸收了，还是通过数字接口和主机SoC通信报告触摸信息（触摸点数、每个触摸点的坐标等）。

### 15.4.4、对外提供I2C的访问接口

（1）整个电容触摸屏包含2部分：触摸板和电容触摸IC。触摸板就是一个物理器件，电容触摸IC一般做到触摸屏的软排线（FPC）上面，电容触摸IC负责操控触摸板、通过AD转换和分析得到触摸点个数、触摸坐标等信息，然后以特定的数字接口与SoC通信。这个数字接口就是I2C。

（2）对于我们主机SoC来说，电容式触摸屏其实就是一个I2C从设备。主机只需要通过I2C总线对这个从设备进行访问即可（从设备有自己特定的从设备地址）。从这里来讲，其实电容式触摸屏和其他的传感器（gsensor等）并没有任何区别。

****

## 15.5、ft5x06电容触摸IC简介

### 15.5.1、电阻式触摸屏和电容式触摸屏的特点对比

（1）耐久性		电容式触摸屏不容易坏，电阻式触摸屏易坏

（2）抗干扰性		电容式触摸屏差一些，电阻式触摸屏要好一些

（3）精准度		电容式触摸屏差一些，电阻式触摸屏好一些

（4）用户体验		电容式触摸屏要好一些，电阻式触摸屏要差一些

（5）价格			电容式触摸屏贵一些，电阻式触摸屏便宜很多

### 15.5.2、思考：为什么工业应用中要用电阻式触摸屏？

（1）消费电子产品（手机、平板电脑）用电容式触摸屏。但是在工业领域都是用电阻式触摸屏，就是因为工业领域环境比较恶劣，电容式触摸屏容易受干扰，所以不合适。

### 15.5.3、触摸屏的发展方向

（1）更薄、更透明、更精准、支持点数更多。

（2）把电容触摸屏和LCD做在一起。可以做到更薄、更透明、价格更低。但是面临的困难是抗干扰性要求更高。

### 15.5.4、ft5x06的数据手册浏览

（1）软件工程师并不关心触摸屏的工艺问题，只关心软件编程接口（物理层是I2C）。

****

# 16、shell原理和问答机制引入

## 16.1、什么是shell

### 16.1.1、壳与封装

（1）shell就是壳的意思，在计算机中经常提到shell是用户操作接口的意思。

（2）因为计算机程序本身很复杂，里面的实现和外面的调用必须分开。接口本身就是对内部复杂的实现的一种封装，外部只需要通过接口就可以很容易的实现效果，但是却不用理会内部实现的复杂性和原理。

### 16.1.2、程序或操作系统的用户接口

（1）操作系统运行起来后都会给用户提供一个操作界面，这个操作界面就叫shell。用户可以通过shell来调用操作系统内部的复杂实现。

（2）shell编程就是在shell层次上进行编程。譬如linux中的脚本编程、windows中的批处理。

### 16.1.3、两种shell：GUI和cmdline

（1）GUI（图形用户界面），特点是操作简单、易学易用，适合使用电脑来工作的人。

（2）cmdline(命令行界面)，譬如linux的终端和windows的cmd，特点是不易用易学，优点是可以进行方便的shell编程，适合做开发的人。

（3）展望：将来的shell应该是声音图像等接口的。

### 16.1.4、shell的运行原理：由消息接收、解析、执行构成的死循环

（1）我们主要分析命令行shell的运行原理。

（2）命令行shell其实就是一个死循环。这个死循环包含3个模块，这3个模块是串联的，分别是命令接收、命令解析、命令执行。

（3）命令行有一个标准命令集，用户在操作的时候必须知道自己想要的操作用通过哪个命令来实现，不能随便输入命令。如果用户输入了一个不是标准命令的命令（不能识别的命令），提示用户这不是一个合法命令，然后重新回到命令行让用户输入下一个命令。

（4）用户输入命令的界面是一个命令行，命令行的意思就是用户输入的命令是以行为单位的，更好理解的说用户输入的命令在用户按下回车键之后就算是结束了，shell可以开始接收了。

### 16.1.5、shell举例：uboot、linux终端、Windows图形界面等

（1）常见的shell，uboot就是一个裸机程序构成的shell（本课程要完成的shell也是裸机的），clinux终端和windows的cmd是操作系统下的命令行shell。windows图形界面、ubuntu图形界面、android的图形界面这些都是图形界面的shell。突然想到另一个类型的shell，网页类型的shell，典型代表就是路由器。

****

## 16.2、shell实战1-从零写最简单shell

### 16.2.1、使用printf和scanf做输入回显

```c
/*
 * @Author: Enos Ji
 * @Date: 2021-06-26 09:31:44
 * @LastEditors: Enos Ji
 * @LastEditTime: 2021-06-26 09:49:28
 * @FilePath: \ubuntu_share\x210\shell\1.shell_echo\main.c
 * @Description: 简单的shell命令——实现回显
 */
#include <stdio.h>
#include <string.h>

#define MAX_LINE_LENGTH 256                 //定义命令行最大长度

int main(int argc, char const *argv[])
{
    char str[MAX_LINE_LENGTH];              //用来存放用户输入的命令内容
    
    while(1)
    {
        //打印命令行提示符
        printf("enosji#");

        //清除字符串
        memset(str, 0, sizeof(str));

        //shell三部曲：第一步：获取用户输入的命令
        scanf("%s",str);
        while(getchar() != 10);

        //第二步：解析用户输入命令

        //第三步：处理用户输入命令
        printf("%s\n", str);
    }
    

    return 0;
}

```



### 16.2.2、定义简单命令集

```c
/*
 * @Author: Enos Ji
 * @Date: 2021-06-26 09:31:44
 * @LastEditors: Enos Ji
 * @LastEditTime: 2021-06-26 10:17:37
 * @FilePath: \ubuntu_share\x210\shell\2.shell_cmd\main.c
 * @Description: 简单的shell命令——实现命令解析
 */
#include <stdio.h>
#include <string.h>

#define MAX_LINE_LENGTH 256                 //定义命令行最大长度


//宏定义一些标准命令
#define LED             "led"
#define LCD             "lcd"
#define PWM             "pwm"

#define CMD_NUM     3                 //当前系统定义的命令数
 
//定义一个字符串数组用来打包我们宏定义的字符串
char g_cmdset[CMD_NUM][MAX_LINE_LENGTH];


//初始化命令列表
static void init_cmd_set(void)
{
    memset(g_cmdset, 0, sizeof(g_cmdset));      //全部清零

    strcpy(g_cmdset[0], LED);
    strcpy(g_cmdset[1], LCD);
    strcpy(g_cmdset[2], PWM);

}



int main(int argc, char const *argv[])
{
    int i = 0;

    char str[MAX_LINE_LENGTH];              //用来存放用户输入的命令内容

    init_cmd_set();
    
    while(1)
    {
        //打印命令行提示符
        printf("enosji#");

        //清除字符串
        memset(str, 0, sizeof(str));

        //shell三部曲：第一步：获取用户输入的命令
        scanf("%s",str);
        while(getchar() != 10);

        //第二步：解析用户输入命令
        //遍历命令列表
        for (i = 0; i < CMD_NUM; i++)
        {
            if (!strcmp(str, g_cmdset[i]))
            {
                //相等就执行这个命令的功能
                printf("%s\n", str);
                break;
            }
        }
        if (i >= CMD_NUM)
        {
            //如果没有找到和输入一样的命令就进入这里
            printf("Command '%s' not found\n", str);
        }

        //第三步：处理用户输入命令
        
    }
    

    return 0;
}


```

****

## 16.3、shell实战2-将简易shell移植到开发板中

### 16.3.1、工程选定、文件复制、Makefile书写

### 16.3.2、printf和scanf函数（本质是putc和getc函数）的移植

（1）puts和putchar函数比较简单，注意的地方就是windows和linux中的回车键定义的不同。
所以在putchar函数中如果用户要输出'\n'时，实际输出"\r\n"

（2）gets和getchar是从Windows中的SecureCRT终端输入字符串到裸机程序中。这里面至少有2个问题：用户输入回显问题、用户按回车键问题、用户按BackSpace退格键问题

（3）自己实现回显

（4）用户按回车键问题，在getchar中解决。方法是碰到'\r'时直接返回'\n'

****

## 16.4、shell实战3-定义标准命令集及解析

### 16.4.1、添加cmd_parser和cmd_exec

### 16.4.2、实现简单的cmd_parser

### 16.4.3、实现对应的cmd_exec

****

## 16.5、shell实战4-添加第一个命令

### 16.5.1、命令任务分析

（1）第一个命令：led，实现的功能是控制板载LED的亮和灭

（2）命令定义：led on 表示点亮led，led off 熄灭led

（3）扩展：led 1 on 表示点亮第一个led。（课堂不实现，留给大家做作业）

### 16.5.2、命令解析

（1）命令解析其实就是把一个类似 led on这种命令解析成led和on两个字符串，放在一个字符串数组中。

****

## 16.6、shell实战5-添加其他命令

### 16.6.1、第一个硬件LED的控制

### 16.6.2、扩展其他硬件命令

****

## 16.7、shell实战7-实现开机倒计时自动执行命令1

（1）计时功能。要用计时的部件（定时器）来完成。
（2）主程序
注意：C语言中声明全局变量时不能加初始化，如果加了编译器就会把这个声明当作定义

****

## 16.8、.shell实战8-初步实现环境变量

环境变量就好象程序的全局变量一样，整个程序中唯一。可以影响程序的执行，环境变量可以支持一些命令来查询环境变量、设置环境变量、保存环境变量（必须借助flash才能完成。本节只在内存中实现环境变量所以无法保存）。
