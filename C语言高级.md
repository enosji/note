# 1、内存这个大话题

## 1.1、程序为什么需要内存

### 1.1.1、计算机程序运行的目的

​		计算机为什么需要编程？编程已经编了这么多年了，已经写了很多程序，为什么还需要写程序？

​		程序的目的是为了运行，程序运行是为了达到一定的结果。计算机就是为了用来计算的，所有的计算机程序其实就是在做计算，计算就是在计算数据。所以计算机程序中很重要的一部分就是数据。

计算机程序 = 代码 + 数据		计算机程序运行完得到一个结果，就是说代码 + 数据（经过运行后）= 结果

从宏观上理解，代码就是动作，就是加工数据的的动作；数据就是数字，就是被代码加工的东西。

那么可以得到结论：程序运行的目的不外乎两个：结果、过程

用函数来类别：函数的形参就是代加工的数据（函数内还需要一些零时数据，就是局部变量），函数本体就是代码，函数的返回值就是结果，函数的执行就是过程。

### 1.1.2、计算机程序的运行过程

​		计算机程序的运行过程，其实就是程序很多个函数相机运行的过程。程序是由很多个函数组成的，程序的本质就是函数，函数的本质就是加工数据的动作。

### 1.1.3、冯诺依曼结构和哈佛结构

冯诺依曼结构就是：数据和代码放在一起。

哈佛结构就是：代码和数据分开存放

什么是代码：函数

什么是数据：全局变量、局部变量

​	在S5PV210中运行的Linux系统中，运行应用程序时：这时候所有的应用程序的代码和数据都在DRAM上面，所以这种结构就是冯诺依曼结构；在单片机中，我们把程序烧写到Flash（NorFlash）中，然后程序在Flash中原地执行，程序中所涉及到的数据（全局变量、局部变量）不能放在Flash中，必须放到ARM(SRAM)中。这种结构就叫哈佛结构。

### 1.1.4、动态内存DRAM和静态内存SRAM

DRAM是动态内存：对于DRAM来说，周期性地充电是一个无可避免的要件。由于这种需要定时刷新的特性，因此被称为“动态”存储器。

SRAM是静态内存：相对来说，静态存储器（SRAM）只要存入数据后，纵使不刷新也不会丢失记忆。

### 1.1.5、总结，为什么需要内存

​	内存使用了存储可变数据的，数据在程序中表现为全局变量、局部变量等（在gcc中，其实常量也是存储在内存中的）（大部分单片机中，常量是存储在Flash中，也就是代码段），对我们写程序来说非常重要，对程序运行更是本质相关

​	所以内存对程序来说几乎是本质需求，越简单的程序需要越少的内存，而越庞大越复杂的程序需要越大的内存，内存管理是我们写程序时很重要的一个话题，我们以前学过了解过的很多的编程的关键其实都是为了内存，列如说数据结构（研究数据时如何组织的，数据就是放在内存中的）和算法（是为了用更优秀更有效的方法来加工数据，既然跟数据有关就离不开内存）。

### 1.1.6、如何管理内存（无OS时，有OS时）

​	对于计算机来说，内存容量越大则可能性越大，所以大家都希望自己的电脑内存更大，我们写程序时如何管理内存就成了大问题，如果管理不善，可能会造成程序运行消耗过多的内存，这样迟早内存都被你这个程序吃光了，当没有内存的时候程序就会崩溃。所以内存对程序来说是种资源，所以管理内存对程序来说是个重要的技术和话题。

先从操作系统来说：操作系统掌握了所有硬件内存，因为内存很大，所以操作系统把内存分成一个一个的页面（其实就是一块，一般时4kb），然后以页面为单位来管理，页面内用更细的方式以字节为单位管理。操作系统内存管理的原理很复杂、很麻烦。对于我们这些使用操作系统的人来说不需要了解细节，操作系统给我们提供了内存管理的一些接口，我们只需要用API即可管理内存，列如在C语言中使用malloc free这些接口来管理内存

没用操作系统时：其实就是逻辑程序，程序需要直接操作内存，编程者需要自己计算内存的使用和安排。如果编程者不小心把内存使用错了，错误结果需要自己承担。

从语言角度来讲：不同语言提供了不同的操作内存的接口，列如说汇编，根本没有任何内存管理，内存管理全靠程序员自己，汇编中操作内存时直接使用内存地址，非常麻烦；

​	在C语言中编译器帮我们管理直接内存地址，我们通过编译器提供的变量名等来访问内存的，操作系统下如果需要大块内存，可以通过API（malloc free）来访问系统内存，裸机系统中需要大块内存需要自己定义数组等来解决。

​	在C++语言对内存的使用进一步封装，我们可以用new来创建对象（其实就是对象的分配），然后使用delete来删除对象，如果忘记了就会造成这个对象所占用的内存无法释放，这就是内存泄露。

​	在java\c#中，这些语言不直接操作内存，而是通过虚拟机来操作内存，这要虚拟机作为程序员的代理，来帮我们处理内存释放工作，就算我们自己忘记释放内存，虚拟机会帮我们处理。虚拟机回收内存是需要付出代价的，当我们对程序性能非常在乎的时候就会用C\C++，如果我们对开发程序的速度非常在乎的时候，就会用JAVA\C#等语言。

****

## 1.2、位、字节、半字、字的概念和内存位宽

### 1.2.1、什么是内存

​	从硬件角度：内存实际上是电脑上的一个配件（一般叫内存条）。根据不同的硬件实现原理可以把内存分为SRAM（不需要初始化）和DRAM（需要先初始化，DRAM有分好多代，列如最早的SDRAM、后来的DDR1、DDR2、）

​	从逻辑角度：内存就是这样一种东西，它可以随机访问（随机访问意思就是只要给一个地址，就可以访问这个内存地址）、并且可以读写（当然逻辑上可以限制其的只读只写）；内存在编程中天然是用来存放变量的（就是因为有了内存，C语言才可以定义变量，C语言中的一个变量实际上就对应内存的一个单元）

### 1.2.2、内存的编程模型

​	从逻辑角度上来讲，内存实际上是由无限多个内存单元格组成的，每个单元格有一个固定的地址叫内存地址，这个内存地址和这个内存单元格唯一且永久绑定。实际的内存的大小是有限制的，列如32位的系统（指的是32位数据总线，一般地址线也是32位，这个地址线32位决定了内存的地址就只能位32位二进制，所以逻辑上的大小就是2的32次方大小）内存限制就是4G，实际上32位系统中可以使用的内存是小于等于4G

### 1.2.3、位和字节

​	内存单元的大小单位有4个：位（1bit）、字节（8bit）、半字（一般是16bit）、字（一般是32bit）

​	在所有的计算机里，所有的机器里，位永远是1bit，字节永远是8bit。

### 1.2.4、字和半字

​	历史上曾经出现过16位系统、32位系统、64位系统三种，而且操作系统还有Windows、Linux、ios等很多，所以很多概念在历史上曾经被混乱的定义过。

建议大家对字、半字、双字这些概念不要详细区分，只要知道这些单位的具体多少位是依赖于平台的。实际工作中在每个平台上想去搞清楚这个平台的定义（字是多少位，半字永远是字的一般，双字永远是字的两倍大小）

编程时一般用不到字的概念，我们区分主要是因为有些文档中会用到这些概念，如果不加区分可能会导致你对程序的误解。

在Linux+ARM这个软硬件平台上，字是32位的。

### 1.2.5、 内存位宽

​	从硬件角度：硬件内存的实现本身就是有宽度的，也就说有些内存条就是8位的，而有些就是16位的。需要强调的是内存之间是可以并联的，通过并联是可以把即使是8位的内存芯片做出来16位32位的硬件内存的。

​	从逻辑角度：内存宽度是任意的，甚至逻辑上存在内存位宽是24位的内存（但是这种内存是买不到的，也没有意义）。从逻辑上说不管内存位宽是多少，我就直接操作即可，对我们的操作不构成影响，但是因为你的操作不是纯逻辑的而是需要硬件去执行的，所以实际上不能为所欲为，所以我们实际的很多操作都是受限于硬件的特性的，列如24位的内存逻辑上和32位的内存没有任何区别，但是实际上硬件都是32位的，都要按照32位硬件的特性和限制干活。

*****

## 1.3、内存的编址和寻址、内存对齐

### 1.3.1、内存编制方法

​	内存在逻辑上就是一个一个的格子，这些格子可以用来装东西（里面装的就是内存中存储的数），每个格子都有一个编号，这个编号就是内存地址，这个内存地址和这个空间是一一对应且永久绑定的。这就叫内存的编址方法。

​	在程序运行时，计算机中CPU只认识内存地址，而不关心这个地址所代表的空间在哪里，怎么分布的这些实体问题，因为硬件设计保证的按照这个地址就一定能找到这个格子，所以说内存单元的2个概念：地址和空间时内存单元的两个方面。

### 1.3.2、关键：内存编址是以字节为单位的

​	我随便给一个数字，说这个数字是内存地址，然后我问你这个内存地址对应的空间多大？这个大小是固定的，就是一个字节（8位）。

### 1.3.3、内存和数据类型

C语言中的基本数据类型：char  short  int  long  float  double

int  整形（整数类型），这个整形（就体现在它和CPU本身的数据位宽是一样的）列如32位的CPU，整形就是32位的，int就是32位的。

数据类型和内存的关系就在于：

​	数据类型是用来定义变量的，而这些变量需要存储、运算在内存中。所以说我们的数据类型必须和内存匹配才能获得最好的性能，否则可能不工作或者效率低下。在32位的系统里面定义变量最好用int，因为这样效率最高。原因就在于32位的系统本身配合的内存也是32位，这样的硬件配置天生适合定义32位int型 变量，效率最好。

​	在很多32位的环境下，我们实际定义bool类型变量（实际上1bit就够了），都是用int来实现bool的，我定义一个bool b1时，编译器实际上帮我们分配了32位的内存来存储这样实际上浪费了31位的内存，但是好处时效率高。

问题：实际编程时，是要省内存为大还是以运行效率为重？答案是不定的，但实际情况，很多年前内存很贵机器内存很少，那时候是以省内存为主。现在内存便宜了，不在乎那点内存，而效率和用户体验变成了关键。现在写程序大部分情况小是以效率为主。

### 1.3.4、内存对齐

我们在c中int a；定义一个int变量，在内存中必须分配4个字节来存储这个a。有两种分配思路和策略：

第一种：0 1 2 3																					对齐访问

第一种：1 2 3 4 或者 2 3 4 5  或者 3 4 5 6 这要连着的四个字节就好 非对齐访问

内存的对齐访问不是逻辑问题，是硬件问题，从硬件上来说，32为的内存它0 1 2 3四个单元本身逻辑上就是有相关性的，者4个字节组合起来当作一个int，硬件上就是合理的，效率最高。

对齐访问很配合硬件所以效率很高；而非对齐访问因为和硬件本身不搭配所以效率不高（因为兼容性的原因，一般的硬件也会提供非对齐访问，但是效率不高）

### 1.3.5、从内存编址来看数组的意义

****

## 1.4、C语言如何操作内存

### 1.4.1、C语言对内存地址的封装

​	例如在C语言中 int a；a = 5； a + =4；//a = 9；

结合内存来解析C语言语句的本质：

int a；//编译器帮我们申请了一个int类型的内存格子（长度是4个字节，地址是确定的只有编译器知道，我们不知道），并且把符号a和这个格子进行绑定

a = 5；//编译器发现我们要给a赋值，编译器就会把5丢到a绑定的那个格子里

a += 4；//编译器发现我们要给a加值，a += 4 等效于 a = a + 4；编译器就会把a原来的值读出来，然后给这个值加4，在把加出来的值写入a里面去。

​	C语言中数据类型的本质含义是：表示一个内存格子的长度和解析方法。

之前讲过一个很重要的概念：内存单位的编址单位是字节，定义类型就是定义从这个地址往后延续多少字节

数据类型决定长度的含义：我们一个内存地址（0x3000），本来这个地址只代表一个字节的长度，但是实际上我们可以通过给它一个数据类型（int），让他有了长度（4），这样这个代表内存地址的数字（0x3000）就能代表从这个数字开头的连续的n（4）个字节的内存格子了（0x3000+0x3001+0x3002+0x3003）。

数据类型决定解析方法的含义：列如我有一个内存地址（0x3000），我们可以通过给这个地址不同的数据类型来指定这个内存单元格子中二进制的解析方法。例如给它一个（int ）0x3000，含义就是（0x3000+0x3001+0x3002+0x3003）这四个字节中连起来共同存储的是一个int型数据。

`(int *)0;` 

`(float *)0; `

`(short)0; ` 

`(char)0;` 

​	C语言中，函数就是一段代码的封装，函数名的实质就是这一段代码的首地址。所以函数名的本质也是一个内存地址。

### 1.4.2、用指针来间接访问内存

关于这个类型（不管是普通变量类型int float等，还是指针类型int *，float *等）只要记住：类型只是对后边数字（代表的是内存地址）所表征的内存的一种长度规定和解析方法而已。C语言中的指针全名叫指针变量，其和普通变量没有任何区别。列如int a和int *p没有任何区别，a和p都代表一个内存地址，但是这个内存地址的解析方法不一样。

 ### 1.4.3、用数组来管理内存

数组管理内存和变量其实没有本质区别，只是符号的解析方法不同。（普通变量、数组、指针变量其实都没有本质差别，都是对内存地址的解析，只是方法不一样）

int a;		// 编译器分配4字节长度给a，并且把首地址和符号a绑定起来。
int b[10];	// 编译器分配40个字节长度给b，并且把首元素首地址和符号b绑定起来。

数组中第一个元素（a[0]）就称为首元素；每一个元素类型都是int，所以长度都是4，其中第一个字节的地址就称为首地址；首元素a[0]的首地址就称为首元素首地址。

*****

## 1.5、内存管理之结构体

### 1.5.1、数据结构这门学问的意义

​	数据结构就是研究数据如何组织（在内存中的排布），如何加工的学问。

### 1.5.2、最简单的数据结构：数组

​	为什么要数组？因为程序中有好多类型相同，意义相关的变量需要管理，这时候如果用单独的变量来做，程序看着比较乱，用数组来管理会更好管理。

### 1.5.3、数组的优势和缺陷

优势就是数组比较简单，访问用下标，可以随机访问

缺陷就是：1数组中所有元素类型必须相同；2数组的大小必须在定义时明确给出，而且一旦确定不能再改了。

### 1.5.4、结构体

结构体发明出来就是为了解决数组的第一个问题：数组元素类型必须相同

我们要管理3个学生的年龄（int类型），怎么办？
	第一种解法：用数组		int ages[3];
	第二种解法：用结构体	

```c
struct ages
{
    int age1;
    int age2;
    int age3;
};
struct ages age;
//分析总结，在这个实列中，数组比结构体好。但是不能得出结论说数组比结构体好，在元素类型不同的情况下就只能用结构体了。


struct people
{
    int age;
    char name[20];
    int heigh;
}
//因为people的各个元素不完全相同，所以必须用结构体，没法用数组
```

### 1.5.5、题外话：结构体内嵌指针实现面向对象

面向过程与面向对象

总的来说：C语言是面向过程的，但是C语言写出来的linux就是面向对象的。

非面向对象的语言，不一定不能实现面向对象的代码。只是说用面向对象的语言来实现面向对象要更加简单一些、直观一些、无脑一些。
用C++、Java等面向对象的语言来实现面向对象简单一些，因为语言本身帮我们做了很多事情；但是用C来实现面向对象很麻烦，看起来也不容易理解，这就是为什么大多数人学过C语言却看不懂linux内核代码的原因。

```c
struct s
{
    int age;//普通变量
    void (*pFunc)(void)//函数指针，指向void func(void)这类的函数
};
//使用这样的结构体就可以实现面对对象。
//这样包含了函数指针的结构体就类似于面向对象中的class，结构体中的变量类 //似于class中的成员变量，结构体中的函数指针类似于class中的成员方法。
```

*****

<img src="E:\Linux教程\华清远见\QQ图片20210412192614.png" style="zoom:60%;" />

## 1.6、内存管理之栈（stack）

### 1.6.1、什么是栈

​	栈是一种数据结构，C语言中使用栈来保存局部变量，栈是被发明用来管理内存的。

### 1.6.2、栈管理内存的特点（小内存、自动化）

栈	先进后出 FILO first in last out

队列	先进先出 FIFO first in first out

栈的特点是入口即出口，只有一个口，另一个口是堵死的。所以先进去的必须后出来。
队列的特点是入口和出口都有，必须从入口进去，从出口出来，所以先进去的必须先出来，否则就堵住后面的。

### 1.6.3、栈的应用举例：局部变量

C语言中的局部变量就是用栈来实现的。

​	我们在C中定义一个局部变量时（int a），编译器会在栈中分配一段空间（4字节）给这个局部变量用（分配时栈顶指针会移动给出空间，给局部变量a用的意思就是，将这4字节的栈内存的内存地址和我们定义的局部变量名a给关联起来），对应栈的操作是入栈。
​	==注意==：这里栈指针的移动和内存分配是自动的（栈自己完成，不用我们写代码去操作）。
​	然后等我们函数退出的时候，局部变量要灭亡。对应栈的操作是弹栈（出栈）。出栈时也是栈顶指针移动将栈空间中与a关联的那4个字节空间释放。这个动作也是自动的，也不用人写代码干预。

栈的优点：栈管理内存，好处是方便，分配和最后的回收都不用程序员操心，C语言自动完成

分析一个细节：C语言中，定义一个局部变量时如果未初始化，则值时随机的，原因是：定义局部变量，其实就是在栈中通过移动栈指针来给程序提供一个内存空间和这个局部变量名绑定。因为这段内存空间在栈上，而栈内存是反复使用的（脏的，上次用完没清零的），所以说使用栈来实现的局部变量定义时如果不显式初始化，值就是脏的。如果你显示初始化怎么样？
C语言是通过一个小手段来实现局部变量的初始化的。

```c
int a = 15;//局部变量定义是初始化
//C语言会自动把这行转成
int a;//局部变量定义
a = 15;//普通赋值语句
```

### 1.6.4、栈的约束（预定栈大小不灵活，怕溢出）

首先，栈是有大小的，所以栈内存大小不好设置，如果太小了怕溢出，太大怕浪费（这个缺点有点像数组）

其次栈的溢出危害很大，一定要避免，所以我们在C语言中定义局部变量的时候不能太多或者太大（列如不能定义局部变量 int a[1000]  使用递归来解决问题时一定要注意递归收敛）

*****

## 1.7、内存管理之堆（heap）

### 1.7.1、什么是堆

​	堆（heap）是一种内存管理方式。内存管理对操作系统来说是一件复杂的事情，因为首先内存的容量很大，其次内存需求和大小快上没有规律（操作系统上运行着几十、几百、几千个进程随时都会申请或者释放内存，申请和释放内存块大小随意）。

堆这种内存管理方式特点就是自由（随时申请、释放；大小块随意）。堆内存是操作系统划归给堆管理器（操作系统中的一段代码，属于操作系统的内存管理单元）来管理的，然后向使用者（用户进程）提供API（malloc和free）来使用堆内存。

我们什么时候使用堆内存？需要内存容量比较大，需要反复使用及释放时，很多数据结构（列如链表）的实现都要使用堆内存。

### 1.7.2、堆管理内存的特点（大块内存、手工分配&使用&释放）

特点一：容量不限（常规使用的需求容量都满足）。

特点二：申请及释放都需要手工完成，手工的含义就是需要程序员写代码明确进行申请malloc和释放free。如果程序员申请内存并使用后为释放，这段内存就丢失了（在堆管理器的记录中，这段内存仍然属于你这个进程，但是进程自己以为这段内存以及不用了，再用的时候会又去申请新的内存块，这就叫吃内存），称为内存泄漏。在c和c++语言中，内存泄漏时最严重的程序bug，这也是别人认为java/c#优秀的地方。

### 1.7.3、C语言操作堆内存的接口（malloc  free）

堆内存释放时最简单，直接调用free释放即可。`void free(void *ptr);` 

堆内存申请时有三个可选择的类似功能函数：malloc、calloc、realloc

void *malloc(size_t size);
void *calloc(size_t nmemb, size_t size);	// nmemb个单元，每个单元size字节
void *realloc(void *ptr, size_t size);		// 改变原来申请的空间的大小的

```c
//譬如要申请10个int元素的内存：
malloc(40);			malloc(10*sizeof(int));//这样写比较好
calloc(10, 4);		calloc(10, sizeof(int));
```

数组在定义时必须同时给处数组元素的个数（数组大小），而且一旦定义再无法更改。（在Java等高级语言中，有一些语法技巧可以更改数组大小，但其实这只是一种障眼法。它的工作原理是：先重新创建一个新的数组大小为要更改后的数组，然后将原数组的所有元素复制进新的数组，然后释放掉原数组，最后返回新的数组给用户；）

堆内存申请必须给定大小，一旦申请完成大小不变，如果要变只能通过realloc接口。realloc的实现原理类似上面的java原理

### 1.7.4、堆的优势和劣势（管理大块内存、灵活、容易内存泄露）

优势：灵活

劣势：需要程序员区处理各种细节，容易出错，严重依赖于程序员的水平。

****

## 1.8、复杂数据结构

### 1.8.1、链表、哈希表、二叉树、图等

​	链表时最重要的。链表在Linux内核中使用非常多，驱动、应用编程中都需要使用链表，所以链表必须掌握，掌握到：会自己定义结构体来实现链表、会写链表的节点插入（前插、后插）、节点删除、节点查找、节点遍历等。（至于像逆序很少有，掌握了前面的几个这个也不难）。

​	哈希表不是很常用，一般不需要自己实现，而是直接用别人实现的哈希表的比较多，对我们来说最重要的是要明白哈希表的原理、从而知道哈希表的特点，从而知道什么时候该用哈希表，当别人用来哈希表的时候要明白别人为什么要用哈希表、合不合适？有没有更好的选择？

​	二叉树、图等。对于这些复杂数据结构，建议不要太当回事。用到的概率很小（在嵌入式开发里）。其实这些数据结构被发明出来是为了解决特定问题，你不处理特定问题根本用不到这些，没有必要去研究。

### 1.8.2、为什么需要更复杂的数据结构

​	因为现实中的问题是多种多样的，问题的复杂度不同，所以需要解决问题的算法和结构不同。所以当你处理什么复杂度的问题，就去研究针对性解决的数据结构和算法；当你没有遇到此类问题（或者你工作的领域根本跟这个就没关系）时就不要去管了。

### 1.8.3、数据结构和算法的关系

​	数据结构的发明都是为了配合一定的算法：算法是为了处理具体问题的，算法的实现依赖于相对应的数据结构。当前我们说的算法和纯数学是不同的（算法是基于数学的，大学计算机研究生博士生很多本科都是和数学相关专用的），因为计算机算法要求以数学算法为指导，并且结合计算机本身的特点来改进，最终实现在一个计算机上可以运行的算法（意思就是用代码可以表示的算法）。

### 1.8.4、怎样学习

从上面表述大家应该明白以下事实：
	1. 数据结构和算法是相辅相成的，要一起研究。
	2. 数据结构和算法对嵌入式来说不全是重点，不要盲目的跑去研究这个。
	3. 一般在实际应用中，实现数据结构和算法的人和使用数据结构和算法的人是分开的。实际中有一部分人的工作就是研究数据结构和算法，并且试图用代码来实现这些算法（表现为库）；其他做真正工作的人要做的就是理解、明白这些算法和数据结构的意义、优劣、特征，然后在合适的时候选择合适的数据结构和算法来解决自己碰到的实际问题。

举个例子：linux内核在字符设备驱动管理时，使用了哈希表（hash table，散列表）。所以字符设备驱动的很多特点都和哈希表的特点有关。

****

# 2、C语言位操作



## 2.1、位操作符

### 2.1.1、位与&

（1）注意位与符号是一个&，两个&&是逻辑与。

（2）真值表：1&0=0；1&1=1；0&0=0；1&1=1

（3）从真值表可以看出：位与操作的特点是，只有1和1位于结果为1，其余全是0

（4）位与和逻辑与的区别：位与时两个操作数是按照二进制位彼次对应位相与的，逻辑与是两个操作数作为整体来相与的。（举例：0xAA&0xF0=0xA0,	0xAA && 0xF0=1）

### 2.1.2、位或 |

（1）注意：位或符号是一个|，两个||是逻辑或。

（2）真值表：1|0=1	1|1=1	0|0=0	0|1=1

（3）从真值表可以看出：位或操作的特点是：只有2个0相位或才能得到0，只要有1个1结果就一定是1.

（4）位或和逻辑或的区别：位或时两个操作数是按照二进制位彼次对应位相与的，逻辑或是两个操作数作为整体来相或的。

### 2.1.3、位取反~

（1）注意：C语言中位取反是~，C语言中的逻辑取反是!

（2）按位取反是将操作数的二进制位逐个按位取反（1变成0，0变成1）；而逻辑取反是真（在C语言中只要不是0的任何数都是真）变成假（在C语言中只有0表示假）、假变成真。

````c
#include<stdio.h>

int main(void)
{
    int a = 45;
    int b,c;
    b = ~a;//按位取反，逐个操作，1变0，0变1
    c = !a;//按逻辑取反，真变假，假变真
    printf("b = %d\n", b);
    printf("c = %d\n", c);
}
````

实验：任何非0的数被按逻辑取反再取反就会得到1；
	  任何非0的数倍按位取反再取反就会得到他自己；

### 2.1.4、位异或^

(1)位异或真值表：1^1=0 	0^0=0	1^0=1	0^1=1	
(2)位异或的特点：2个数如果相等结果为0，不等结果为1。记忆方法：异或就是相异就或操作起来。

位与、位或、位异或的特点总结：
位与：（任何数，其实就是1或者0）与1位与无变化，与0位与变成0
位或：（任何数，其实就是1或者0）与1位或变成1，与0位或无变化
位异或：（任何数，其实就是1或者0）与1位异或会取反，与0位异或无变化

### 2.1.5、左移位<< 与右移位 >>

C语言的移位要取决于数据类型。
对于无符号数，左移时右侧补0（相当于逻辑移位）
对于无符号数，右移时左侧补0（相当于逻辑移位）
对于有符号数，左移时右侧补0（叫算术移位，相当于逻辑移位）
对于有符号数，右移时左侧补符号位（如果正数就补0，负数就补1，叫算术移位）

嵌入式中研究的移位，以及使用的移位都是无符号数

****

## 2.2、位与位或位异或在操作寄存器时的特殊作用

### 2.2.1、寄存器操作的要求（特定位改变而不影响其他位）

（1）ARM是与IO同一编址的，ARM中有很多内部外设，SoC中CPU通过向这些内部外设的寄存器写入一些特定的值来操控这个内部外设，进而控制硬件动作，所以说：读写寄存器就是在操控硬件。

（2）寄存器的特点：按位进行规划和使用

### 2.2.2、寄存器操作的要求（改变特定位而不影响其他位）

（1）寄存器操作要求：在设定时不能影响其他位。但是寄存器的读写时整体32位一起进行的（也就是说你只想修改bit5~bit7是不行的，必须整体32位一起写入）

（2）如何做到？答案是：读–改–写三部曲，读改写的操作理念就是：当我们想改变一个寄存器种某些特定位时，我不会直接去给它写，我会先读出寄存器整体原来的值，然后在这个基础上修改我想要修改的特定位，再将修改后的值整体写入寄存器。这样达到的效果就是在不影响其他位的值的情况下，我关心的位的值已经被修改了 。

### 2.2.3、特定为清零 &

（1）回顾上节讲的位与操作的特点：（任何数，其实就是1或者0）与1位与无变化，与0位与变成0
（2）如果希望将一个寄存器的某些特定位变成0而不影响其他位，可以构造一个合适的1和0组成的数和这个寄存器原来的值进行位与操作，就可以将特定位清零。
（3）举例：假设原来32位寄存器中的值为：0xAAAAAAAA，我们希望将bit8～bit15清零而其他位不变，可以将这个数与0xFFFF00FF进行位与即可。

```c
#include<stdio.h>

int main(void)
{
    unsigned int a = 0xaaaaaaaa;
    unsigned int b = 0xffff00ff;//f相当于二进制的1
    unsigned int c;
    c = a & b;
    printf("a & b = 0x%x\n",c);//结果 0xaaaa00aa
}
```

### 2.2.4、特定位置1用|

（1）回顾上节讲的位或操作的特点：任何数，其实就是1或者0）与1位或变成1，与0位或无变化
（2）操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要置1的特定位为1，其他位为0，然后将这个数与原来的数进行位或即可。

### 2.2.5、特定位取反用^

（1）回顾上节讲的位异或操作的特点：（任何数，其实就是1或者0）与1位异或会取反，与0位异或无变化
（2）操作手法和刚才讲的位与是类似的。我们要构造这样一个数：要取反的特定位为1，其他位为0，然后将这个数与原来的数进行位异或即可。

****

## 2.3、如何用位运算构定特定二进制数

### 2.3.1、寄存器位操作经常需要特定位给特定值

（1）从上节可知，对寄存器特定位进行置1、清零或者取反，关键性的难点在于要事先构建一个特别的数，这个数和原来的值进行位与、位或、位异或等操作，即可达到我们对寄存器操作的要求。
（2）解法1：用工具软件或者计算器或者自己大脑计算，直接给出完整的32位特定数。

优势：可以完成工作，难度也不大，操作起来也不是太麻烦。
劣势：依赖工具，而且不直观，读程序的人不容易理解。

评价：凑活能用，但是不好用，应该被更好用的方法替代。
（2）解法2：自己写代码用位操作符号（主要是移位和位取反）来构建这个特定的二进制数

### 2.3.2、使用移位获取特定位为1的二进制数

（1）最简单的就是用移位获取一个特定位为1的二进制数，例如说我们需要一个bit3~bit7为1（隐含意思就是其他位置为0）的二进制数，我们可以这样：0x1f<<3

（2）我们要获取bit3 ~ bit7为1，同时bit23 ~ bit25为1，其余位为0的数：((0x1f<<3) | (0x7<<23)) 

```c
#include<stdio.h>

int main(void)
{
    int a;
    /*下面表达式含义，位或说明这个数字由两部分组成，第一部分左移3位说明	    *是从bit3开始的到bit7
     *第二部分的解读和第一部分一样，可知第二部分其实是就是bit23到          *bit25；
     *这个数的特点就是：bit3 ~ bit7和bit23 ~ bit25为1其余为0
     */
    a = ((0x1f<<3) | (0x7<<23));
    printf("a = 0x%x\n", a);
}
```

### 2.3.4、再结合位取反获取特定位为0的二进制数

（1）这次我们要获取bit4～bit10为0，其余位全部为1的数。怎么做？
（2）利用上面讲的方法就可以：(0xf<<0)|(0x1fffff<<11)
但是问题是：连续为1的位数太多了，这个数字本身就很难构造，所以这种方法的优势损失掉了。
（3）这种特定位（比较少）为0而其余位（大部分）为1的数，不适合用很多个连续1左移的方式来构造，适合左移加位取反的方式来构造。
（4）思路是：先试图构造出这个数的位相反数，再取反得到这个数。（譬如本例中要构造的数bit4～bit10为0其余位为1，那我们就先构造一个bit4～bit10为1，其余位为0的数，然后对这个数按位取反即可）

```c
#include<stdio.h>

int main(void)
{
    unsigned int a;
    a = ~(0x7f<<4);
    printf("a = 0x%x", a);
}
```

### 2.3.5、总结：位与、位或结合特定二进制数即可完成寄存器位操作需求

（1）如果你要的这个数比较少位为1，大部分位为0，则可以通过连续很多个1左移n位得到。

（2）如果你想要的数是比较少位为0，大部分位为1，则可以通过先构建其位反数，然后再位取反来得到。

（3）如果你想要的数中连续1（连续0）的部分不止1个，那么可以通过多段分别构造，然后再彼此位与即可。这时候因为参与位或运算的各个数为1的位是不重复的，所以这时候的位或其实相当于几个数的叠加。

****

## 2.4、位运算实战演练

回顾：要置1用|，用清零用&，要取反用^，~和<< >>用来构建特定二进制数。

### 2.4.1、给定一个整形数a，设置a的bit3，保证其他位不变

```c
#include<stdio.h>

int main(void)
{
    unsigned int a;
    a |= (1<<3) ;
}
```

### 2.4.2、定一个整形数a，设置a的bit3 ~bit7，保证其他位不变

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
    a |=(0x1f<<3);//a |= (0b11111<<3)
}
```

### 2.4.3、定一个整形数a，清除a的bit15，保证其他位不变

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
    a &= (~(1<<15));
}
```

### 2.4.4、定一个整形数a，清除a的bit15 ~ bit23，保证其他位不变

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
    a &= (~(0x1ff<<15));
}
```

### 2.4.5、给定一个整形数a，取出a的bit3~bit8

思路：
	第一步：先将这个数bit3～bit8不变，其余位全部清零。
	第二步，再将其右移3位得到结果。
	第三步，想明白了上面的2步算法，再将其转为C语言实现即可。

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
   	unsigned int b;
    b = a&(0x3f<<3);//将除了需要的位之外清零
    c >>= 3;
}
```

### 2.4.6、用C语言给一个寄存器的bit7 ~ bit17赋值937（其余位不影响）

关键点：第一，不能影响其他位；第二，你并不知道原来bit7～bit17中装的值。
思路：第一步，先将bit7～bit17全部清零，当然不能影响其他位。
	       第二步，再将937写入bit7～bit17即可，当然不能影响其他位。

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
    a &= (~(0x7ff<<7));	//将需要赋值的位清零
    a |= (397<<7);//将397赋值到bit7 ~ bit17
}
```

### 2.4.7、用C语言将一个寄存器的bit7～bit17中的值加17（其余位不受影响）。

关键点：不知道原来的值是多少
思路：第一步，先读出原来bit7～bit17的值
	       第二步，给这个值加17
	       第三步，将bit7～bit17清零
	       第四步，将第二步算出来的值写入bit7～bit17

```c
#include<stdio.h>

int mian(void)
{
    unsigned int a;
    unsigned int b;
    b = a & (0x7ff<<7);
    b >>= 7;//先读出之前的值
    b += 17;//将之前的值加17
    a &= (~(0x7ff<<7));
    a |= (b<<7);//将加过的值赋给已经清零的a上去
}
```

### 2.4.8、用C语言给一个寄存器的bit7～bit17赋值937，同时给bit21～bit25赋值17。

思路：4.2.4.6的升级版，两倍的4.2.4.6中的代码即可解决。
分析：这样做也可以，但是效果不够高，我们有更优的解法就是合两步为一步。

```c
#include<stdio.h>

#define VALUE1 937
#define VALUE2 17		//将数字定义宏

int mian(void)
{			//分析：这样做也可以，但是效果不够高，我们有更优的解                   //法就是合两步为一步。
    unsigned int a;
    a &= (~(0x7ff<<7));	
    a |= (397<<7);
    a &= (~(0x1f<<21));
    a |= (17<<21);
    
    //第二种写法
    a &= (~(0x7ff<<7)) | (~(0x1f<<21));//将两个条件全部清零
    a |= (397<<7) | (17<<21);//将两个条件全部赋值
    
    //内核常见写法
     a &= (~(0x7ff<<7)) | (~(0x1f<<21));
    a |= (VALUE1<<7) | (VALUE2<<21);
}
```

*****

## 2.5、用宏定义来完成位运算

### 2.5.1、直接用宏来置位、复位（最右边为第一位）

将x这个数的第n为置位或者复位

`#define SET_NTH_BIT(x, n)  (x | ((1U)<<(n-1)))`
`#define CLEAR_NTH_BIT(x, n) (x & ~((1U)<<(n-1)))`

```c
#include<stdio.h>
	//用宏定义将32位数x的第n位（右边起算，也就是bit0开始）的数置位
#define SET_BIT_N(x,n)	(x | (1U<<n-1))  //1后面加U表示无符号型
	//用宏定义将32位数x的第n位（右边起算，也就是bit0开始）的数复位
#define CLEAN_BIT_N(x,n) (x & (~(1U<<n-1)))
	//用宏定义将32位数x的第n位到第m位（右边起，m位是高位）的数置位
	//主要是需要得到（m-n+1）个1
	//算法： 第一步：先得到32位的1 ~0U
	//		第二步：将第一步得到的1向由移动（32-（m-n+1））位就可以得	 //		 到这么多的1
#denfine SET_BIT_N_M（x,n,m） (x | (((~0U)>>(32-m-n+1)))<<(n-1))
	//截取变量x的第n到第m位，题目相当于2.4.5的题目
#denfine GETBITS(x,n,m) (a & ~(~0U<<(m-n+1))<<(n-1))>>(n-1))
int main(void)
{
	unsigned int a = 0;
	unsigned int b = 0;
	b = SET_BIT_N(a,4);
	printf("a = 0x%x\n", b);//将a的第4位置位
    
    b = CLEAN_BIT_N(a,4);
    printf("a = 0x%x\n", b);//将a的第4位清零
    
    b = SET_BIT_N_M(a,1,4);
    printf("a = 0x%x\n", b);//将a的第0位到第3位置位
    
}
```

复杂宏的分析：

​	((x & ~ (~ (0U)<<(m-n+1))<<(n-1)) >> (n-1))
第一步，先分清楚这个复杂宏分为几部分：2部分
(x & ~(~(0U)<<(m-n+1))<<(n-1)) 			>> 			(n-1)

分析为什么要>>(n-1)，相当于是我们4.2.4.5中的第二步

第二步，继续解析剩下的：又分为2部分
x 		& 		~ (~ (0U)<<(m-n+1))<<(n-1) 		
分析为什么要&，相当于我们4.2.4.5中的第一步	

第三步，继续分析剩下的：
~		(~(0U)<<(m-n+1))		<<		(n-1) 
这个分析时要搞清楚第2坨到底应该先左边取反再右边<<还是先右边<<再左边取反。解法：第一，查C语言优先级表；第二，自己实际写个代码测试。
说明这个式子应该是	~( ~ (0U)<<(m-n+1))		<<		(n-1) ，这就又分为2部分了

****

# 3、指针才是C语言的精髓

## 3.1、指针到底是什么

### 3.1.1、指针变量和普通变量的区别

（1）首先必须非常明确：指针的实质就是变量，它和普通变量完全没有区别。指针完整的名字应该叫指针变量，简称指针。

```c
#include<stdio.h>

int main(void)
{
    int a;//定义了一个int型变量，名字叫a
    int b;//定义了一个指针变量，名字叫做p，p指向了int型的变量
    
    a = 4;//可以操作
    p = 4;//编译器不允许只要操作，因为指针变量虽然实质上也是个普通变   			//量，但是它的用途和普通变量不同，指针变量存储的应该是另一个           //变量的地址而不是用来随意存一些int类型的数	
    p = (int *)4;//我们明知道其实就是数字4但是我们强制转换成int* 类型			       //的4，就是告诉编译器，这个4其实是个地址(而且是个int				//类型变量的地址)，那么我们这个（int *）4就和p类型匹				   //配了，编译器就过了
}
```

### 3.1.2、为什么需要指针呢

（1）指针的出现是为了实现间接访问。在汇编中都有间接访问，其实就是CPU的寻址方式的间接寻址。

（2）间接访问（CPU的间接寻址）是CPU设计时决定的，这个决定了汇编语言必须有能够实现间接寻址，有决定了汇编之上的C语言必须实现间接寻址。

（3）高级语言如Java、C#等没有指针，那么它们是怎么实现间接访问？答案就是语言本身帮我们封装了。

### 3.1.3、指针使用三部曲：定义指针变量、关联指针变量、解引用

```c
#include<stdio.h>
//指针使用分三步：定义指针变量、给指针变量赋值、解引用
int main(void)
{	int a = 23;
    	//第一步定义指针变量
    int *p;
       //绑定指针，其实就是给指针变量赋值，就是让这个指针指向另一个变量
    p = &a;//实现指针绑定
	 //解引用
 	//如果没有绑定指针就去接引用，几乎一定会出错
 	*p = 555;//把555放到p指向的那个变量中
}
```

（1）当我们int *p定义一个指针变量p时，因为p是局部变量，所以也遵循C语言局部变量的一般规律（定义局部变量并且未初始化，则值是随机的），所以此时p变量中存储的是一个随机的数字。

（2）此时如果我们解引用p，则相当于我们访问了这个随机数字为地址的内存空间。那这个空间到底能不能访问不知道（也许行也许不行），所以如果直接定义指针变量未绑定有效地址就去解引用几乎必死无疑。

（3）定义一个指针变量，不经绑定有效地址就去解引用，就好象拿一个上了镗的枪随意转了几圈然后开了一枪。

（4）指针绑定的意义就在于：让指针指向一个可以访问、应该访问的地方（就好象拿着枪瞄准目标的过程一样），指针的解引用是为了间接访问目标变量（就好象开枪是为了打中目标一样）

## 3.2、指针带来的一些符号的理解

我们写的代码是给编译器看的，代码要想达到你想象的结果，就必要编译器对你的代码的理解和你自己对代码的理解一样。编译器理解代码就是理解的符号，所以我们要正确理解C语言中的符号，才能像编译器一样思考程序、理解代码

### 3.2.1、星号 *

（1）在C语言中* 可以表示乘号，也可以表示指针符号，这两个用法毫无关系，就是恰巧用来同一个符号而已。

（2）星号在用于指针相关功能的时候有两种用法：第一种是指针定义时，* 结合前面的类型用于表明要定义的指针的类型；第二种功能是指针解引用，解引用时 *p表示p指向的变量本身。

### 3.2.2、取地址符&

（1）取地址符使用时直接加在一个变量的前面，然后取地址符和变量加起来构成一个新的符号，这个符号表示这个变量的地址。

### 3.2.3、指针定义并初始化、与指针定义然后赋值的区别

（1）指针定义时可以初始化，指针的初始化其实就是给指针变量初值（跟普通变量的初始化没有任何本质区别）。
（2）指针变量定义同时初始化的格式是：int a = 32; int *p = &a;（星号其实是int * 赋值其实还是 p = &a）
（3）不初始化时指针变量先定义再赋值：int a = 32; int *p; 	p = &a;		正确的

### 3.2.4、左值和右值

（1）放在赋值运算符左边的就叫左值，右边的就叫右值。所以赋值操作其实就是：左值 = 右值;

（2）当一个变量做左值时，编译器认为这个变量符号的真实含义是这个变量所对应的那个内存空间；当一个变量做右值时，编译器认为这个变量符号的真实含义是这个变量的值，也就是这个变量所对应的内存空间中存储的那个数。

（3）左值与右值的区别，就好象现实生活中“家”这个字的含义。譬如“我回家了”，这里面的家指的是你家的房子（类似于左值）；但是说“家比事业重要”，这时候的家指的是家人（家人就是住在家所对应的那个房子里面的人，类似于右值）

****

## 3.3、野指针问题

### 3.3.1、什么是野指针，从哪里来，有什么危害

（1）野指针就是指针指向的位置是不可知的（随机的、不正确的）

（2）野指针很可能触发运行时的段错误（Sgmentation fault）

（3）因为指针变量在定义时未初始化，值是随机的。指针变量其实就是别的变量（指针所指向的变量）的地址，所以意味着这个指针指向了一个地址是不确定的变量，这时候去解引用就是去访问这个地址不确定的变量

（4）野指针因为指向地址是不可预知的，所以有3种情况：第一种是指向不可访问（操作系统不允许访问的敏感地址，譬如内核空间）的地址，结果是触发段错误，这种算是最好的情况了；第二种是指向一个可用的、而且没什么特别意义的空间（譬如我们曾经使用过但是已经不用的栈空间或堆空间），这时候程序运行不会出错，也不会对当前程序造成损害，这种情况下会掩盖你的程序错误，让你以为程序没问题，其实是有问题的；第三种情况就是指向了一个可用的空间，而且这个空间其实在程序中正在被使用（譬如说是程序的一个变量x），那么野指针的解引用就会刚好修改这个变量x的值，导致这个变量莫名其妙的被改变，程序出现离奇的错误。一般最终都会导致程序崩溃，或者数据被损害。这种危害是最大的。
（5）指针变量如果是局部变量，则分配在栈上，本身遵从栈的规律（反复使用，使用完不擦除，所以是脏的，本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值），就决定了栈的使用多少会影响这个默认值。因此野指针的值是有一定规律不是完全随机，但是这个值的规律对我们没意义。因为不管落在上面野指针3种情况的哪一种，都不是我们想看到的。

### 3.3.2、怎么避免野指针

（1）野指针的错误来源，就是指针定义之后没有初始化也没有赋值（总之就是指针没有明确的指向一个可用的内存空间），然后去接应用它。

（2）知道了野指针产生的原因，避免方法就出来了：在指针在解引用之前，一定要确保指针指向一个绝对可用的空间。

（3）常规的做法是这样的：

​			第一点：定义指针时，同时初始化NULL

​			第二点：在解引用之前，先去判断这个指针是不是NULL

​			第三点：指针使用完成之后，将其赋值为NULL

​			第四点：在指针使用之前，将其赋值绑定一个可用地址空间

（4）野指针的防治方案4点绝对可行，但是略显麻烦。很多人懒得这么做，那实践中怎么处理？在中小型程序中，自己水平可以把握的情况下，不必严格参照这个标准；但是在大型程序，或者自己水平感觉不好把握时，建议严格参照这个方法。

### 3.3.3、NULL到底是什么

（1）NULL在C\C++中定义为：

`#ifdef _cplusplus`   		//定义这个符号就是表示当前环境时C++环境

`#define NULL 0`  	 		 //在C++中NULL就是0

`#else`

`define NULL (void *)0`   //在C中NULL是强制类型转换为void * 的0

`#endif`

（2）在C语言中，你可以int *p；你可以p = (int *)0；但是不可以p = 0；因为类型不相同。

（3）NULL的实质其实就是0，然后我们给我们的指针赋初值为NULL，其实就是让指针指向0地址处。为什么指向0呢，两个原因，第一层原因就是0地址处在作为一个特殊地址（我们认为指针指向这里就表示指针没有被初始化，就表示为野指针 ）；第二层原因是这个地址0地址在一般的操作系统中都是不允许被访问的，如果程序员不去检查（是否等于NULL）就写代码直接解引用就会出现段错误，这种已经是最好的结果了。

（4）一般我们在判断这个指针是否是野指针时，都是写成：`if (NULL != p)` 

​		而不是写成：`if (p != NULL)` ；原因时NULL写在后面，当中间是==符号时，有时候容易忘记写成了赋值符号=，编译器是不会报错的，这个错误（对于新手）很难检查出来，如果NULL写前面编译器时会报错的。

****

## 3.4、const关键字与指针

### 3.4.1、const修饰指针的4种形式

（1）const关键字，在C语言中用来修饰变量，表示这个变量是个常量

（2）const修饰指针有4种方式，区分清楚着4种方式可全部理解const和指针

​		第一种：`const int *p;` p是个指针指向一个int型的数据，p所指向的那个数是常量。

​		第二种：`int const *p;`  p是个指针指向一个int型的数据，p所指向的那个数是常量。

​		第三种：`int *const p;`  p是个指针指向一个int型的数据，p本身是个常量，p所指向的量是个变量

​		第四种：`const int * const p;`  p是个指针指向一个int型的数据，p本身是常量，指向的也是常量

（3）关于指针变量的理解，主要涉及2个变量：第一个是指针变量p本身，第二个是p指向的那个变量(*p)。一个const关键字只能修饰一个变量，所以弄清楚这4个表达式的关键就是搞清楚const放在某个位置是修饰谁的。

### 3.4.2、const修饰的变量真的不能改变吗

```c
#include<stdio.h>

int main(void)
{
    const int a =5;
    int *p;
    p = (int *)&a;//这里报了警告可以通过强制类型转换来消除
    *p = 6;			//定义指针间接改变a的数值
    printf("a = %d\n", a);
}
```

（1）课堂练习说明：const修饰的变量其实是可以改的（前提是gcc环境下）。

（2）在某些单片机环境下，const修饰的变量是不可以改的。const修饰的变量到底能不能真的被修改，取决于具体的环境，C语言本身并没有完全严格一致的要求。

（3）在gcc中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。

（4）更深入一层的原因，是因为gcc把const类型的常量也放在了data段，其实和普通的全局变量放在data段是一样实现的，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，所以只要骗过编译器就可以修改了。

### 3.4.3、const的用法

（1）const是在编译器中实现的，编译时检查，并非不能骗过。所以在C语言中使用const，就好象是 一种道德约束而非法律约束，所以大家使用const时更多是传递一种信息，就是告诉编译器、也告诉读程序的人，这个变量是不应该也不必被修改的。

****

## 3.5、深入学习数值

### 3.5.1、从内存角度来理解数组

（1）从内存角度来说：数值变量就是一次分配多个变量，而且这多个变量在内存中的存储单元式依次相连的。

（2）我们分开定义多个变量（int a，b，c，d）和一次定义一个数值（int a[4]）；这两种定义方法相同点是都定义了4个int型变量，而且这4个变量都是独立的单个使用的；不同点是单独定义时a、b、c、d在内存中的地址不一定相连，但是定义成数组后，数组中的4个元素地址肯定是依次相连的。

（3）数组中多个变量虽然必须单独访问，但是因为他们的地址彼此相连，因此很适合用指针来操作，因此数组和指针天生就叫纠结在一起。

### 3.5.2、从编译器角度来理解数组

（1）从编译器角度来说：数组变量也是变量，和普通变量和指针变量没有本质不同。变量的本质就是一个地址，这个地址在编译器中决定具体数值，具体数值和变量名绑定，变量类型决定这个地址的长度。

（2）搞清楚：变量、变量名、变量类型这三个概念的含义，很多问题就清楚了。

### 3.5.3、数组中几个关键符号（a  a[0]  &a  &a[0]）的理解

（1）这4个符号搞清楚了，数组相关的很多问题都有答案了。理解这些符号的时候要和左值右值结合起来，也就是搞清楚每个符号分别做左值和右值时的不同含义。

（2）a就是数组名。a做左值时表示整个数组的所有空间（10×4=40字节），又因为C语言规定数组操作时要独立单个操作，不能整体操作数组，所以a不能做左值；a做右值表示数组首元素（数组的第0个元素，也就是a[0]）的首地址（首地址就是起始地址，就是4个字节中最开始第一个字节的地址）。a做右值等同于&a[0];

（3）a[0]表示数组的首元素，也就是数组的第0个元素。做左值时表示数组第0个元素对应的内存空间（连续4字节）；做右值时表示数组第0个元素的值（也就是数组第0个元素对应的内存空间中存储的那个数）

（4）&a就是数组名a取地址，字面意思来看就应该是数组的地址。&a不能做左值（&a实质是一个常量，不是变量因此不能赋值，所以自然不能做左值。）；&a做右值时表示整个数组的首地址。

（4）&a[0]字面意思就是数组第0个元素的首地址（搞清楚[]和&的优先级，[]的优先级要高于&，所以a先和[]结合再取地址）。做左值时表示数组首元素对应的内存空间，做右值时表示数组首元素的值（也就是数组首元素对应的内存空间中存储的那个数值）。做右值时&a[0]等同于a。

解释：为什么数组的地址是常量？因为数组是编译器在内存中自动分配的。当我们每次执行程序时，运行时都会帮我们分配一块内存给这个数组，只要完成了分配，这个数组的地址就定好了，本次程序运行直到终止都无法再改了。那么我们在程序中只能通过&a来获取这个分配的地址，却不能去用赋值运算符修改它。

==总结==：
（1）&a和a做右值时的区别：&a是整个数组的首地址，而a是数组首元素的首地 址。这两个在数字上是相等的，但是意义不相同。意义不相同会导致他们在参与运算的时候有不同的表现。

（2）a和&a[0]做右值时意义和数值完全相同，完全可以互相替代。

（3）&a是常量，不能做左值。

（4）a做左值代表整个数组所有空间，所以a不能做左值。

*****

## 3.6、数组和指针的天生姻缘

### 3.6.1、以指针的方式访问数组元素

```c
#include<stdio.h>

int main(void)
{
    int a[5] = {1,2,3,4,5};
    
    printf("a[3] = %d\n", a[3]);
    printf("*(a+3) = %d\n", *(a+3));//两者一样
    
    int *p;
    p = a;//a做右值时表示数组元素首地址，等同于&a[0]
    printf("*(p+3) = %d\n", *(p+3));
}
```

（1）数组元素使用时不能整体访问，只能单独访问。访问方式有两种：数组形式和指针形式。

（2）数组格式访问数组元素是：数组名[下标]; (注意下标从0开始)

（3）指针格式访问数组元素是：*(指针+偏移量); 如果指针是数组首元素地址（a或者&a[0]），那么偏移量就是下标；指针也可以不是首元素地址而是其他哪个元素的地址，这时候偏移量就要考虑叠加了。

（4）数组下标方式和指针方式均可以访问数组元素，两者的实质其实是一样的。在编译器内部都是用指针方式来访问数组元素的，数组下标方式只是编译器提供给编程者一种壳（语法糖）而已。所以用指针方式来访问数组才是本质的做法。

### 3.6.2、从内存角度理解访问数组的实质

（1）数组的特点就是：数组中各个元素的地址是依次相连的，而且数组还有一个很大的特点（其实也是数组的一个限制）就是数组中各个元素的类型比较相同。类型相同就决定了每个数组元素占几个字节是相同的（譬如int数组每个元素都占4字节，没有例外）。

（2）数组中的元素其实就是地址相连接、占地大小相同的一串内存空间。这两个特点就决定了只要知道数组中一个元素的地址，就可以很容易推算出其他元素的地址。

### 3.6.3、指针和数组类型的匹配问题

`int *p; int a[5];	p = a;	`	// 类型匹配
`int *p; int a[5];	p = &a;`		// 类型不匹配。p是int *，&a是整个数组的指针，也就是一个数组指针类型，不是int指针类型，所以不匹配

（1）&a、a、&a[0]从数值上来看是完全相等的，但是意义来看就不同了。从意义上来看，a和&a[0]是数组首元素首地址，而&a是整个数组的首地址；从类型来看，a和&a[0]是元素的指针，也就是int * 类型；而&a是数组指针，是int (*)[5];类型。

### 3.6.4、总结：指针类型决定了指针如何参与运算

（1）指针参与运算时，因为指针变量本身存储的数值是表示地址的，所以运算也是地址的运算。

（2）指针参与运算的特点是，指针变量+1，并不是真的加1，而是加1*sizeof(指针类型)；如果是int *指针，则+1就实际表示地址+4，如果是char *指针，则+1就表示地址+1；如果是double *指针，则+1就表示地址+8.

（3）指针变量+1时实际不是加1而是加1×sizeof(指针类型)，主要原因是希望指针+1后刚好指向下一个元素（而不希望错位）。

****

## 3.7、指针和强制类型转换

### 3.7.1、变量的数据类型的含义

（1）所有的类型的数据存储在内存中，都是按照二进制格式存储的。所以内存中只知道有0和1，不知道是int的、还是float的还是其他类型。

（2）int、char、short等属于整形，他们的存储方式（数转换成二进制往内存中放的方式）是相同的，只是内存格子大小不同（所以这几种整形就彼此叫二进制兼容格式）；而float和double的存储方式彼此不同，和整形更不同。

（3）int a = 5;时，编译器给a分配4字节空间，并且将5按照int类型的存储方式转成二进制存到a所对应的内存空间中去（a做左值的）；我们printf去打印a的时候（a此时做右值），printf内部的vsprintf函数会按照格式化字符串（就是printf传参的第一个字符串参数中的%d之类的东西）所代表的类型去解析a所对应的内存空间，解析出的值用来输出。也就是说，存进去时是按照这个变量本身的数据类型来存储的（譬如本例中a为int所以按照int格式来存储）；但是取出来时是按照printf中%d之类的格式化字符串的格式来提取的。此时虽然a所代表的内存空间中的10101序列并没有变（内存是没被修改的）但是怎么理解（怎么把这些1010转成数字）就不一定了。譬如我们用%d来解析，那么还是按照int格式解析则值自然还是5；但是如果用%f来解析，则printf就以为a对应的内存空间中存储的是一个float类型的数，会按照float类型来解析，值自然是很奇怪的一个数字了。

总结：C语言中的数据类型的本质，就是决定了这个数在内存中怎么存储的问题，也就是决定了这个数如何转成二进制的问题。一定要记住的一点是内存只是存储1010的序列，而不管这些1010怎么解析。所以要求我们平时数据类型不能瞎胡乱搞。

分析几个题目：
* 按照int类型存却按照float类型取		一定会出错
* 按照int类型存却按照char类型取		有可能出错也有可能不出错
* 按照short类型存却按照int类型取	   有可能出错也有可能不出错
* 按照float类型存却按照double取		一定会出错

### 3.7.2、指针的数据类型的含义

（1）指针的本质是：变量，指针就是指针变量

（2）一个指针涉及2个变量：一个是指针变量自己本身，一个是指针变量指向的那个变量

（3）int *p;定义指针变量时，p（指针变量本身）是int *类型，*p（指针指向的那个变量）是int类型的。

（4）int *类型说白了就是指针类型，只要是指针类型就都是占4字节，解析方式都是按照地址的方式来解析（意思是里面存的32个二进制加起来表示一个内存地址）的。结论就是：所有的指针类型（不管是int * 还是char * 还是double *）的解析方式是相同的，都是地址。

（5）对于指针所指向的那个变量来说，指针的类型就很重要了。指针所指向的那个变量的类型（它所对应的内存空间的解析方法）要取决于指针类型。譬如指针是int *的，那么指针所指向的变量就是int类型的。

### 3.7.3、指针数据类型转换实例分析1（int  * —>float  *）

```c
#include<stdio.h>

int main(void)
{
    int a = 5;
    int *p1 = &a
    float *p;
    p = (float *)p1;
    printf("*p = %f\n", *p);//出错
    printf("*p1 = %d\n", *p1);
}
```

（1）之前分析过：int和float的解析方式是不兼容的，所以int *转成float *再去访问绝对会出错。

### 3.7.4、指针数据类型实列分析（int * —> char *）

```c
#include<stdio.h>

int main(void)
{
    int a = 65;
    char *p1 = &a;
    printf("*p1 = %c\n", *p1);//这个时候是对的 结果是‘A’  
}
```



（1）int和char类型都是整形，类型兼容的。所以互转的时候有时候错有时候对。

（2）int和char的不同在于char只有1个字节而int有4个字节，所以int的范围比char大。在char所表示的范围之内int和char是可以互转的不会出错；但是超过了char的范围后char转成int不会错（向大方向转就不会错，就好比拿小瓶子的水往大瓶子倒不会漏掉不会丢掉），而从int到char转就会出错（就好象拿大瓶子水往小瓶子倒一样） 

****

## 3.8、指针、数组与sizeof运算符

（1）sizeof是C语言中的一个运算符（注意sizeof不是函数，虽然用法很像函数），sizeof的作用是用来返回（）里的变量或者数据类型占用的内存字节数。

（2）sizeof存在的价值：主要是因为在不同的平台下各种数据类型所占的内存字节不尽相同（列如int在32位的系统下为4个字节，在16位的系统性为2个字节……）。所以程序中需要使用sizeof来判断当前变量\数据类型在当前环境下占几个字节。

### 3.8.1、表示字符串时

（1）在所有得32位系统中所有指针的长度都是4字节，不管什么类型。

（2）strlen是个库函数，用来返回一个字符串的长度（注意，字符串长度是不包含‘\0’的）。一定注意strlen接受的一定是一个字符串（特征是以‘\0’结尾）

```c
//题目一
#include<stdio.h>
#include<string.h>

int main(void)
{
    char str[] = ”hello”;  
    printf("sizeof(str) = %d", sizeof(str));//结果为6
    printf("sizeof(str[0]) = %d", sizeof(str[0]));//结果为1
    printf("strlen(str) = %d", strlen(str));//结果为5，不包含‘/0’
}

```

````c
//题目二
#include<stdio.h>
#include<string.h>

int main(void)
{
    char str[] = ”hello”; 
    char *p = str;
    printf("sizeof(p) = %d", sizeof(p));//测得只是指针变量本身得长度
    								//所有32位系统指针都是 4字节
    printf("sizeof(*p) = %d", sizeof(*p));// 1 相当于sizeof(char)
    printf("strlen(p) = %d", strlen(p));//5 相当于strlen(str)
}
````



### 3.8.2、表示整形时

```c
//题目三
#include<stdio.h>
#include<string.h>

int main(void)
{
    int n = 10;
    printf("sizeof(n) = %d", sizeof(n));
    printf("sizeof(int) = %d", sizeof(int));//两者长度一样
}
```

（1）sizeof测试一个变量的本身，和sizeof测试这个变量的类型，结果是一样的。

```c
//题目三
#include<stdio.h>
#include<string.h>

int main(void)
{
    int b[100] = {10};
    printf("sizeof(b) = %d", sizeof(b));//400  100*sizeof(int)
}
```

（1）sizeof（数组名）的时候，数组名不做左值也不做右值，纯粹就是数组名的含义。那么sizeof（数组名）实际返回的是整个数组所占用的内存空间（以字节为单位）

### 3.8.3、数组在函数内

```c
#include<stdio.h>
//void func(int *a) 与这样写没有区别
void func(int a[])
{
    printf("sizeof(a) = %d", sizeof(a));//结果为4，因为a在函数func										//内部就是个指针
}
//如果想把数组的首地址和大小一起传进来
void func1(int *a, int num)
{
    //在子函数内a是传进来的数组首地址，num是数组的大小
}

int main(void)
{
    int a[20];
    func(a);
    func1(a,sizeof(a));
}
```

（1）函数传参是可以用数组的

（2）函数传参是数组时，实际上传递的不是整个数组，而是数组的首元素首地址，也就是说我们函数传参用数组传，实际上相当于我们传递的是一个指针（指针指向数组的首元素首地址）

```c
#include<stdio.h>

int main(void)
{
    int a[100];
    int b = sizeof(a)/sizeof(a[0]);//整个数组/数组中一个元素的字节数
    printf("b = %d\n", b);//用来判断一个数组里面有几个数
}
```



### 3.8.4、宏定义时

```c
#include<stdio.h>

#define dpChar char *
typedef char *tpChar;	//typedef 用来重命名类型,或者说用了用户自定						  //义类型


int main(void)
{
    dpChar p1,  p2;	//展开:char *p1, p2;	相当于char *p1;char p2;
    tpChar p3,  p4;	//等价于：char *p3,char *p4;		
    printf("sizeof(p1) = %d", sizeof(p1));// 4
    printf("sizeof(p2) = %d", sizeof(p2));// 1
    printf("sizeof(p3) = %d", sizeof(p3));// 4
    printf("sizeof(p4) = %d", sizeof(p4));// 4
}
```

*****

## 3.9、指针与函数传参

### 3.9.1、普通变量作为函数形参

（1）函数传参时，普通变量作为参数时，形参和实参名字可以不相同，实际上都是用实参替代相对应的形参。

（2）在子函数内部，形参的值等于实参。原因是函数调用时把实参的值赋值给了形参。

（3）这就是很多书上写的“传值调用”（相当于实参做右值，形参做左值）

```c
#include<stdio.h>
//a和b的地址不同，说明a和b不是同一个变量（在内存中a和b是两个独立的空间）
int func(int b)
{
    printf("func(b) = %p\n", &b);
}

int main(void)
{
    int a = 5;
    printf("&a = %p\n", &a);
    func(a);
}
```

### 3.9.2、数组作为函数传参

```c
#include<stdio.h>

int func(int b[])
{
    printf("sizeof(b) = %d\n", sizeof(b));
    printf("func(b) = %p\n", b);
}

int main(void)
{
    int a[10];
    printf("&a = %p\n", &a);
    func(a);
}

```

（1）函数名作为形参传参时，实际传递是不是整个数组，而是数组的首元素的首地址（也就是整个数组的首地址。因为传参时是传值，所以这两个没区别）。所以在子函数内部，传进来的数组名就等于是一个指向数组首元素首地址的指针。所以sizeof得到的是4.

（2）在子函数内传参得到的数组首元素首地址，和外面得到的数组首元素首地址的值是相同的。很多人把这种特性叫做“传址调用”（所谓的传址调用就是调用子函数时传了地址（也就是指针），此时可以通过传进去的地址来访问实参。）

（3）数组作为函数形参时，[]里的数字是可有可无的。为什么？因为数组名做形参传递的实际只是个指针，根本没有数组长度这个信息。

### 3.9.3、指针作为函数形参

（1）只有一句话：和数组作为函数形参是一样的.这就好像指针方式访问数组元素和数组方式访问数组元素的结果一样是一样的。

### 3.9.4、结构体变量作为形参

```c
#include<stdio.h>

struct A
{
    char a;		//结果 a = 8 原因是结构体对齐的问题，因为要对齐存放所				  //以变成8了
    int b;
};

void func(struct A a1)
{
    printf("sizeof(a1) = %d\n", sizeof(a1));
    printf("&a1 = %p\n", &a1);
    printf("a1.b = %d\n", a1.b);
}

int main(void)
{
    struct A a = 
    {
        .a = 4,
        .b = 5555,
    };
    
    printf("sizeof(a) = %d\n", sizeof(a));
    printf("&a = %p\n", &a);
    printf("a.b = %d\n", a.b);
    func1(a);
}//说明结构体作为变量时传参也是值传递
/* 
*  sizeof(a) = 8
*  &a = 0xbfbad08
*  a.b = 5555
*  sizeof(a1) = 8
*  &a1 = 0xbfbad030
*  a1.b = 5555.
*/
```

（1）结构体变量作为函数形参的时候，实际上和普通变量（类似于int之类的）传参时表现是一模一样的。所以说结构体变量其实也是普通变量而已。

（2）因为结构体一般都很大，所以如果直接用结构体变量进行传参，那么函数调用效率就会很低。（因为在函数传参的时候需要将实参赋值给形参，所以当传参的变量越大调用效率就会越低）。怎么解决？思路只有一个那就是不要传变量了，改传变量的指针（地址）进去。

（3）结构体因为自身太大，所以传参应该用指针来传（但是程序员可以自己决定，你非要传结构体变量过去C语言也是允许的，只是效率低了）；回想一下数组，为什么C语言设计的时候数组传参默认是传的数组首元素首地址而不是整个数组？

```c
//改造结构体传值
#include<stdio.h>

struct A
{
    char a;		//结果 a = 8 原因是结构体对齐的问题，因为要对齐存放所				  //以变成8了
    int b;
};

void func(struct A *a1)
{
    printf("sizeof(a1) = %d\n", sizeof(a1));
    printf("sizeof(*a1) = %d\n", sizeof(*a1));
    printf("&a1 = %p\n", &a1);//相当于二重指针
    printf("a1 = %p\n", a1);
    printf("a1->b = %d\n", a1->b);
}

int main(void)
{
    struct A a = 
    {
        .a = 4,
        .b = 5555,
    };
    
    printf("sizeof(a) = %d\n", sizeof(a));
    printf("&a = %p\n", &a);
    printf("a.b = %d\n", a.b);
    func1(&a);
}//说明结构体作为变量时传参也是值传递
/* 
*  sizeof(a) = 8
*  &a = 0xbfb5508
*  a.b = 5555
*  sizeof(a1) = 4
*  sizeof(*a1) = 8
*  &a1 = 0xbfbad030
*  a1 = 0xbfb5508
*  a1->b = 5555.
*/
```



### 3.9.4、传值调用与传址调用

（1）传值调用描述的是这样一种现象：x和y作为实参，自己并没有真身进入swap1函数内部，而只是拷贝了一份自己的副本（副本具有和自己一样的值，但是是不同的变量）进入子函数swap1，然后我们在子函数swap1中交换的实际是副本而不是x、y真身。所以在swap1内部确实是交换了，但是到外部的x和y根本没有受影响。

（2）在swap2中x和y真的被改变了（但是x和y真身还是没有进入swap2函数内，而是swap2函数内部跑出来把外面的x和y真身改了）。实际上实参x和y永远无法真身进入子函数内部（进去的只能是一份拷贝），但是在swap2我们把x和y的地址传进去给子函数了，于是乎在子函数内可以通过指针解引用方式从函数内部访问到外部的x和y真身，从而改变x和y。

（3）结论：这个世界上根本没有传值和传址这两种方式，C语言本身函数调用时一直是传值的，只不过传的值可以是变量名，也可以是变量的指针。

****

## 3.10、输入型参数与输出型参数

### 3.10.1、函数为什么需要形参和返回值

（1）函数名是一个符号，用来表示整个函数代码段的首地址，实质上是个指针常量，所以在程序上使用到函数名时都是当地址用的，用来调用这个函数的。

（2）函数体是函数的关键，用一对{ }括起来，包含很多代码，函数体就是函数实际做的工作。

（3）形参列表和返回值。形参是函数的输入部分，返回值是函数的输出部分。对函数最好的理解就是把函数看成一个加工机器（程序其实是数据加工器），形参列表就是这个机器的原材料输入端；返回值就是机器的成品输出端。

（4）其实如果没有形参列表和返回值，函数也能对数据进行加工，用全局变量即可。用全局变量来传参和用函数参数的返回值来传参各有特点，实践中都有使用，总的来说，函数参数传参用的更多一点，这样可以实现模块化编程，而C语言中尽量少用全局变量。

（5）用全局变量传参最大的好处就是省略了函数传参的开销，所以效率要高一些，但是实战中用的最多的还是传参，如果参数很多传参开销很大，通常的做法是把很多参数打包成结构体，然后传结构体变量指针进去。

```c
#include<stdio.h>

int multip(int a);
void multip_2(void);

int x;
int y;

int main(void)
{
    //第一种方法，函数传值
    int a = 3;
    int b ;
    b = multip(a);
    printf("b = %d\n", b);
    //第二种方式，用全局变量
    x = 3;
    multip_2();
    printf("y = %d\n", y);
}

int multip(a)
{
    return a * 5;
}

void multip_2(void)
{
    y = x * 5；
}
```

### 3.10.2、函数传参时用const指针

（1）const一般用在函数传参列表中，用法是 `const int *p ；`（意义是指针变量p是可变的，而p所指向的变量是不可变的）。

（2） const用来修饰指针做函数传参，作用是声明在函数内部不会改变这个函数所指向的内容，所以给这个函数传一个不可改变的指针（char *p = “linux”时）不会出现段错误；而一个未声明为const的指针的函数，你给他传一个不可改变的指针时就要小心了。

### 3.10.3、函数怎么向外部返回多个值

（1）一般来说，函数的输入部分就是函数参数，输出部分就是返回值，问题是函数的参数可以有很多个，而返回值只能有一个。这就造成了我们无法让一个函数返回多个值

（2）在我们现实中，一个函数需要返回多个值是很普遍的，因此完全依赖返回值是不靠谱的，通常的做法是用参数来作为返回（在典型的linux风格函数中，返回值是不用来返回结果的，而是用来返回一个0或者负数，用来表示程序运行结果是成功还是失败）

（3）普遍做法，编程中函数的输入和输出都是靠函数参数的，返回值只是用来表示函数执行的结果是成功还是失败。如果这个参数使用了做输入的就叫输入型参数，如果是用来做输出的就叫输出型参数。

（4）输出型参数就是用来让函数内部把数据输出到函数外部。

```c
#include<stdio.h>

int main(void)
{
    int a,b = 0;
    a = 3;
    muplit(a, &b);	//这里的a就是输入型参数，b就是输出型参数
    printf("b = %d\n", b);
}


int muplit(int a, int *p)
{
    *p = 5 * a;
    
     return 0;
}
```

### 3.10.4、总结

（1）看到一个函数的原型后，怎样一眼看出哪个参数做输入哪个做输出，函数传参如果传的是普通变量（不是指针）肯定是输入型参数；如果是指针就有2中可能，为了区别，经常的做法是：如果这个参数是做输入的（通常做输入的在函数内部只需要读取这个参数而不会需要更改它）就会在指针前面加上const来修饰；如果函数形参是指针变量比过去还没有加const，那么就表示这个函数用来做输出参数的。

****

# 4、C语言复杂表达式与指针高级用法

## 4.1、指针数组和数组指针

### 4.1.1、字面上理解指针数组和数组指针

（1）指针数组的实质是一个数组，这个数组中存储的内容全部是指针变量。

（2）数组指针的实质是一个指针，这个指针指向的是一个数组。

### 4.1.2、分析指针数组和数组指针的表达式

（1）int *p[5] ;  int ( *p)[5] ; int *(p[5]) ;

（2）一般规律：int * p；（p是一个指针）；int  p[5]；（p是个数组）

总结：我们在定义一个符号的时候，关键在于：首先要搞清楚你定义的符号是谁（第一步：找核心）；其次再来看谁跟核心最近、谁跟核心结合（第二步：找核心）；以后继续向外扩散（第三步：继续向外结合直到整个符号完）。

（3）如果核心和* 结合，表示核心是指针。如果核心和[ ]结合，表示核心是数组；如果核心和（）结合，表示核心是函数。

（4）一般规律来分析（1）的三个符号：

第一个：int * p[5] ;  这个p先和数组做运算，所以p是个指针数组，数组有5个元素大，数组中的元素都是指针

第二个：int ( *p )[5]；核心是p，p是一个指针，这个指针指向一个数组，数组由5个元素，数组中存的元素是int类型，这就是一个数组指针。

第三个：int *(p[5])；和第一个是一样的

==注意==：符号的优先级的用处：其实是决定当两个符号一起作用的时候决定哪个符号先运算，哪个符号后运算。

遇到优先级问题：第一是查优先级表，第二自己记住（只要记住[ ]  .  ->优先级比较高）

### 4.1.3、总结1：优先级和结合性是分析符号意义的关键

（1）在分析我们C语言问题时不要胡乱去猜测规律，不要总觉得C语言无从捉摸，从已知的规律出发按照既定的规律去做即可。

### 4.1.4、总结2：学会逐层剥离的分析方法

（1）找到核心后从内到外逐层进行结合，结合之后可以把已经结合的当作一个整体再和整体外面的继续结合

### 4.1.5、总结3：基础理论和原则是关键，没有无缘无故的规则

*****

## 4.2、函数指针与typedef

### 4.2.1、函数指针的实质（还是指针变量）

（1）函数指针的实质，还是指针变量。本身占4个字节（在32位系统里面，所有的指针都是4个字节）

（2）函数指针、数组指针和普通指针之间并没有本质区别，区别在于指针所指向的东西是什么。

（3）函数的实质是一段代码，这一段代码在内存中是连续分布的（一个函数的大括号括起来的所有语句将来编译出来生成的可执行程序是联系的），所以对于函数来说很关键的就是函数的第一句代码的地址，这个地址就是所谓的函数的首地址，在C语言中用函数名这个符号来表示。

（4）结合函数的实质，函数指针其实就是一个普通变量，这个普通变量的类型是函数指针变量类型，他的值就是某个函数的地址（也就是它的函数名这个符号在编译器中对应的值）

### 4.2.2、函数指针的书写和分析方法

（1）C语言本身是强类型语言（每个变量都有自己的类型），编译器可以帮我们做比较严格的类型检查

（2）所有的指针变量类型其实本质是一样的，但是C语言中去区分他们，写法也是不一样的（列如int类型的指针就写着 int * p；数组指针就写作int (*p)[5]，函数指针就得写的更复杂）

（3）假设我们现在有个函数：void func(void)；对应的函数指针：                    void (*p)(void)；类型是：void ( *)(void) 类型

（4）函数名和数组名最大的区别就是：函数名做右值时加不加&效果是一样的，但是数组名做右值时意义就不一样了。

（5）写一个复杂函数指针实列：`char *strcpy(char * dest, const char *src);` ，对应的函数指针：` char *(*pFunc)(char * dest, const char * src);`

```c
#include<stdio.h>

void func(void)
{
    printf("test for function pointer.\n");
}

int main(void)
{
    void (*p)(void);
    p = func;//左边是一个函数指针变量，右边是函数名也是函数首地址
    p = &func;//这种也是可以的，效果是一样的
    p();   //用函数指针来解引用以调用该函数
}
```

### 4.2.3、typedef关键字的用法

（1）typedef是C语言中的关键字，作用是用来定义（或者重命名）类型

（2）C语言中的类型一共有两种：一种是编译器定义的原生类型（基础数据类型，如int、double之类的）；第二种是用户自定义类型，不是语言自带的是程序员之际定义的（类如数组类型、结构体类型、函数类型……）。

（3）我们上面说的函数指针、指针数组、数组指针都属于用户自定义类型。

（4）有时候自定义类型太长了不方便，这时候就可以用typedef重命名一个短一点的名字

（5）注意：typedef是给类型重命名，也就是说typedef加工出来的是类型不是变量。类型是不占内存的

```c
#include<stdio.h>
#include<string.h>
//这句重命名了一种类型，这个新类型的名字叫pTypedef ，类型是char *(*) //(char * , const char * ) 类型的
typedef char *(*pTypedef)(char * , const char * );
//这个是函数指针数组
typedef char *(*pTypedef[5])(char * , const char * );

int main(void)
{
	char *(*pFunc)(char * , const char * );
    
    pTypedef p1;//效果等效于上面的定义
    pTypedef p2;
    
    p2 = pFunc;//能够通过编译，说明他们两个类型是相同的
}
```

*****

## 4.3、函数指针实战

### 4.3.1、用函数指针调用执行函数

```c
//程序演示,计算器
#include<stdio.h>
int add(int a, int b);
int sub(int a, int b);
int mul(int a, int b);
int div(int a, int b);
//定义了一个函数指针类型，这个函数指针指向了一种特定的类型
typedef int (*pFunc)(int, int); 

int main(void)
{
    int a, b, sum = 0;
    pFunc p1 = NULL;
    char c = 0;
    printf ("please input number：")；
    scanf ("%d %c %d", &a, &c, &b);
    switch (c):
    {
        case '+':
        	p1 = add;
        	break;			            
        case '-':
        	p1 = sub;
        	break;
        case '*':
        	p1 = mul;
        	break;
        case '/':
        	p1 = div;
        	break;
        default:
        	p1 = NULL;
        	break;
    }
    sum = p1(a, b);
    printf("%d %c %d = %d\n",a, c, b, sum);
    			
    
}

int add(int a, int b)
{
    return a + b;		
}
int sub(int a, int b)
{
    return a - b;
}
int mul(int a, int b)
{
    return a * b;
}
int div(int a, int b)
{
    return a / b;
}
```

（1）最简单的函数指针来调用函数的示例，在上节课中已经演示过了。

（2）本节演示的是用函数指针指向不同的函数来实现同一个调用执行不同的结果。

（3）如果学过C++或者Java或者C#等面向对象的语言，就会知道面向对象三大特征中有一个多态。多态就是同一个执行实际结果不一样，跟我们这里看到的现象其实是一样的。

（4）刚才的调试过程，可以得到很多信息：

第一：当程序出现段错误时，第一步先定位段错误。定位的方法就是在可疑处加打印信息，从而锁定导致段错误的语句，然后集中分析这句为什么会段错误。

第二：linux中命令行默认是行缓冲的，意思就是说当我们程序printf输出的时候，linux不会一个字一个字的输出我们的内容，而是将其缓冲起来放在缓冲区等一行准备完了再一次性把一行全部输出出来（为了效率）。linux判断一行有没有完的依据就是换行符'\n'（windows中换行符是\r\n, linux中是\n，iOS中是\r）。也就是说你printf再多，只要没有遇到\n（或者程序终止，或者缓冲区满）都不会输出而会不断缓冲，这时候你是看不到内容输出的。因此，在每个printf打印语句（尤其是用来做调试的printf语句）后面一定要加\n，否则可能导致误判。

第三：关于在linux命令行下用scanf写交互性代码的问题，想说以下几点：

 1. 命令行下的交互程序纯粹是用来学习编程用的，几乎没有实践意义，大家别浪费时间了。
 2. scanf是和系统的标准输入打交道，printf和标准输出打交道。要完全搞清楚这些东西得把标准输入标准输出搞清楚。
 3. 我们用户在输入内容时结尾都会以\n结尾，但是程序中scanf的时候都不会去接收最后的\n，导致这个回车符还存留在标准输入中。下次再scanf时就会先被拿出来，这就导致你真正想拿的那个数反而没机会拿，导致错误。

### 4.3.2、结构体内嵌函数指针实现分层

（1）分层的原因是：在完成一个非常庞大的项目时，一个人弄不了，会把整个大项目进行分工，而要进行分工就得先进行分层，分层之后各个层次由不同的人完成，然后彼此调用组合共同完成工作

（2）本程序要完成一个计算器，我们设计了2个层次：上层是framework.c，实现应用程序框架；下层是cal.c，实现计算器。实际工作时cal.c是直接完成工作的，但是cal.c中的关键部分是调用的framework.c中的函数来完成的。

（3）先写framework.c，由一个人来完成。这个人在framework.c中需要完成计算器的业务逻辑，并且把相应的接口写在对应的头文件中发出来，将来别的层次的人用这个头文件来协同工作。

（4）另一个人来完成cal.c，实现具体的计算器；这个人需要framework层的工作人员提供头文件来工作（但是不需要framework.c）

```c
//模拟分层  假设这个是cal.h文件
#ifndef __CAL_H__
#define __CAL_H_


typedef int (*pFunc)(int, int);

//结构体使用了做计算器的，计算器工作需要计算的原材料
struct cal_t
{
    int a;
    int b;
    pFunc p;
    
};
//函数原型声明
int calculator(const struct cal_t *p);


#endif
```



```c
//模拟分层  假设这个是framework.c文件
#include"cal.h"

//计算器函数
int calculator(const struct cal_t *p)
{
    return p->p(p->a, p->b);
}

```



```c
//模拟分层  假设这个是cal.c文件
#include"cal.h"
#include<stdio.h>

int add(int a, int b)
{
    return a + b;		
}
int sub(int a, int b)
{
    return a - b;
}
int mul(int a, int b)
{
    return a * b;
}
int div(int a, int b)
{
    return a / b;
}


int main(void)
{
    int sum;
    struct cal_t myCal;
    myCal.a = 13;
    myCal.b = 14;
    myCal.p = add;

    sum = calculator(&myCal);
    printf("sum = %d\n", sum);

    return 0;
}
```



（5）总结：

​	第一：本节和上节实际完成的是同一个习题，但是采用了不同的程序架构。

​	第二：对于简单问题来说，上节的不分层反而容易理解，反而简单；本节的分层代码不好理解，看起来有点把简单问题复杂化的意思。原因在于我们这个问题本身确实是简单问题，而简单问题就应该用简单方法处理。我们为什么明知错误还要这样做？目的是向大家演示这种分层的写代码的思路和方法。

​	第三：分层写代码的思路是：有多个层次结合来完成任务，每个层次专注各自不同的领域和任务；不同层次之间用头文件来交互。

​	第四：分层之后上层为下层提供服务，上层写的代码是为了在下层中被调用。

​	第五：上层注重业务逻辑，与我们最终的目标相直接关联，而没有具体干活的函数。

​	第六：下层注重实际干活的函数，注重为上层填充变量，并且将变量传递给上层中的函数（其实就是调用上层提供的接口函数）来完成任务。

​	第七：下层代码中其实核心是一个结构体变量（譬如本例中的struct cal_t），写下层代码的逻辑其实很简单：第一步先定义结构体变量；第二步填充结构体变量；第三步调用上层写好的接口函数，把结构体变量传给它既可。

*****

## 4.4、再论typedef

### 4.4.1、C语言中2种类型：内建类型与用户自定义类型

（1）内建类型ADT、自定义类型UDT

### 4.4.2、typedef定义（或者叫重命名）类型而不是变量

（1）类型是一个数据模板，变量是一个实在的数据。类型是不占内存的，而变量是占内存的。
（2）面向对象的语言中：类型就是类class，变量就是对象。

### 4.4.3、typedef与#define宏的区别

`typedef char *pChar; `   这个对后面每一个变量都有用，这个定义的时候原来的类型在前面，要改变的在后面

`#define pChar char *`  宏属于替换 只对离他最近的起作用，这个定义的时候是新的类型在前面，宏的解释在后面

### 4.4.4、typedef与结构体

（1）结构体在使用时都是先定义结构体的类型，再用结构体类型去定义变量。

（2）C语言语法规定，结构体类型使用时必须是struct 结构体类型名 结构体变量名;这样的方式来定义变量。

```c
#include<stdio.h>
//结构体类型的定义
struct student
{
    char name[5];
    int age;
};
//将上面的定义方式修改,定义了结构体类型，有两个类型名一个是struct  //student还有一个是student_t
typedef struct student
{
    char name[5];
    int age;
}student_t;
//还可以两个类型名都相同
typedef struct student
{
    char name[5];
    int age;
}student;

int main(void)
{
	struct student s1;//struct student是类型 s1是变量
    s1.age = 12;
    student_t s2;
    
}
```

（3）使用typedef一次定义2个类型，分别是结构体变量类型，和结构体变量指针类型。

```c
#include<stdio.h>
//结构体类型的定义
struct student
{
    char name[5];
    int age;
}student;
//一次定义了两个类型，第一个是结构体类型定义了两个名字struct //teather,teather
//第二个是结构体指针类型，有两个名字，struct teather *,pTeather
typedef struct teather
{
    char name[20];
    int age;
    int mager;
}teather, *pTeather;

int main(void)
{
    teather t1;
    t1.age = 23;
    pTeather p1 = &t1;
    printf("teather age = %d\n", p1->age);
    /*struct student *pS1;
    student *pS2;//结构体指针，两种写法都可以
    */
}
```

### 4.4.5、typedef与const

（1）typedef int *PINT;	const PINT p2; 相当于是int *const p2;

（2）typedef int *PINT;	PINT const p2; 相当于是int *const p2;

（3）如果确实想得到const int *p;这种效果，只能typedef const int *CPINT; CPINT p1;

### 4.4.6、使用typedef的重要意义（2个：简化类型、创造平台无关的类型）

（1）简化类型的描述。

​	`char *(*)(char *, char *);-> typedef char *(*pFunc)(char *, char *);`	

（2）很多编程体系下，人们倾向于不使用int、double等C语言内建类型，因为这些类型本身和平台是相关的（譬如int在16位机器上是16位的，在32位机器上就是32位的）。为了解决这个问题，很多程序使用自定义的中间类型来做缓冲。譬如linux内核中大量使用了这种技术.
内核中先定义：typedef int size_t; 然后在特定的编码需要下用size_t来替代int（譬如可能还有typedef int len_t）

（3）STM32的库中全部使用了自定义类型，譬如typedef volatile unsigned int vu32;

****

## 4.5、二重指针

### 4.5.1、二重指针与普通一重指针的区别

（1）本质上来说，二重指针和一重指针的本质都是指针变量，指针变量的本质就是变量。

（2）一重指针变量和二重指针变量本身都占4字节内存空间，

```c
#include<stdio.h>

int main(void)
{
    char a;
    char *p1;
    char **p2;
    
    p1 = &a;
    //p2 = &a;//是不行的 p2是char **类型的
    	   //char **类型的意思是指针指向的变量还是个指针类型
    p2 = &p1;//p1本身是指针类型，再取地址就变成了char **类型和p2正好 			//匹配
}
```



### 4.5.2、二重指针的本质

（1）二重指针本质上也是指针变量，和普通指针的差别就是它指向的变量类型必须是个一重指针。二重指针其实也是一种数据类型，编译器在编译时会根据二重指针的数据类型来做静态类型检查，一旦发现运算时数据类型不匹配编译器就会报错。

（2）C语言中如果没有二重指针行不行？其实是可以的。一重指针完全可以做二重指针做的事情，之所以要发明二重指针（函数指针、数组指针），就是为了让编译器了解这个指针被定义时定义它的程序员希望这个指针被用来指向什么东西（定义指针时用数据类型来标记，譬如int *p，就表示p要指向int型数据），编译器知道指针类型之后可以帮我们做静态类型检查。编译器的这种静态类型检查可以辅助程序员发现一些隐含性的编程错误，这是C语言给程序员提供的一种编译时的查错机制。

（3）为什么C语言需要发明二重指针？原因和发明函数指针、数组指针、结构体指针等一样的。

### 4.5.3、二重指针的用法

（1）二重指针指向一重指针的地址

（2）二重指针指向指针数组的

（3）实践编程中二重指针用的比较少，大部分时候就是和指针数组纠结起来用的。

```c
#icnlude<stdio.h>

int main(void)
{
    int *p1[5];
    int *p2;
    int **p3;
    
    p2 = p1;//这是不行的
    p3 = p1;//p1是指针数组名，本质上是数组名，做右值时表示首元素的首地			  //址，而我们数组元素就是一个int *类型的，所以p1就是一个int 			//*类型变量的指针的指针,所以它本质上是一个int **类型的
}
```



（4）实践编程中有时在函数传参时为了通过函数内部改变外部的一个指针变量，会传这个指针变量的地址（也就是二重指针）进去

```c
#include<stdio.h>

int func(int **p)
{
    *p = (int *)0x12345678;
}

int main(void)
{
    int a = 4;
    int *p = &a;			//p指向a
    printf("p = %p\n", p);	//p打印出来就是a的地址
    func(&p);				//在我们func内部将其指向的地址更改
    printf("p = %p\n", p);	//p已经不指向a了
}
```



### 4.5.4、二重指针与数组指针

（1）二重指针、数组指针、结构体指针、一重指针、普通变量的本质都是相同的，都是变量。

（2）所有的指针变量本质都是相同的，都是4个字节，都是用来指向别的东西的，不同类型的指针变量只是可以指向的（编译器允许你指向的）变量类型不同。

（3）二重指针就是：指针数组指针

****

## 4.6、二维数组

### 4.6.1、二维数组的内存映像

（1）一维数组在内存中是连续分布的多个内存单元组成的，而二维数组在内存中也是连续分布的多个内存单元组成的。

（2）从内存角度来看，一维数组和二维数组没有本质差别。

（3）二维数组`int a[2][5]`和一维数组`int b[10]`其实没有任何本质差别。我们可以把两者的同一单元的对应关系写下来。

`a[0][0]	 a[0][1]   a[0][4]	 a[1][0]	a[1][1]	  a[1][4]	`

`b[0]	 	 b[1]	    b[4]	  b[5]	    b[6]	  b[9]`

（4）既然二维数组都可以用一维数组来表示，那二维数组存在的意义和价值在哪里？明确告诉大家：二维数组a和一维数组b在内存使用效率、访问效率上是完全一样的（或者说差异是忽略不计的）。在某种情况下用二维数组而不用一维数组，原因在于二维数组好理解、代码好写、利于组织。

（5）总结：我们使用二维数组（C语言提供二维数组），并不是必须，而是一种简化编程的方式。想一下，一维数组的出现其实也不是必然的，也是为了简化编程。



### 4.6.2、数组的第一维和第二维

（1）二维数组`int a[2][5]`中，2是第一维，5是第二维。

（2）结合内存映像来理解二维数组的第一维和第二维的意义。首先第一维是最外面一层的数组，所以`int a[2][5]`这个数组有2个元素；其中每一个元素又是一个含有5个元素的一维数组（这个数组就是第二维）。

（3）总结：二维数组的第一维是最外部的那一层，第一维本身是个数组，这个数组中存储的元素也是个一维数组；二维数组的第二维是里面的那一层，第二维本身是个一维数组，数组中存的元素是普通元素，第二维这个一维数组本身作为元素存储在第一维的二维数组中。



### 4.6.3、二维数组的下标式访问和指针式访问

（1）回顾：一维数组的两种访问方式。以int b[10]为例, int *p = b;。
b[0] 等同于 *(p+0);   b[9] 等同于 *(p+9);  b[i] 等同于 *(p+i)

（2）二维数组的两种访问方式：以`int a[2][5]`为例，(合适类型的)`p = a;`
`a[0][0]`等同于`*(*(p+0)+0); a[i][j]`等同于` *(*(p+i)+j)`



### 4.6.4、二维数组的应用和更多维数组

（1）最简单情况，有10个学生成绩要统计；如果这10个学生没有差别的一组，就用b[10]；如果这10个学生天然就分为2组，每组5个，就适合用`int a[2][5]`来管理。

（2）最常用情况：一维数组用来表示直线，二维数组用来描述平面。数学上，用平面直角坐标系来比拟二维数组就很好理解了。

（3）三维数组和三维坐标系来比拟理解。三维数组其实就是立体空间。

（4）四维数组也是可以存在的，但是数学上有意义，现在空间中没有对应（因为人类生存的宇宙是三维的）。

​	总结：一般常用最多就到二维数组，三维数组除了做一些特殊与数学运算有关的之外基本用不到。（四轴飞行器中运算飞行器角度、姿态时就要用到三维数组）

***

## 4.7、二维数组的指针和运算

### 4.7.1、指针指向二维数组的数组名

（1）二维数组的数组名表示二维数组的第一维数组中首元素（也就是第二维的数组）的首地址

（2）二维数组的数组名a等同于&a[0]，这个和一维数组的符号含义是相符的。

（3）用数组指针来指向二维数组的数组名是类型匹配的。

```c
#include<stdio.h>

int main(void)
{
    int a[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};
    
    int (*p)[5];//数组指针，指针指向数组，有5个int类型的元素
    p = a;		//a是二维数组数组名，单独出现是二维数组第一维首地址
    			//等同于&a[0]
    p = &a[0];//这样写也是可以的
    
    printf("a[1][3] = %d\n", *(*(p+1)+3));
}
```

### 4.7.2、指针指向二维数组第一维

```c
#include<stdio.h>

int main(void)
{
    int a[2][5] = {{1,2,3,4,5},{6,7,8,9,10}};
    
    int *p = a[0];//a[0]表示二维数组的第一维的第一个元素，相当于是第二				    //维的整体数组的数组名，数组名又表示数组首元素的首地					 //址，因此a[0]等同于&a[0][0]
    int *p = &a[0][0];
    printf("a[0][3] = %d\n", *(p+3));
    
    int *p1 = a[1];       
    printf("a[1][3] = %d\n", *(p1+3));//这样才能访问a[1][3]
}
```

（1）用int *p来指向二维数组的第一维a[i]

### 4.7.3、二维数组指针指向第二维

（1）二维数组的第二维元素其实就是普通变量了（`a[1][1]`其实就是int类型的7），已经不能用指针类型和它相互赋值了。

（2）除非`int *p = &a[i][j];`，类似于指针指向二维数组的第一维。

==总结==

1、数组中各个符号的含义。
2、数组的指针式访问，尤其是二维数组的指针式访问。	

*****

# 5、数组&字符串&结构体&共用体&枚举

## 5.1、程序中内存从哪里来1–栈

### 5.1.1、程序执行需要内存支持

（1）对于程序来说，内存就是程序的立足之地（程序是被放在内存中运行的）：程序运行时内存来存储一些临时变量。

### 5.1.2、内存管理最终是由操作系统完成的

（1）内存本身在物理上是一个硬件器件，由硬件系统提供。

（2）内存是由我们的操作系统统一管理，为了内存管理方便又合理，操作系统提供了多种机制来让我们应用程序使用内存。这些机制彼此不同，各有特点，我们的程序根据自己的实际情况来选择某种方式获取内存（在操作系统处登记这块内存的临时使用权限）、使用内存、释放内存（向操作系统归还这块内存的试用权）。

### 5.1.3、三种内存来源：栈（stack）、堆（heap）、数据区（.data）

（1）在一个C语言程序中，能够获取内存就是三种方式：栈（stack）、堆（heap）、数据区（.data） 

### 5.1.4、栈的详解

每一个程序都有自己独立的栈。

运行时自动分配&自动回收：栈是自动管理的，程序员不需要手动干预。方便简单

反复使用：栈内存在程序中其实就是一块空间，程序反复使用这块空间。

脏内存：栈内存由于反复使用，每次使用程序后不会去清理，因此分配到时原来的值还保留着。

临时性：函数不能返回栈变量的指针，因为这个空间时临时的

栈会溢出：因为操作系统事先给定了栈的大小，如果在函数中无穷尽的分配栈内存总能用完。

```c
#include<stdio.h>
//函数不能返回函数内部局部变量的地址，因为这个函数执行返回完之后这个局 //部变量就已经不在了,这个局部变量是分配在栈上的，虽然不在了但是栈的内存 //还是可以访问的，但是实际上访问的地址已经和之前哪个变量没关系了
int *func(void)
{
    int a = 4;//a是一个局部变量，分配在栈上，又叫临时变量
    printf("&a = %p\n",&a);
    return &a;
}

int main(void)
{
    int *p = NULL;
    p = func();
    printf("p = %p\n",p);
    
    printf("*p = %d\n", *p);//证明栈内存使用完之后时脏的
    return 0;
}
```

****

## 5.2、程序中内存从哪里来2–堆

### 5.2.1、堆内存详解

堆是所有程序共有的

操作系统堆管理器管理：堆管理器是操作系统的一个模块，堆的方式分配灵活，按需配比。

大块内存：堆内存管理着总量很大的操作系统内存块，各进程可以按需申请使用，使用完释放。

程序手动申请&释放：手动的意思是需要程序员写代码去申请malloc和释放free

脏内存：堆内存也是反复使用的，而且使用者用完释放前是不会清除的，因此也是脏的。

临时性：堆内存只在malloc和free之间属于我这个进程，而可以访问，在malloc之前和free之后都不能访问，否则会有不可预料而定后果。

### 5.2.2、堆内存使用范例

```c
#include<stido.h>
#include<stdlib.h>

int main(void)
{
    //需要一个1000个int元素的数组
    //第一步：申请和绑定
    int *p = (int *)malloc(1000*sizeof(int));
    //第二步：检验申请是否成功
    if(NULL == P)
    {
        printf("malloc error\n");
        return -1;
    }
    //第三步：使用内存
 // p = &a;//如果在free之前个p另外赋值，那么malloc申请的那段内存就丢失		      //掉了,malloc后p和返回的那段内存相绑定，p是那段内存的唯一联			//系人，如果在没有free之前就丢了，那么这段内存就永远丢了，		   //丢了的概念就是在操作系统的堆管理器中这段内存是当前进程拿			//着的，但是你已经用不了了，所以你想申请新的来替换使用，这			//就叫程序吃内存。学名叫内存泄漏
    *(p+0) = 1;
    *(p+1) = 2;//正确使用
    
    //第四步：释放内存
    free(p);
    p = NULL;//防止野指针
}
```

（1）void * 是个指针类型，malloc返回的是一个void * 类型的指针，实质上malloc返回的是堆管理器分配给我的本次内存申请的内存的首地址（所以说malloc返回的其实是一个数字表示的是一个内存地址），为什么要使用void * 作为它的返回类型，主要是malloc帮我们分配内存时只是分配了内存空间，至于这段空间将来用来存储什么类型的元素malloc是不关心的，由程序员自己决定。

（2）什么是void类型，早期被翻译成空型，其实void不表没有类型而表示万能类型，void的意思是说这个数据的类型当前是不确定的，在需要的时候可以再去指定它的具体类型。void * 类型是个指针类型，这个指针本身所指向的类型是不确定的，换句话说这个指针在需要的时候可以被强制转换为需要的类型的指针，也就是说这个指针可以指向任何类型的元素。

（3）malloc的返回值：成功申请空间返回这个内存空间的指针，失败申请返回NULL，我们malloc获取的内存指针使用前一定要去检验是否申请成功

（4）malloc申请的内存时用完后要free释放。free(p);会告诉堆管理器这段内存我用完了你可以回收了。堆管理器回收了这段内存后这段内存当前进程就不应该再使用了。因为释放后堆管理器就可能把这段内存再次分配给别的进程，所以你就不能再使用了。

（5·）再调用free归还这段内存之前，指向这段内存的指针p一定不能丢（也就是不能给p另外赋值）。因为p一旦丢失这段malloc来的内存就永远的丢失了（内存泄漏），直到当前程序结束时操作系统才会回收这段内存。

### 5.2.3、malloc的一些细节表现

malloc(0)：申请0字节的空间本身就是一件无厘头的事情，一般不会碰到这个需要，如果真碰到这种事，实际会给你分配16个字节的空间并且返回了这个空间所在的地址，但是这个答案不是固定的，因为我们C语言并没有明确规定malloc(0)时的表现，由各malloc函数库的实现者来定义。

malloc(4)：我们gcc中的malloc默认最小是以16字节为分配单位的，如果malloc小于16字节时都会返回一个16字节的大小的内存。malloc实现时没有实现任意字节的分配而是允许一些大小的块内存的分配。

malloc(20)：去访问第200个元素的时候，实战中是可以访问的，这是因为C语言的管理不严谨的原因，我们不应该这么做

*****

## 5.3、程序内存从哪里来3–数据段

### 5.3.1、代码段、数据段、bss段

![](E:\Linux教程\华清远见\QQ图片20210412181508.png)

（1）编译器在编译程序的时候，将程序中所有的元素分成了一些组成部分，各部分构成一个段，所以说段是可执行程序的组成部分。

（2）代码段（又称ro 只读段）：就是我们程序中的可执行部分，直观上来说代码段就是函数堆叠组成的，

（3）数据段（也被称为静态数据区、静态区）：数据段就是程序中的数据，直观理解就是C语言中的全局变量。（注意：全局变量才算是程序的数据，局部变量不算是程序的数据，只能算是函数的数据）

（4）bss段（又叫ZI（zero initial）段）：bss段的特点就是被初始化为0，bss段本质上也是属于数据段，bss段就是被初始化为0 的数据段

注意区分：数据段（.data）和bss段的区别和联系：二者本来没有本质区别，都是用来存放c程序中的全局变量，区别在于把显式初始化为非零的全局变量存在.data段，而把显示初始化为0或者未显示初始化（C语言规定未显示初始化的全局变量默认为0）的全局变量放在bss段。

### 5.3.2、有些特殊数据会被放到代码段

```c
#include<stdio.h>

int main(void)
{
    char *p = "linux";
  //char const *p = "linux"; 最正确的写法
    *(p+0) = 'f';
    printf("p = %f\n", p);
    return 0;
}
```

（1）C语言中使用`char *p = “linux”;` 定义字符串时，字符串“linux”实际上被分配到了代码段（ro只读段），也就是说这个字符串实际上是个字符串常量而不是变量字符串。

（2）const型常量：C语言中const关键字用来定义常量，常量就是不能被改变的量。const的实现方法至少有2种：第一种就是编译将const修饰的变量放在代码段去以实现不能修改（普遍见于各种单片机的编译器）；第二种就是由编译器来检查以确保const型的常量不会被修改，实际上const型的常量还是和普通变量一样放在数据段的（gcc中就是这样实现的）。

### 5.3.3、显式初始化为非零的全局变量和静态局部变量放在数据段

（1）放在.data段的变量有2种：第一种是显式初始化为非零的全局变量。第二种是静态局部变量，也就是static修饰的局部变量。（普通局部变量分配在栈上，静态局部变量分配在.data段）

### 5.3.4、未初始化或显式初始化为0的全局变量放在bss段

（1）bss段和.data段并没有本质区别，几乎可以不用明确去区分这两种。

### 5.3.5、总结：C语言中所有变量和常量所使用的内存无非以上三种情况

（1）相同点：三种获取内存的方法，都可以给程序提供可用内存，都可以用来定义变量给程序用。

（2）不同点：栈内存对应C中的普通局部变量（别的变量还用不了栈，而且栈是自动的，由编译器和运行时环境共同来提供服务的，程序员无法手工控制）；堆内存完全是独立于我们的程序存在和管理的，程序需要内存时可以去手工申请malloc，使用完成后必须尽快free释放。（堆内存对程序就好象公共图书馆对于人）；数据段对于程序来说对应C程序中的全局变量和静态局部变量。

（3）如果我需要一段内存来存储数据，我究竟应该把这个数据存储在哪里？（或者说我要定义一个变量，我究竟应该定义为局部变量还是全局变量还是用malloc来实现）。不同的存储方式有不同的特点，简单总结如下：

​	函数内部临时使用，出了函数不会用到，就定义局部变量

​	堆内存和数据段几乎拥有完全相同的属性，大部分时候是可以完全替换的。但是生命周期不一样，堆内存的生命周期是从malloc开始到free结束，而全局变量是从整个程序一开始执行就开始，直到整个程序结束才会消灭，伴随程序运行的一生。

​	启示：如果你这个变量只是在程序的一个阶段有用，用完就不用了，就适合用堆内存；如果这个变量本身和程序是一生相伴的，那就适合用全局变量。（堆内存就好象租房、数据段就好象买房。堆内存就好象图书馆借书，数据段就好象自己书店买书）你以后会慢慢发现：买不如租，堆内存的使用比全局变量广泛。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>


int main(void)
{
    char a[] = "linux";
    
    char *p = (char *)malloc(10);
    if(NULL == p)
    {
        printf("malloc error\n");
        return -1;//malloc定义之后一定要检查申请状态
    }
    memset(p,0,10);//给申请空间的字符串数组复位为0
    strcpy(p,"linux");//将申请字符串数组空间赋值的方法
}
```



*****

## 5.4、C语言的字符串类型

### 5.4.1、C语言没有原生字符串类型

（1）很大高级语言java、c#等就是有字符串类型的，有个string来表示字符串，用法和int很像，可以用string s1 = “linux”；来定义字符串类型

（2）C语言是没有string类型的，C语言中的字符串是通过字符指针来间接的实现的。

### 5.4.2、C语言使用指针来管理字符串

（1）C语言定义字符串方法：char * p = “linux”；此时p就叫字符串，但是实际上p只是一个字符指针（本质上就是一个指针，只是p指向的是一个字符串的起始地址而已）

### 5.4.3、C语言中字符串的本质：指针指向头、固定尾部的地址相连的一段内存

（1）字符串就是一串字符。字符反应在现实中就是文字、符号、数字等人用来表达的符号，反应在编程中字符就是字符类型的变量。C语言中使用ASCII编码对字符进行编程，编程后可以用char型变量来表示一个字符。字符串就是多个字符打包在一起共同组成的。

（2）字符串在内存中其实就是多个字节连续分布构成的（类似数组、字符串和字符数组很像）

（3）C语言中字符串三个核心要点：第一是用一个指针指向字符串的头；第二个是固定尾部（字符串总是以‘\0’结尾）；第三个是组成字符串的各字符彼此地址相连。

（4）'\0'是一个ASCII字符，其实就是编码为0的那个字符（真正的0，和数字0是不同的，数字0有它自己的ASCII编码）。要注意区分'\0'和'0'和0.（0等于'\0'，'0'等于48）

（5）'\0'作为一个特殊的数字被字符串定义为（幸运的选为）结尾标志。产生的副作用就是：字符串中无法包含'\0'这个字符。（C语言中不可能存在一个包含'\0'字符的字符串），这种思路就叫“魔数”（魔数就是选出来的一个特殊的数字，这个数字表示一个特殊的含义，你的正式内容中不能包含这个魔数作为内容）。

### 5.4.4、注意：指向字符串的指针和字符串本身是分开的两个东西

（1）char * p = “linux”；这段代码中，p本质上是一个字符指针，占4个字节；“linux”在代码段占6个字节；实际上总共消耗10个字节，这10个字节中：4字节的指针p叫做字符串指针（用来指向字符串的，理解为字符串的引子，但是它本身不是字符串），5字节用来从“linux”这5个字符的内存才是真正的字符串，最后一个字节使用了存‘\0’的内存是字符串的结尾标志（本质上也不属于字符串）。

### 5.4.5、存储多个字符的2种方法：字符串和字符数组

（1）我们有多个连续字符（典型的就是Linux这个字符串）需要储存，实际上有两种方式：第一种就是字符串，第二种就是字符数组

```c
#include<stdio.h>

int main(void)
{
    char *p = "linux";
    char a[] = "linux";//字符串和字符数组的两种定义方式
}
```

****

## 5.5、字符串和字符数组的细节

### 5.5.1、字符数组初始化与sizeof、strlen

（1）sizeof是C语言中的关键字，也是C语言中的一个运算符（sizeof使用时是sizeof（类型或变量名），所以很多人误以为sizeof是函数，其实不是），sizeof运算符用来返回一个类型或者变量所占的内存字节数。用sizeof的主要原因一是int、double等原生类型占几个字节和平台有关；二是在C语言中除了ADT之外还有UDT，这些用户自定义类型占几个字节无法一眼看出，所以需要用sizeof运算符让编译器帮忙计算的。

（2）strlen是C语言的库函数，这个库函数的原型是：size_t strlen(const char *s);这个函数接受一个字符串的指针，返回这个字符串的长度（以字节为单位）。注意一点：strilen返回的字符串长度是不包含结尾的‘\0’的，我们之所以需要strlen库函数是因为从字符串的定义（指针指向头、固定结尾、中间依次相连）可以看出无法之间得到字符串的长度，需要用strlen函数来计算得到字符串的长度。

（3）sizeof（数组名）运算符得到的永远是数组元素个数（也就是数组大小），和数组有无初始化，初始化多、少等都是没有关系的；strlen是用来计算我们字符串的长度的，只能传递合法的字符串进去才是有意义的，如果随便传递一个字符指针，但是这个字符指针并不是字符串是没有意义的。

（4）当我们定义数组时如果没有明确给出数组大小，则必须同时给它初始化，编译器会根据初始化式去自动计算数组的大小（数组定义时必须给出大小，要么直接初始化）

### 5.5.2、字符串和sizeof、strlen

（1）char *p = "linux"; sizeof(p)得到的永远是4，因为这时候sizeof测的是字符指针p本身的长度，和字符串的长度是无关的。

（2）strlen刚好用来计算字符串的长度。

### 5.5.3、字符数组和字符串的本质差异（内存分配角度）

（1）字符数组char a[] = "linux";来说，定义了一个数组a，数组a占6字节，右值"linux"本身只存在于编译器中，编译器将它用来初始化字符数组a后丢弃掉（也就是说内存中是没有"linux"这个字符串的）；这句就相当于是：char a[] = {'l', 'i', 'n', 'u', 'x', '\0'};

（2）字符串char *p = "linux";定义了一个字符指针p，p占4字节，分配在栈上；同时还定义了一个字符串"linux"，分配在代码段；然后把代码段中的字符串（一共占6字节）的首地址（也就是'l'的地址）赋值给p。

​	总结对比：字符数组和字符串有本质差别。字符数组本身是数组，数组自身自带内存空间，可以用来存东西（所以数组类似于容器）；而字符串本身是指针，本身永远只占4字节，而且这4个字节还不能用来存有效数据，所以只能把有效数据存到别的地方，然后把地址存在p中。

​	也就是说字符数组自己存那些字符；字符串一定需要额外的内存来存那些字符，字符串本身只存真正的那些字符所在的内存空间的首地址。

*****

## 5.6、C语言之结构体简单概述

### 5.6.1、结构体类型是一种自定义类型

（1）C语言中的2中类型：原生类型和自定义类型

### 5.6.2、结构体使用时先定义结构体类型再用类型定义变量

（1）结构体定义时需要先定义结构体类型再用类型定义变量

（2）也在定义结构体类型的同时定义结构体变量

```c
#include<stdio.h>

struct people
{
    char name[20];
    int age;
};

struct student
{
    char name[20];
    int age;
}s1;
//定义的同时定义变量

typedef struct student
{
    char name[20];
    int age;
}student;
//这样就是将类型struct student重命名为student不是定义变量

int main(void)
{
    struct people p1;//使用结构体类型定义变量
    s1.age = 23;
    printf("a1.age = %d\n", s1.age);
    
    struct student s2;
    s2.age = 21;//再定义其他变量还是可以的
}
```

### 5.6.3、从数组到结构体的进步之处

（1）结构体是从数组发展而来的。其实数组和结构体都算是数据结构的范畴了，数组就是最简单的数据结构、结构体比数组更复杂一些，链表、哈希表之类的比结构体复杂些；二叉树、图等又更复杂一些。

（2）数组有两个明显的缺陷：第一是我们定义时必须明确给定数组的大小，且这个大小在以后是不能更改的，第二个是数组要求所有元素的类型必须一致，更复杂的数据结构中就致力于解决数组的两个缺陷。

（3）结构体就是用来解决数组第二个缺陷的，可以将结构体理解为一个其中元素可以不相同的数组。结构体完全可以取代数组，只是在数组可用范围内它最简单。

```c
#include<stdio.h>

struct score
{
    int a;
    int b;
    int c;
};

int main(void)
{
    int a[3];//数组方式定义三个学生的成绩
    score s;//结构体方式定义三个学生的成绩
}
```

### 5.6.4、结构体变量中的元素如何访问

（1）数组中元素的访问方式：表明上有2种（数组下标和指针方式）；实质上都是指针方式

（2）结构体中元素访问方式：只有一种，用 . 号和->方式来访问（.和->访问结构体元素其实质是一样的，只是C语言规定用结构体变量来访问元素用. 用结构体变量的指针来访问元素用->。实际上在高级语言中已经不区分了，都用.）

（3）结构体的访问方式有点类似于数组下标的方式

思考：结构体变量的点号或者->访问元素的实质是什么？其实本质上还是用指针来访问的。

```c
#include<stdio.h>

struct score
{
    int a;
    int b;
    int c;
};

int main(void)
{
    score s;
    //编译器在内部还是将其转为指针方式访问
    s.a = 12;//相当于：int *p = s; *(p+0) = 12;
    s.b = 22;//相当于：int *p = s; *(p+1) = 22;
    s.c = 33;//相当于：int *p = s; *(p+2) = 33;
}
```

```c
//结构体和指针的关系
#include<stdio.h>

struct mystruct
{
    int a;//内存中占4个字节
    double b;//内存中占8个字节
    char c;
};

int mian(void)
{
  	struct mystruct s1;
    s1.a = 12;//相当于 int *p = (int *)&s1; *p = 12;
    s1.b = 4.4;//相当于 double *p = (double *)((int)&s1 + 4);*p=4.4
    s1.c = 'a';//相当于char *p = (char *)((int)&s1 + 12);*p = 'a'
}
```

****

## 5.7、结构体的对齐访问

### 5.7.1、举例说明什么是结构体对齐访问

```c
#include<stdio.h>

struct s
{
    char c;//c实际上占4个字节，而不是一个字节
    int a;
}s1;

int main(void)
{	//证明struct s 所占字节数
    printf("sizeof(struct s) = %d\n", sizeof(struct s));//结果为8
    
    s1.c = 'c';
    s1.a = 12;
    
    char *p1 = (char *)&s1;
    printf("*p1 = %c\n", *p1);
    
    int *p2 = (int *)((int)&s1 + 1);
    printf("*p2 = %d\n", *p2);//结果错误
    
    int *p3 = (int *)((int)&s1 + 4);
    printf("*p3 = %d\n", *p3);//结果正确 *p3 = 12
}
```

（1）上一章节说过结构体中元素的访问其实本质上还是用指针的方式，结合这个元素在整个结构体中的偏移量和这个元素的类型进行访问的。

（2）但是实际上结构体元素的偏移量比我们上一章节的还要复杂，因为结构体要考虑元素的对齐访问，所以每个元素实际所占的字节数和自己本身的类型所占的字节数不一定完全一样。（列如char c 实际占字节数可能是1、也可能是2……）

（3）一般来说，我们用. 的方式来访问结构体元素时，我们是不用考虑结构体的元素对齐的，因为编译器会帮我们处理这个细节。但是因为C语言本身很底层的语言，而且做嵌入式开发经常需要从内存角度，以指针方式来处理结构体及其中的元素，因此还是需要掌握结构体的对齐规则。

### 5.7.2、结构体为何需要对齐

（1）结构体中元素对齐访问的主要原因是为了配合硬件，就是说硬件本身有物理限制，如果对齐排布和访问会提高效率，否则会大大降低效率。

（2）内存本身是个物理器件（DDR内存芯片，SoC上的DDR控制器），本身有一定的局限性；如果内存每次访问按照4个字节效率是最高的，如果你不对齐访问效率要低很多。

（3）还有很多别的因素和原因，导致我们需要对齐访问，列如说Cache的一些缓存特性，还有其他硬件（列如说MMU、LCD显示器）的一些内存依赖特性，所以会要求内存对齐访问。

（4）对比对齐访问和不对齐访问：对齐访问牺牲了内存空间，换取速度性能；而非对齐访问牺牲了访问速度性能，换取了内存空间的完全利用。

### 5.7.3、结构体对齐的规则和运算

（1）编译器本身可以设置内存对齐的规则（不对齐访问其实就是1字节对齐），有以下规则需要记住：

第一个：32位编译器，一般默认对齐方式是4字节对齐

```c
#include<stdio.h>

/*第一题分析过程
*首先是整个结构体，整个结构体变量4字节对齐是由编译器保证的，我们不要操心
*然后是第一个元素a，a的开始地址就是整个结构体的开始地址，所以自然是4字节
*对齐。但是a的结束地址要由下一个元素说的算。
*然后第二个元素b，因为上一个元素a本身占4字节本身就是对齐的，所以留给b的开
*始地址也是4字节对齐地址，所以b可以直接放（b放的位置就决定了a一共占4字  *节，因为不需要填充）。b的起始地址定了之后，结束地址不能确定（因为可能）
*需要填充，结束地址要看下一个地址
*然后三个元素c，shuort类型需要2字节对齐（short类型元素必须放在类似0，*2，4，8这样的地址处，不能放在奇数地址处），因此c不能紧挨着b来存放，解决
*方案是在b之后添加1字节填充（padding），然后再开始放c，c放完之后还没有结*束，当整个结构体所有的元素都对齐存放后，还没有结束，因为整体结构还要是4 *的整数倍
*
*/

struct mystruct1
{				//1字节对齐		4字节对齐
    int a;		// 4			4
    char b;		// 1			2 有1个字节是为了填充(1+1)
    short c;	// 2			2
};

typedef struct mystruct2
{				//1字节对齐		4字节对齐
    char a;		 // 1			4(1+3)
    int b;		 // 4			4
    short c;	 // 2			4(2+2)
}Mys2;

typedef struct
{				 //1字节对齐		4字节对齐
    int a;		  // 4
    short b;       // 2
    static int c;  //
}Mys3;

typedef struct mystruct5
{						 //1字节对齐		4字节对齐
    int a;				  // 4				4
    struct mystruct1 s1;   // 7(4+1+2)		  8(7+1)
    double b;			  // 8				8
    int c;				  // 4				4
}Mys5;

struct stu
{					//1字节对齐		4字节对齐
    char sex;		 // 1			4(1+3)
    int length;		 // 4			4
    char name[10];	 // 10			12(10+2) 
};

int main(void)
{
    printf("sizeof(struct mystruct1) = %d\n",sizeof(struct mystruct1));
    printf("sizeof(struct mystruct2) = %d\n",sizeof(struct mystruct2));
    printf("sizeof(struct mystruct5) = %d\n",sizeof(struct mystruct5)); 
    printf("sizeof(struct stu) = %d\n",sizeof(struct stu)); 
    return 0;
}
```

总结下：结构体对齐的分析要点和关键

1、结构体对齐要考虑：结构体整体本身必须安置在4字节对齐处，结构体对齐后的大小必须是4的倍数（编译器设置为4字节对齐时，如果编译器设置为8字节对齐，则这里的4就是8）

2、结构体中每个元素都必须对齐存放，而每个元素本身都有自己的对齐规则。（对齐规则就是元素自身类型所占的字节数）

3、编译器考虑结构体存放时，以满足以上2点要求的最少内存需要的排布来算

### 5.7.4、gcc支持但是不推荐的对齐指令：#pragma pack( )	 #pragma pack(n) (n=1/2/4/8)

（1）#pragma是用来指挥编译器，或者说设置编译器的对齐方式的。编译器默认的对齐方式是4，但是有时候会不希望对齐方式是4（列如说希望1字节对齐，也可能是8字节对齐）

（2）常用的设置编译器对齐的命令有两种：第一种是#pragma pack( )，这种是设置编译器1字节对齐（有些人喜欢讲：设置编译器不对齐，或者说取消编译器对齐访问）；第二种是#pragma pack(4)；这个括号中的数字就是我们希望多少字节对齐

（3）我们需要#pragma pack(n)开头，以#pragma pack()结尾，定义一共区间，这个区间内的对齐就为n

（4）#pragma pack的方式在很多c环境下都是支持的，但是gcc虽然也可以但是不建议使用

```c
#include<stdio.h>
#pragma pack(1)	//意思就是取消字节对齐



#pragma pack()
```

### 5.7.5、gcc推荐的对齐指令：`__attribute__((packed))`  `__attribute__((aligned(n)))` 

（1）`__attribute__((packed))`使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。packed的作用就是取消对齐访问。

（2）`__attribute__((aligned(n)))`使用时直接放在要进行内存对齐的类型定义的后面，然后它起作用的范围只有加了这个东西的这一个类型。它的作用是让整个结构体变量整体进行n字节对齐（注意是结构体变量整体n字节对齐，而不是结构体内各元素也要n字节对齐）

### 5.7.6、参考文献

http://www.cnblogs.com/dolphin0520/archive/2011/09/17/2179466.html
	http://blog.csdn.net/sno_guo/article/details/8042332

***

## 5.8、offsetof宏与container_of宏

### 5.8.1、由结构体指针进而访问各元素的原理

（1）通过结构体整体变量来访问其中各个元素，本质上是通过指针方式访问的，形式上是通过. 号的方式（这时候是编译器帮我们自动计算了偏移量）。

### 5.8.2、offsteof宏的作用是

（1）作用：用宏来计算结构体中某个元素和结构体首地址的偏移量（其实质是通过编译器来帮我们计算的）。

（2）offsetof宏的原理：我们虚拟一个type类型的结构体变量，然后用我们的type.member来访问那个member元素，继而得到我们的member相对于我们整个变量首地址的偏移量

（3）学习思路：先学会用这个宏，再去理解这个宏的原理

`(TYPE *)0`  这是一个强制类型转换，把0地址强制类型转换成一个指针，这个指针指向一个TYPE类型的结构体变量（实际上这个结构体变量可能不存在，但是只要我不去解引用这个指针就不会出错）。

`((TYPE *)0)->MEMBER `   `(TYPE *)0`是一个TYPE类型结构体变量的指针，通过指针指针来访问这个结构体变量的member元素

`&((TYPE *)0)->MEMBER `    等效于`&(((TYPE *)0)->MEMBER)`，意义就是得到member元素的地址。但是因为整个结构体变量的首地址是0

```c
#include<stdio.h>

struct mystruct
{
    char a;
    int b;
    double c;
};

#define offsetof(TYPE,MEMBER) ((int)&((TYPE *)0)->MEMBER)

int main(void)
{
  	mystruct s1;
    s1.b = 12;
    int *p = (int *)((char *)&s1 + 4);
    printf("*p = %d\n", *p);
    
    int offsetofa = offsetof(struct mystruct,a);
    printf("offsetofa = %d\n", offsetofa);
    
}
```

### 5.8.3、container_of宏

（1）作用：知道一个结构体中某个元素的指针，反推这个结构体变量的指针,有了这个container_of宏，我们可以从一个元素的指针得到整个结构体变量的指针，继而得到结构体中所有其他变量的指针

（2）typeof关键字的作用：typeof(a)时由变量a得到a的类型，typeof就是由我们这个变量名得到变量数据类型的。

（3）这个宏的工作原理：先用typeof得到member元素的类型定义成一个指针，然后用这个指针减去该元素相对于整个结构体变量的偏移量（偏移量用offsetof宏得到的），减去之后得到的就是整个结构体变量的首地址了，再把这个地址强制类型转换为type * 类型即可。

```c
#include<stdio.h>

struct mystruct
{
    char a;
    int b;
    double c;
};
//TYPE是结构体类型，MEMBER是结构体中一个元素的元素名
//这个宏返回值是member元素相对于整个结构体变量的首地址的偏移量，类型是 //int类型的
#define offsetof(TYPE,MEMBER) ((int)&((TYPE *)0)->MEMBER)
//ptr是指向结构体元素member的指针，type是结构体类型，member是结构体中一 //个元素的元素名，这个宏返回的就是指向整个结构体变量的指针，类型是（type //*）
#define container_of(ptr,type,member) ({  		   \
const typeof(((type *)0)->member) * __mptr = (ptr);    \
(type *)((char *)__mptr - offsetof(type,member));})

int main(void)
{
  	mystruct s1;
    struct mystruct *ps = NULL;
    short *p = &(s1.c);//p就是指向我们这个结构体中某个member的指针
    printf("&s1 = %p\n", &s1);
    
    //问题是通过p来计算得到我们s1的指针
    ps = container_of(p,struct mystruct,c);
    printf("ps = %p\n",ps);
}
```

### 5.8.4、学习指南和要求

（1）最基本的要求：必须会这两个宏的使用，就是知道这两个宏接受什么参数返回什么值，会用这两个值写代码，看见代码中别人用着两个宏能理解是什么意思

（2）升级要求：能理解这两个宏的工作原理，能表述出来（有些面试笔试题会这么要求）

（3）更高级的要求：能自己写出这两个宏（不要着急，慢慢来）

***

## 5.9、共用体（union）

### 5.9.1、共用体类型的定义、变量定义和使用

（1）共用体union和结构体struct在类型定义、变量定义和使用方法上很相似

（2）共用体和结构体的不同：结构体类似一个包裹，结构体中的成员彼此独立存在，分布在内存的不同单元中，他们只是被打包为一个整体叫做结构体而已；共用体中的各个成员其实是一体的，彼此不独立，他们使用同一个内存单元。有时候是这个元素有时候是别的元素，更准确的说法是同一个内存空间有多种解释方式。

（3）共用体union就是对内存中存储的二进制的不同的理解方式。

（4）在有些书中把union翻译成联合（联合体），这个名字不好，现在翻译为共用体比较合适。

（5）union的sizeof测到的大小实际上就是union种各个元素里面占用内存最大的那个元素的大小。因为可以存的下这个就可以存下其他的元素。

（6）union中的元素不存在内存对齐的问题，因为union中实际上只有一个空间的大小，都是从同一个地址开始的（开始的地址就是整个union占用的空间的首地址）所以不涉及到内存对齐。

```c
#include<stdio.h>

struct mystruct
{
    int a;
    char b;
};

//共用体类型的定义
//a和b其实指向同一块内存空间，只是对这块内存空间的2种不同的解析方式。
//如果我们使用u1.a那么就按照int类型来解析这个内存空间；如果我们使用u1.b
//那么就按照char类型来解析这块内存空间
union myunion
{
    int a;
    int b;
};

int main(void)
{
    //test 1
    struct mystruct s1;
    s1.a = 23;
    printf("s1.b = %d\n", s1.b);//结果s1.b = 0;s1.a和s1.b是独立存在
    
    union myunion u1;//共用体变量的定义
    u1.a = 23;		//元素的使用
    printf("u1.b = %d\n", u1.b);//u1.b = 23 ，u1.a和u1.b是相关的
    
    printf("u1.a = %p\n", &u1.a);
    printf("u1.b = %p\n", &u1.b);//a和b指向同一块地址空间，只是对之快 								//空间的解析规则不同
    
    return 0;		
}
```

### 5.9.2、共用体和结构体的相同和不同

（1）相同点就是操作语法几乎相同。

（2）不同点是本质上的不同。struct是多个独立元素（内存空间）打包在一起；union是一个元素（内存空间）的多种不同解析方式。

### 5.9.3、共用体的主要用途

（1）共用体就用在那种对同一个内存单元进行多种不同规则解析的这种情况下。

（2）C语言中其实是可以没有共用体的，用指针和强制类型转换可以替代共用体完成同样的功能，但是共用体的方式更简单、更便捷、更好理解。

```c
#include<stdio.h>

union test
{
    int a;
    float b;
};

int main(void)
{
    union test t1;
    t1.a = 1123477881;
    printf("t1.b = %d\n", t1.b);//t1.b = 123.456
    //相当于用指针方式的
    int a = 1123477881;
    printf("b = %d\n",*((float *)&a));
}
```



***

## 5.10、大小端模式

### 5.10.1、什么是大小端模式

（1）大端模式（big endian）和小端模式（little endian），最早是小说中提出的词，本来和计算机没有关系。

（2）后来计算机通信发展起来了，遇到了一个问题就是：在串口等串行通信中，一次只能发送一个字节。这时候我要发送一个int类型的数就遇到了一个问题，int类型有4个字节，我是按照：byte0 byte1 byte2 byte3这样的顺序发送，还是按照byte3 byte2 byte1 byte0这样的顺序发送。规则就是发送方和接收方必须按照同样的字节顺序来通信，否则就会出现错误。这就叫通信系统中的大小端模式，这是计算机和大小端这个词挂钩的最早问题

（3）现在我们讲的这个大小端模式，更多的是指计算机存储系统的大小端。在计算机内存/硬盘/Nnad中，因为我们的存储系统是32位的，但是数据任然是以字节为单位的于是乎一个32位的二进制在内存中存储时有2种分布方式：高字节对应高地址（小端模式）、高字节对应低地址（大端模式）

（4）大端模式和小端模式本身没有对错，没有优劣，理论上按照大端或小端都可以，但是要求必须存储时和读取时按照同样的大小端模式来进行，否则会出错。

（5）现实的情况就是：有些CPU公司用大端（譬如C51单片机）；有些CPU用小端（譬如ARM）。（大部分是用小端模式，大端模式的不算多）。于是乎我们写代码时，当不知道当前环境是用大端模式还是小端模式时就需要用代码来检测当前系统的大小端。

经典笔试题：用C语言写一个函数来测试当前机器的大小端模式。

### 5.10.2、用union来测试机器的大小端模式

```c
#include<stdio.h>

union myunion
{
    int a;
    char b;
};
//如果是小端模式返回1，大端模式返回0
//共用体最重要的一点：定义的变量都是从低地址开始的
int is_little_endain(void)
{
    union myunion u1;
    u1.a = 1;//地址0的那个字节内是1（小端）还是0（大端）
    return u1.b;
}

int main(void)
{
    int i = is_little_endain();
    if(i == 0)
    {
        printf("是大端模式\n");
    }
    else if(i == 1)
    {
        printf("是小端模式\n");
    }
}
```

### 5.10.3、用指针的方式去测试机器的大小端模式

```c
#include<stdio.h>

int is_little_endian(void)
{
    int a = 1;
    char b = *((char *)&a);//指针方式访问本质上还是共用体的方式
    return b;
}

int main(void)
{
    int i = is_little_endain();
    if(i == 0)
    {
        printf("是大端模式\n");
    }
    else if(i == 1)
    {
        printf("是小端模式\n");
    }
}
```

### 5.10.4、看似可行实则不行的测试大小端方式：位与、移位、强制类型转换

（1）位与运算。
结论：位与的方式无法测试机器的大小端模式。（表现就是大端机器和小端机器的&运算后的值相同的）
理论分析：位与运算是编译器提供的运算，这个运算是高于内存层次的（或者说&运算在二进制层次具有可移植性，也就是说&的时候一定是高字节&高字节，低字节&低字节，和二进制存储无关）。

（2）移位
结论：移位的方式也不能测试机器大小端。
理论分析：原因和&运算符不能测试一样，因为C语言对运算符的级别是高于二进制层次的。右移运算永远是将低字节移除，而和二进制存储时这个低字节在高位还是低位无关的。

（3）强制类型转换
同上

### 5.10.5、通信系统中的大小端（数组的大小端）

（1）譬如要通过串口发送一个0x12345678给接收方，但是因为串口本身限制，只能以字节为单位来发送，所以需要发4次；接收方分4次接收，内容分别是：0x12、0x34、0x56、0x78.接收方接收到这4个字节之后需要去重组得到0x12345678（而不是得到0x78563412）。

（2）所以在通信双方需要有一个默契，就是：先发/先接的是高位还是低位？这就是通信中的大小端问题。

（3）一般来说是：先发低字节叫小端；先发高字节就叫大端。（我不能确定）实际操作中，在通信协议里面会去定义大小端，明确告诉你先发的是低字节还是高字节。

（4）在通信协议中，大小端是非常重要的，大家使用别人定义的通信协议还是自己要去定义通信协议，一定都要注意标明通信协议中大小端的问题。

****

## 5.11、枚举

### 5.11.1、枚举的作用

（1）枚举在C语言中其实是一些符号常量集。直白点说：枚举定义了一些符号，这些符号的本质就是int类型的常量，每个符号和一个常量绑定。这个符号就表示一个自定义的一个识别码，编译器对枚举的认知就是符号常量所绑定的那个int类型的数字。

（2）枚举中的枚举值都是常量，怎么验证？用%d打印出来的数字

（3）枚举符号常量和其对应的常量数字相对来说，数字不重要，符号才重要。符号对应的数字只要彼此不相同即可，没有别的要求。所以一般情况下我们都不明确指定这个符号所对应的数字，而让编译器自动分配。（编译器自动分配的原则是：从0开始依次增加。如果用户自己定义了一个值，则从那个值开始往后依次增加）

```c
#include<stdio.h>
//这个枚举用来表示函数的返回值，ERROR表示错，RIGHT表示对
enum return_value
{
  	ERROR,
    RIGHT,
};

enum return_value func1(void);

int main(void)
{
    enum return_value r = func1();
    if(r == RIGHT)//枚举是直接使用的和共用体是不一样的不需要r.RIGHT
    {
        printf("RIGHT\n");
    }
    else if(r == ERROR)
    {
        printf("ERROR\n");
    }
}

enum return_value func1(void)
{
    enum return_value r1;
    r1 = ERROE;
    return r1;
}
```

### 5.11.2、C语言为何需要枚举

（1）C语言没有枚举是可以的。使用枚举其实就是对1、0这些数字进行符号化编码，这样的好处就是编程时可以不用看数字而直接看符号。符号的意义是显然的，一眼可以看出。而数字所代表的含义除非看文档或者注释。

（2）宏定义的目的和意义是：不用数字而用符号。从这里可以看出：宏定义和枚举有内在联系。宏定义和枚举经常用来解决类似的问题，他们俩基本相当可以互换，但是有一些细微差别。

### 5.11.3、宏定义和枚举区别

（1）枚举是将多个有关联的符号封装在一个枚举中，而宏定义是完全散的。也就是说枚举其实是多选一。

（2）什么情况下用枚举？当我们要定义的常量是一个有限集合时（譬如一星期有7天，譬如一个月有31天，譬如一年有12个月····），最适合用枚举。（其实宏定义也行，但是枚举更好）

（3）不能用枚举的情况下（定义的常量符号之间无关联，或者无限的）用宏定义。

总结：宏定义先出现，用来解决符号常量的问题；后来人们发现有时候定义的符号常量彼此之间有关联（多选一的关系），用宏定义来做虽然可以但是不贴切，于是乎发明了枚举来解决这种情况。

### 5.11.4、枚举的定义和使用

 				参考发的代码

*****

# 6、C语言宏定义与预处理、函数和函数库

## 6.1、C语言预处理理论

### 6.1.1、由源码到可执行程序的过程

（1）源码.c–>（编译）–>elf可执行程序（最简单的顺序）

（2）源码.c–>（编译）–>目标文件.o–>（链接）–>elf可执行程序

（3）源码.c–>（预处理）–>预处理过的.i(c)源文件–>（编译）–>汇编文件.s–>（汇编）–>目标文件.o–>（链接）–>elf可执行程序（相较完整的顺序）

预处理用的是预处理器，编译用的是编译器，汇编用的是汇编器，链接用的是链接器，这几个工具再加上其他会用到的可用工具，合起来就叫做编译工具链。gcc就是一个编译工具链

### 6.1.2、预处理的意义

（1）编译器本身主要目的是编译源代码，将c的源代码转换成.s的汇编代码，编译器聚焦核心功能后，就剥离出了一些非核心的功能到预处理去了

（2）预处理器帮编译器做一些编译前的杂事。

### 6.1.3、gcc中只预处理不编译的方法

（1）gcc在编译时可以给一些参数来做一些设置，列如gcc xx.c -o xx可以指定可执行程序的名称；例如gcc xx.c -c -o xx.o可以指定只编译不链接，也可以生成.o的目标文件。

（2）gcc -E xx.c -o xx.i  可以实现只预处理不编译，一般情况下没必要只预处理不编译，但是有时候这种技巧可以用来帮助我们研究预处理过程，帮助我们debug程序

总结：宏定义被预处理时的现象：第一，宏定义语句本身不见了（可见我们编译器根本不认识宏定义）；第二，typedef重命名语句还在，说明它和宏定义是有本质区别的，说明它是由编译器处理的而不是由预处理来处理的

****

## 6.2、C语言预处理代码实战

### 6.2.1、头文件包含

（1）#include<>和#include””的区别：<>专门用来包含系统提供的头文件（就是系统自带的，不是程序员自己写的）；“ ”用来包含自己写的头文件。；更深层次来说：<>的话C语言编译器只会到系统指定的目录（编译器中配置的，例如说在我们Ubuntu中就在/usr/includ目录，我们编译器还运行用 -I来附加指定其他的包含路径）去寻找头文件（隐含意思就是不会到当前目录下寻找），如果找不到就会提示找不到这个头文件

（2）” “包含的头文件，编译器会默认现在当前目录下寻找相应头文件，如果没找到然后再到系统指定目录去寻找，如果还没知道就会报错

总结+注意：规则虽然允许用双引号来包含系统目录，但是一般的原则是：如果是系统指定的自带的用<>，如果是自己写的在当前目录下的就用“”，如果是自己写的但是集中放在一个专门存放头文件的目录将来在编译器中用-I参数来寻找，这种情况下也用尖括号。

（3）头文件包含的真实含义就是：在#include<xxx.h> 的那一行，将xx.h这个头文件的内容原地展开替换这一行的#include语句，过程在预处理中进行

### 6.2.2、注释

（1）注释是给人看的，不是给编译器看的

（2）编译器是不看注释的，实际上在预处理阶段，预处理器就会拿掉程序中所有的注释语句，到了编译器编译阶段程序中其实已经没有注释了

### 6.2.3、条件编译

（1）有时候我们希望程序有多种配置，在我们源代码编写时写好各种配置的代码，然后给这个配置开关，在源代码级别去修改配置开关来让程序编译出不同的效果。

```c
#include<stdio.h>

#define NUM

int main(void)
{
    int a;
    #ifdef NUM//如果前面有定义NUM这个符号，就成立
    a = 111;
    
    #else//如果前面没有就进入这块，执行下面语句
    a = 222;
    
    #endif
    printf("a = %d\n", a);//结果是111 ，上面确实在全局定义了NUM
}
```

（2）条件编译中用的两种判定方法分别是#ifdef和#if 

区别：

​	#ifdef xxx 判定条件成立与否主要看xxx这个符号在本语句之前有没有被定义，只要定义了这个符号（我们可以直接#define xxx 或者#define xxx 12或者#define xxx yyy 都是可以的）就是成立的。

​	#if（条件表达式），它的判定标准是（）中的表达式是true还是error，有点类似于C语言中的if语句，但是它属于预处理不属于我们正式的语句

```c
#include<stdio.h>

#define NUM 0

int main(void)
{
    int a;
    #ifd (NUM == 0)//#if 里面的是表达式
    a = 111;
    
    #else
    a = 222;
    
    #endif
    printf("a = %d\n", a);
}
```

****

## 6.3、宏定义

### 6.3.1、宏定义的规则和使用解析

（1）宏定义的解析规则就是：在预处理阶段由预处理器进行替换，这个替换是原封不动的替换。

（2）宏定义替换会递归进行，知道替换出来的值本身不再是个宏

（3）一个正确的宏定义的式子本身包含三个部分：第一部分是#dedine ，第二部分是宏名 ，剩下的所有为第三部分。

（4）宏可以带参数称为带参宏。带参宏的使用和带参函数有点像，但是在使用上有一些差异。在定义带参宏时，每一个参数在宏体中引用时都必须加括号，最后再整体加括号，括号缺一不可

### 6.3.2、宏定义实列1：MAX宏（求两个数中最大的）

```c
#include<stido.h>

#define MAX(a, b) (((a) > (b)) ? (a) : (b))

int main(void)
{
    int a = 3;
    int b = 4;
    int max = MAX(a, b);
    printf("max = %d\n", max);
}
```

关键：第一点，要想到用三目运算符完成

​		   第二点，注意括号的使用

### 6.3.3、宏定义实列2：SEC_PER_YEAR，用宏定义来表示一年有多少秒

```c
#include<stdio.h>

#define SEC_PER_YEAR (365*24*60*60)//错误的默认的超过了int类型的存储

#define SEC_PER_YEAR (365*24*60*60UL)//将类型转换为无符号型
```

关键：第一点，当一个数字直接出现在程序中时，它默认是int型的；

​		   第二点，一年有多少秒这个数字刚好超过了int类型存储的范围

### 6.3.4、带参宏和带参函数的区别（宏定义的缺陷）

（1）宏定义是在预处理期间处理的，而函数是在编译期间处理的。这个区别带来的实质差异是：宏定义最终是在调用宏的地方把宏体原地展开，而函数是在调用函数处跳转到函数中去执行，执行完后再跳转回来。

​	注：宏定义和函数的最大差别就是：宏定义是原地展开，因此没有调用开销；而函数是跳转执行再返回，因此函数有比较大的调用开销。所以宏定义和函数相比，优势就是没有调用开销，没有传参开销，所以当函数体很短（尤其是只有一句话时）可以用宏定义来替代，这样效率高。

（2）带参宏和带参函数的一个重要差别就是：宏定义不会检查参数的类型，返回值也不会附带类型；而函数有明确的参数类型和返回值类型。当我们调用函数时编译器会帮我们做参数的静态类型检查，如果编译器发现我们实际传参和参数声明不同时会报警告或错误。

​	注：用函数的时候程序员不太用操心类型不匹配因为编译器会检查，如果不匹配编译器会叫；用宏的时候程序员必须很注意实际传参和宏所希望的参数类型一致，否则可能编译不报错但是运行有误。

​	总结：宏和函数各有千秋，各有优劣。总的来说，如果代码比较多用函数适合而且不影响效率；但是对于那些只有一两句话的函数开销就太大了，适合用带参宏。但是用带参宏又有缺点：不检查参数类型。 

### 6.3.5、内联函数和inline关键字

（1）内联函数通过在函数定义前加inline关键字实现。

（2）内联函数本质上是函数，所以有函数的优点（内联函数是编译器负责处理的，编译器可以帮我们做参数的静态类型检查））；但是同时他也有带参宏的优点（不用调用开销，而是原地展开），实际上是函数和带参宏的结合，内联函数就是带来参数静态类型检查的宏

（3）当我们的函数体很短（列如只有一两句话）的时候，我又希望利用编译器的参数类型检查来排错，我还希望没有调用开销，最适合用内联函数。

### 6.3.6、宏定义来实现编译（#define  #undef #ifdef）

```c
#include<stdio.h>

#define DEBUG
//意思是如果我上面定义了DEBUG 那么我debug(x)定义为printf(x)否则为空
#undef DEBUG//如果上面有定义DEBUG就把定义的DEBUG注销掉

#ifdef DEBUG
#define debug(x) printf(x)
#else
#define debug(x)
#endif

```

（1）程序有DEBUG版本和RELEASE版本，区别就是编译时有无定义DEBUG宏。

****

## 6.4、函数的本质、

### 6.4.1、C语言为什么有函数

（1）整个程序分成多个源文件，一个文件分成多个函数，一个函数分成多个语句，这就构成了整个程序的组织形式，这样组织的好处在于，分化问题、便于编程、便于分工。

（2）函数出现是人（程序员和架构师）的需要，而不是机器（编译器、CPU）的需要。

（3）函数的目的就是为了实现模块化编程，说白了就是为了提供程序的可移植性。

### 6.4.2、函数书写的一般原则

第一：遵循一定格式。函数的返回类型、函数名、参数列表等。

第二：一个函数只做一件事，函数不能太长也不宜太短，原则是一个函数只做一件事。

第三：传参不宜太多：特别是在ARM体系下，传参不宜超过4个。如果传参确实需要太多则考虑结构体打包

第四：尽量少碰全局变量：函数最好用传参返回值和外部交换数据，不要用全局变量。

### 6.4.3、函数是动词、变量是名词（面对对象中分别叫方法和成员变量）

（1）函数将来被编译成可执行代码段、变量（主要指全局变量）经过编译后变成了数据或者说在运行时变成了数据，一个程序的运行需要代码和数据两方面的结合才能完成。

（2）代码和数据需要彼此配合的，代码是为了加工数据，数据必须借助代码来起作用。名词性的数据必须经过动词性的加工才能变成最终我们需要的产出的数据。这个加工的过程就是程序的加工过程。

### 6.4.4、函数的实质是：数据处理器

（1）程序的主体是数据，也就是说程序的运行的主要目标是生成目标数据，我们写代码也是为了目标数据。我们如何得到目标数据必须有两个因素：原材料+加工算法。原材料就是程序的输入数据，加工算法就是程序

（2）程序的编写和运行就是为了把原数据加工成目标数据，所以程序的实质就是一个数据处理器。

（3）函数就是程序的一个缩影，函数的参数列表其实就是为了给函数输入原材料数据，函数的返回值和输出型函数就是为了向外部输出目标数据，函数的函数体里的那些代码就是加工算法

（4）函数在静止没有执行的时候就像一台没有开动的机器，此时只占用一些存储空间但是并不占用资源（CPU+内存）；程序的每一次运行都好像机器的每一次开机，运行时需要耗费资源（CPU+内存）运行时可以对数据加工生成目标数据，函数运行完毕会释放占用的资源

（5）整个程序的运行其实就是很多函数相继运行的连续过程。

***

## 6.5、函数的基本使用

### 6.5.1、函数三要素：定义、声明、调用

（1）函数的定义就是函数体、函数声明就是函数原型、函数调用就是使用函数

（2）函数定义是函数的根本，函数定义中的函数名表示了这个函数在内存中的首地址，所以可以用函数名来调用执行这个函数（实质是指针解引用访问）；函数定义中的函数体是函数的执行关键，函数将来执行时主要就是执行函数体。所以一个函数没有定义就是无基之塔。

（3）函数声明的主要作用是告诉编译器函数的原型

（4）函数调用就是调用执行一个函数。

### 6.5.2、函数原型和作用

（1）函数原型就是函数的声明，说白了就是函数的函数名、返回值类型、参数列表。

（2）函数原型的主要作用就是给编译器提供原型，让编译器在编译程序时帮我们进行参数的静态类型检查

（3）必须明白：编译器在编译程序时是以单个源文件为单位的（所以一定要在哪里调用在哪里声明），而且编译器工作时已经经过预处理处理了，最最重要的是编译器编译文件时是按照文件中语句的先后顺序执行的。

（4）编译器从源文件的第一行开始编译，遇到函数声明时就会收到编译器的函数声明表中，然后继续向后。当遇到一个函数调用时，就在我的本文件的函数声明表中去查这个函数，看有没有原型相对应的一个函数（这个相对应的函数有且只能有一个）。如果没有或者只有部分匹配则会报错或报警告；如果发现多个则会报错或报警告（函数重复了，C语言中不允许2个函数原型完全一样，这个过程其实是在编译器遇到函数定义时完成的。所以函数可以重复声明但是不能重复定义）

****

## 6.6、递归函数

### 6.6.1、什么是递归函数

（1）递归函数就是函数中调用了自己本身的函数。

（2）递归函数和循环的区别：递归不等于循环

（3）递归函数解决问题的典型就是：求阶乘，求斐波那契数列

```c
//用递归函数计算阶乘
#include<stdio.h>

int jiecheng(int n);

int main(void)
{
    int a = 0,sum;
    scanf("%d",&a);
    sum = jiecheng(a);
  	printf("%d\n",sum);  
}

int jiecheng(int n)
{
    if(n < 1)
    {
        printf("error\n");
        return -1; //传参错误校验
    }
    else if(n == 1)//！！！！等于是双等号！！！！
    {
        return 0;
    }
    else if(n > 1)
    {
        return (n * jiecheng(n - 1));
    }
}
```

### 6.6.2、函数的递归调用原理

```c
#include<stdio.h>

int main(void)
{
    digui(3);
}

void digui(int n)
{
    printf("递归前：n = %d\n",n);
    if(n > 1)
    {
        digui(n - 1);
    }
    else
    {
        printf("结束递归：n = %d\n",n);
    }
    printf("递归后：n = %d\n",n);
}
/*
*结果是：
*递归前：n = 3
*递归前：n = 2
*递归前：n = 1
*结束递归：n =1
*递归后：n = 1
*递归后：n = 2
*递归后：n = 3
*/
```

（1）实际上递归函数是在栈内存上递归执行的，每次递归执行一次就需要耗费一些栈内存。

（2）我们栈内存的大小是限制了递归深度的重要因素。

### 6.6.3、使用递归函数的原则：收敛性、栈溢出

（1）收敛性就是说：递归函数必须有终止递归的条件，每次这个函数被执行时，我们判断一个决定是否继续执行递归，这个条件最终必须能够被满足。如果没有递归终止条件或者这个条件永远不能被满足，则这个递归没有收敛性，这个递归最终要失败.

（2）因为递归是占用栈内存的，每一次递归调用都会消耗一些栈内存，因此必须在栈溢出之前递归收敛（终止），否则就会栈溢出。

（3）递归函数的使用是有一定的风险的，必须把握好。

****

## 6.7、函数库

### 6.7.1、什么是函数库

（1）函数库就是事先写好的函数的集合，给别人复用

（2）函数是模块化的，因此可以被复用，我们写好了一个函数可以被反复使用。

### 6.7.2、函数库的由来

（1）最开始是没有函数库的，每个人写程序都是要从零开始自己写的，时间长了慢慢的早期的程序员就积累下来一些有用的函数.

（2）早期的程序员经常参加行业聚会，在聚会上大家互相交换各自的函数库。

（3）后来程序员中的一些大神就提出把大家各自的函数库收拢在一起，然后经过校准和整理，最后形成了一份标准化的函数库，就是现在的标准的函数库，譬如说glibc。

### 6.7.3、函数库的提供形式：动态链接库与静态链接库

（1）早期的函数的共享都是以源代码的形式进行的，这种方式的共享是最彻底的（后来这种源码共享的方向就是形成我们现在的开源社区）。但是这种方式有他的缺点，缺点就是无法以商业化形式发布函数库。

（2）商业公司需要将自己的有用的函数库共享给被人（当然是付费的），但是又不能给客户源代码。这时候的解决方案就是以库（主要有2种：静态库和动态库）的形式来提供。

（3）比较早出现的是静态链接库。静态库其实就是商业公司将自己的函数库源代码经过只编译不连接形成.o的目标文件，然后用ar工具将.o文件归档成.a的归档文件（.a的归档文件又叫静态链接库文件）。商业公司通过发布.a库文件和.h头文件来提供静态库给客户使用；客户拿到.a和.h文件后，通过.h头文件得知库中的库函数的原型，然后在自己的.c文件中直接调用这些库文件，在连接的时候链接器会去.a文件中拿出被调用的那个函数的编译后的.o二进制代码段链接进去形成最终的可执行程序。

（4）动态链接库比静态链接库出现的晚一些，效率更高一些，是改进型的。现在我们一般都是使用动态库。静态库在用户链接自己的可执行程序时就已经把调用的库中的函数的代码段链接进最终可执行程序中了，这样好处是可以执行，坏处是太占地方了。尤其是有多个应用程序都使用了这个库函数时，实际上在多个应用程序最后生成的可执行程序中都各自有一份这个库函数的代码段。当这些应用程序同时在内存中运行时，实际上在内存中有多个这个库函数的代码段，这完全重复了。而动态链接库本身不将库函数的代码段链接入可执行程序，只是做个标记。然后当应用程序在内存中执行时，运行时环境发现它调用了一个动态库中的库函数时，会去加载这个动态库到内存中，然后以后不管有多少个应用程序去调用这个库中的函数都会跳转到第一次加载的地方去执行（不会重复加载）。

### 6.7.4、函数库中库函数的使用

（1）gcc中编译链接程序默认是使用动态链接库的，要想使用静态链接需要在gcc时后面就上-static 来强制静态链接。

（2）库函数的使用需要注意3点：第一，包含相应的头文件；第二，调用库函数时注意函数原型；第三，有些库函数链接时需要额外用-lxxx来指定链接；第四，如果是动态库，要注意-L指定动态库的地址。

***

## 6.8、字符串函数

### 6.8.1、什么是字符串

（1）字符串就是由多个字符在内存中连续分布组成的字符结构。字符串的特点是指定了开头（字符串的指针）和结尾（结尾固定为字符'\0'），而没有指定长度（长度由开头地址和结尾地址相减得到）

### 6.8.2、为什么要讲字符串处理函数

（1）函数库为什么要包含字符串处理函数？因为字符串处理的需求是客观的，所以从很早开始人们就在写很多关于字符串处理的函数，然后逐渐形成了现在的字符串处理函数库。

（2）面试笔试时，常用字符串处理函数也是经常考到的点。

### 6.8.3、常用字符串处理函数

（1）C库中字符串处理函数包含在string.h中，这个文件在ubuntu系统中在/usr/include中

（2）常见字符串处理函数及作用：

memcpy		确定src和dst不会overlap，则使用memcpy效率高
memmove	 确定会overlap或者不确定但是有可能overlap，则使用memove比较						保险
memset
memcmp
memchr
strcpy
strncpy
strcat
strncat
strcmp
strncmp
strdup
strndup
strchrstrstr
strtok
·······（具体可以查看头文件或者man手册，也可以上菜鸟编程查看）

***

## 6.9、数学库

### 6.9.1、math.h.

（1）真正的数学运算的函数定义在：/usr/include/i386-linux-gnu/bits/mathcalls.h

（2）使用数学库函数的时候，只需要包含math.h即可。

### 6.9.2、计算平方根

（1）库函数：double sqrt(double x)；

```c
#include<stdio.h>
#include<math.h>

int main(void)
{
    double a = 16.0;
    double b = sqrt(a);
    printf("b = %lf\n",b);
}
```

注意区分编译时的错误和链接时的错误：

编译时的错误报告是：4.6.10.math.c:9:13: warning: incompatible implicit declaration of built-in function ‘sqrt’ [enabled by default]
  double b = sqrt(a);

链接时的错误报告：4.6.10.math.c:(.text+0x1b): undefined reference to `sqrt'
collect2: error: ld returned 1 exit status

​	分析；这个链接错误的意思是：sqrt函数有声明（声明就在math.h中）有引用（在math.c）但是没有定义，链接器找不到函数体。sqrt本来是库函数，在编译器库中是有.a和.so链接库的（函数体在链接库中的）。

​	C链接器的工作特点：因为库函数有很多，链接器去库函数目录搜索的时间比较久。为了提升速度想了一个折中的方案：链接器只是默认的寻找几个最常用的库，==如果是一些不常用的库中的函数被调用，需要程序员在链接时明确给出要扩展查找的库的名字==。链接时可以用-lxxx来指示链接器去到libxxx.so中去查找这个函数。

### 6.9.3、链接数学库时加 -lm

（1）-lm就是告诉链接器到libm中去查找用到的函数。

（2）实战中发现在高版本的gcc中，经常会出现每加-lm也可以编译链接的。

ldd + 可执行文件名 可查找这个文件链接的文件所在位置

***

## 6.10、自己制作静态链接库并使用

（1）第一步：自己制作静态链接库

​	首先使用gcc -c只编译不连接，生成.o文件；然后使用ar工具进行打包成.a归档文件库名不能随便乱起，一般是lib+库名称，后缀名是.a表示是一个归档文件：

```makefile
all:
	gcc enosji.c -o enosji.o -c
	ar -rc libenosji.a enosji.o 
```

==注意==：制作出来了静态库之后，发布时需要发布.a文件和.h文件。

（2）第二步：使用静态链接库

​	把.a和.h都放在我引用的文件夹下，然后在.c文件中包含库的.h，然后直接使用库函数。

第一次，编译方法：gcc test.c -o test
报错信息：test.c:(.text+0xa): undefined reference to `func1'
		  test.c:(.text+0x1e): undefined reference to `func2' //说明没有链接到函数库
第二次，编译方法：gcc test.c -o test -lenosji // 后面加 l 和链接库的名字
报错信息：/usr/bin/ld: cannot find -laston
					collect2: error: ld returned 1 exit status //链接器没有找到链接库，得告诉他在当前路径下找 后面加 -L. 告诉链接器在-L后面加得路径下寻找
第三次，编译方法：gcc test.c -o test -laston -L.
无报错，生成test，执行正确。

（3）除了ar名另外，还有个nm命令也很有用，它可以用来查看一个.a文件中都有哪些符号

****

## 6.11、自己制作动态链接库

（1）动态链接库的后缀名是.so（对应windows系统中的dll），静态库的扩展名是.a

（2）第一步：创建一个动态链接库。

```makefile
all:
	gcc enosji.c -o enosji.o -c -fPIC //第一步只编译不链接
	gcc -o  libenosji.so enosji.o -shared
```


​		-fPIC是位置无关码，-shared是按照共享库的方式来链接。
注意：做库的人给用库的人发布库时，发布libxxx.so和xxx.h即可。

（3）第二步：使用自己创建的共享库。
第一步，编译方法：gcc test.c -o test
报错信息：test.c:(.text+0xa): undefined reference to `func1'
test.c:(.text+0x1e): undefined reference to `func2'
collect2: error: ld returned 1 exit status

第二步，编译方法：gcc test.c -o test -laston
报错信息：/usr/bin/ld: cannot find -laston
collect2: error: ld returned 1 exit status

第三步，编译方法：gcc test.c -o test -laston -L.
编译成功

但是运行出错，报错信息：
error while loading shared libraries: libaston.so: cannot open shared object file: No such file or directory

错误原因：动态链接库运行时需要被加载（运行时环境在执行test程序的时候发现他动态链接了libaston.so，于是乎会去固定目录尝试加载libaston.so，如果加载失败则会打印以上错误信息。）

解决方法一：
将libaston.so放到固定目录下就可以了，这个固定目录一般是/usr/lib目录。
cp libaston.so /usr/lib即可

解决方法二：使用环境变量LD_LIBRARY_PATH。操作系统在加载固定目录/usr/lib之前，会先去LD_LIBRARY_PATH这个环境变量所指定的目录下去寻找，如果找到就不用去/usr/lib下面找了，如果没找到再去/usr/lib下面找。所以解决方案就是将libaston.so所在的目录导出到环境变量LD_LIBRARY_PATH中即可：
`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:当前目录路径`

在ubuntu中还有个解决方案三，用ldconfig

(4)ldd命令：作用是可以在一个使用了共享库的程序执行之前解析出这个程序使用了哪些共享库，并且查看这些共享库是否能被找到，能被解析（决定这个程序是否能正确执行）。

****

# 7、存储类&作用域&生命周期&链接属性

## 7.1、概念解析

### 7.1.1、存储类

（1）存储类就是存储类型，也就是描述C语言变量在何种地方存储。

（2）内存有多种管理方法：栈、堆、数据段、bss段、.text段……一个变量得存储类属性就是描述变量存储在何种内存段中

（3）譬如：局部变量分配在栈上，所以它的存储类就是栈；显式初始化为非0的全局变量分配在数据段，显式初始化为0和没有显示初始化（默认为0）的全局变量分配在bss段。

### 7.1.2、作用域

（1）作用域是描述这个变量起作用的代码范围。

（2）基本来说，C语言变量的作用域规则是代码块作用域。意思就是这个变量起作用的范围是当前的代码块。代码块就是一对大括号{}括起来的范围，所以一个变量的作用域是：这个变量定义所在的{}范围内从这个变量定义开始往后的部分。(这就解释了为什么变量定义总是在一个函数的最前面)

### 7.1.3、生命周期

（1）声明周期是描述这个变量什么时候诞生（运行时分配内存空间给这个变量）及什么时候死亡（运行时收回这个内存空间，此后再不能访问这个内存地址，或者访问这个内存地址已经和这个变量无关了）的。

（2）变量和内存的关系，就和人（变量）去图书馆借书（内存）一样。变量的生命周期就好象我人借书的这段周期一样。

（3）研究变量的生命周期可以我们理解程序运行的一些现象、理解C语言的一些规则。

### 7.1.4、链接属性

（1）大家知道程序从源代码到最终可执行程序，经历的过程：编译、链接。

（2）编译阶段就是把源代码搞成.o目标文件，目标文件里面有很多符号和代码段、数据段、bss段等分段。符号就是编程中的变量名、函数名等。运行时变量名、函数名能够和相应的内存对应起来，靠符号来做链接的。

（3）.o的目标文件链接生成最终可执行程序的时候，其实就是把符号和相对应的段给链接起来。
C语言中的符号有三种链接属性：外连接属性、内链接属性、无连接属性。

总结：以上4个概念，其实就是从4个不同角度来分析C语言的一些运行规则。综合这4种分析角度能够让程序员完全掌握C语言程序的运行规则和方法。

****

## 7.2、Linux下C语言得内存映射

![](E:\Linux教程\华清远见\QQ图片20210412181508.png)

### 7.2.1、代码段、只读数据段

（1）对应着程序中的代码（函数），代码段在linux中又叫文本段(.text)

（2）只读数据段就是在程序运行期间只能读不能写的数据，const修饰的常量有可能是存在只读数据段的（但是不一定，const常量的实现方法在不同平台是不一样的）

### 7.2.2、数据段、bss段

（1）数据段存：1、显式初始化为非0的全局变量；2、显式初始化为非0的static局部变量

（2）bss段存：1、显式初始化为0或者未显式初始化的全局变量；2、显式初始化为0或未显式初始化的static局部变量。

### 7.2.3、堆

（1）C语言中什么样变量存在堆内存中？C语言不会自动向堆中存放东西，堆的操作是程序员自己手工操作的。程序员根据需求自己判断要不要使用堆内存，用的时候自己申请，自己使用，完了自己释放。

### 7.2.4、文件映射区

（1）文件映射区就是进程打开了文件后，将这个文件的内容从硬盘读到进程的文件映射区，以后就直接在内存中操作这个文件，读写完了后在保存时再将内存中的文件写到硬盘中去。

### 7.2.5、栈

（1）栈内存区，局部变量分配在栈上；函数调用传参过程也会用到栈

### 7.2.6、内核映射区

（1）内核映射区就是将操作系统内核程序映射到这个区域了。

（2）对于linux中的每一个进程来说，它都以为整个系统中只有它自己和内核而已。它认为内存地址0xC0000000以下都是它自己的活动空间，0xC0000000以上是OS（操作系统）内核的活动空间。

（3）每一个进程都活在自己独立的进程空间中，0-3G的空间每一个进程是不同的（因为用了虚拟地址技术），但是内核是唯一的。

### 7.2.7、OS（操作系统）下和裸机下C程序加载执行的差异

（1）C语言程序运行时环境有一定要求，意思是单独个人写的C语言程序没法直接在内存中运行，需要外部一定的协助，这段协助的代码叫加载运行代码（或者叫构建C运行时环境的代码，这一段代码在操作系统下是别人写好的，会自动添加到我们写的程序上，这段代码的主要作用是：给全局变量赋值、清bss段）。

（2）ARM裸机第十六部分，写shell时有一次定义了一个全局变量初始化为0但是实际不为0，后来在裸机的start.S中加了清bss段代码就变0了。这就说明在裸机程序中没人帮我们来做这一段加载运行时代码，要程序员自己做（start.S中的重定位和清bss段就是在做这个事）；在操作系统中运行程序时程序员自己不用操心，会自动完成重定位和清bss，所以我们看到的现象：C语言中未初始化的全局变量默认为0·····。

（3）数据段的全局变量或静态局部变量都是有非0的初值的，这些初值在main函数运行之前就已经被初始化了，是重定位期间完成的初始化。

****

## 7.3、存储类相关的关键字

### 7.3.1、auto

（1）auto关键字在C语言中只有一个作用，那就是修饰局部变量。

（2）auto修饰局部变量，表示这个局部变量是自动局部变量，自动局部变量分配在栈上。（既然在栈上，说明它如果不初始化那么值就是随机的······）

（3）平时定义局部变量时就是定义的auto的，只是省略了auto关键字而已。可见，auto的局部变量其实就是默认定义的普通的局部变量。

### 7.3.2、static

（1）static关键字在C语言中有2种用法，而且这两种用法彼此没有任何关联、完全是独立的。其实当年本应该多发明一个关键字，但是C语言的作者觉得关键字太多不好，于是给static增加了一种用法，导致static一个关键字竟然有两种截然不同的含义。

（2）static的第一种用法是：用来修饰局部变量，形成静态局部变量。要搞清楚静态局部变量和非静态局部变量的区别。本质区别是存储类不同（存储类不同就衍生出很多不同）：非静态局部变量分配在栈上，而静态局部变量分配在数据段/bss段上。

（3）static的第二种用法是：用来修饰全局变量，形成静态全局变量。要搞清楚静态全局变量和非静态全局变量的区别。区别是在链接属性上不同，讲到链接属性时详细讲。
分析：
	1、静态局部变量在存储类方面和全局变量一样。
	2、静态局部变量在生命周期方面和全局变量一样。
	3、静态局部变量和全局变量的区别是：作用域、连接属性。静态局部变量作用域是代码块作用域（和普通局部变量是一样的）、链接属性是无连接；全局变量作用域是文件作用域（和函数是一样的）、链接属性方面是外连接。

### 7.3.3、register

（1）register关键字不常用，也只有一个作用，那就是：register修饰的变量。编译器会尽量将它分配在寄存器中。（平时分配的一般的变量都是在内存中的）。分配在寄存器中一样的用，但是读写效率会高很多。所以register修饰的变量用在那种变量被反复高频率的使用，通过改善这个变量的访问效率可以极大的提升程序运行效率时。所以register是一种极致提升程序运行效率的手段。

（2）uboot中用到了一个register类型的变量，gd这个变量是用来存uboot的全局变量（gd就是global data）。因为这个全局变量在整个uboot中到处都被访问，所以定义成register的。

（3）平时写代码要被定义成register这种情况很少，一般慎用。

（4）register编译器只能承诺尽量将register修饰的变量放在寄存器中，但是不保证一定放在寄存器中。主要原因是因为寄存器数量有限，不一定有空用。

### 7.3.4、extern

（1）extern主要用来声明全局变量，声明的目的主要是在a.c中定义全局变量而在b.c中使用该变量。

（2）C语言中程序的编译时以单个.c源文件为单位的，因此编译a.c时只考虑a.c中的内容（不会考了b.c的内容），这就导致a.c中使用了b.c中定义的变量时在编译时报错。解决方案是声明

（3）应该在a.c中使用g_b之前先声明g_b，声明就是告诉a.c我在别的文件中定义了g_b，并且它的原型和声明的一样，将来在链接的时候链接器会在别的.o文件中找到这个同名变量。声明一个全局变量就要用到extern关键字

（4）定义全局变量的时候，我们是定义兼且声明的，定义本身就是声明，但是声明没有定义，这也就是为什么我们要将全局变量放在c文件头部而不放在其他地方的原因因为它还有声明的作用。 

### 7.3.5、volatile

（1）volatile的字面意思：可变的、易变的。C语言中volatile用来修饰一个变量，表示这个变量可以被编译器之外的东西改变。编译器之内的意思是变量的值的改变是代码的作用，编译器之外的改变就是这个改变不是代码造成的，或者不是当前代码造成的，编译器在编译当前代码时无法预知。譬如在中断处理程序isr中更改了这个变量的值，譬如多线程中在别的线程更改了这个变量的值，譬如硬件自动更改了这个变量的值（一般这个变量是一个寄存器的值）

（2）以上说的三种情况（中断isr中引用的变量，多线程中共用的变量，硬件会更改的变量）都是编译器在编译时无法预知的更改，此时应用使用volatile告诉编译器这个变量属于这种（可变的、易变的）情况。编译器在遇到volatile修饰的变量时就不会对改变量的访问进行优化，就不会出现错误。

```c
#include<stdio.h>

int main(void)
{
    volatile int a, b, c;
    a = 3;
    b = a;
    c = b;		//等效于 c = b = a = 3
    //无优化的情况下：内存读取三次，写3次
    //编译器优化为：内存只读取一次，写3次，直接将3赋值给三个变量
    //这时如果中间a的值被中断或者多线程修改了a的值但是编译器不知道还是将3     //赋值下去了，这时就出错了，程序员需要去分析a的值是否会被修改如果会就     //要在定义时加上volatile关键字,这样编译器在执行时就会放弃优化
    
}
```



（3）编译器的优化在一般情况下非常好，可以帮助提升程序效率。但是在特殊情况（volatile）下，变量会被编译器想象之外的力量所改变，此时如果编译器没有意识到而去优化则就会造成优化错误，优化错误就会带来执行时错误。而且这种错误很难被发现。

（4）volatile是程序员意识到需要volatile然后在定义变量时加上volatile，如果你遇到了应该加volatile的情况而没有加程序可能会被错误的优化。如果在不应该加volatile而加了的情况程序不会出错只是会降低效率。所以我们对于volatile的态度应该是：正确区分，该加的时候加不该加的时候不加，如果不能确定该不该加为了保险起见就加上。

### 7.3.6、restrict

（1）c99中才支持的，所以很多延续c89的编译器是不支持restrict关键字，gcc支持的。

（2）restrict也是和编译器行为特征有关的。

（3）restrict只用来修饰指针，不能修饰普通变量。概括的说：restrict关键字仅限于指针，是告诉编译器，所有修改该指针所指向的内容的操作都是基于（base on）该指针的，即不存在其他进行修改操作的途径，这样的好处就是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。

```c
int f(int *x, int *y)
{
    *x = 0;
    *y = 1;
    return *x;//虽然返回值*x 99%都是返回0，但是编译器害怕*x会被其他地方			//修改就不会将其优化为return 0；
    
}
//修改
int f(restrict int *x, int *y)
{
    *x = 0;
    *y = 1;
    return *x;//这是告诉编译器*x除了它自己之外没有被的途径再去修改其值让				//编译器放心修改为return 0
}
```



（4）参考文章http://blog.chinaunix.net/uid-22197900-id-359209.html

（5）memcpy和memmove的区别：void *memcpy( void * restrict dest ,const void * restrict src,sizi_t n) 这是一个很有用的内存复制函数，由于两个参数都加了restrict限定，所以两块区域不能重叠，即 dest指针所指的区域，不能让别的指针来修改，即src的指针不能修改. 相对应的别一个函数 memmove(void *dest,const void * src,size_t)则可以重叠。

### 7.3.7、typedef

（1）typedef在C语言关键字归类上属于存储类关键字，但是实际上和存储类没关系。

****

## 7.4、作用域详解

### 7.4.1、局部变量的代码块作用域

（1）代码块基本可以理解为一对大括号{}括起来的部分。（一般定义全局变量时变量名前面回加上g_）

（2）代码块不等于函数，因为if  while for都有{}。所以代码块<=函数

（3）局部变量的作用域是代码块作用域，也就是说一个局部变量可以被访问和使用的范围仅限于定义这个局部变量的代码块中定义式之后的部分。

### 7.4.2、函数名和全局变量的文件作用域

（1）文件作用域的意思就是全局的访问权限，也就是说整个.c文件中都可以访问这些东西。这就是平时所说的局部和全局，全局就是文件作用域。

（2）详细准确的说：函数和全局变量的作用域是定义所在的整个.c文件之内定义式之后的部分。

总结：
（1）不管是局部变量、全局变量、函数，都要先定义才能使用

（2）严格来说我们上面的总结是错误的。准确的说：全局变量/函数的作用域都是自己所在的文件，但是定义式之前的部分因为缺少声明所以没法用，解决方案是：1、把它定义到前面去；2、定义到后面但是在前面加声明；局部变量因为没法声明，所以只能定义在前面去。

（3）在c89标准的编译器中（现在很多编译器还延续使用c89标准），所有的局部变量必须先定义在最前面，在变量定义之前不能有一句执行代码。在c99标准的编译器中（gcc兼容c99标准）可以允许在代码块内任意地方定义变量。但是允许定义的变量还是只能使用在定义了之后，定义之前还是不能用的。

### 7.4.3、同名变量的掩蔽规则

（1）问题：编程时，不可避免会出现同名变量。变量同名后不一定会出错。

（2）首先，如果两个同名变量作用域不同且没有交叠，这种情况下同名没有任何影响。

（3）其次，如果两个同名变量作用域有交叠，C语言规定在作用域交叠范围内，作用域小的一个变量会掩蔽掉作用域大的那个（县官不如现管）。

****

## 7.5、变量的生命周期

### 7.5.1、研究变量生命周期的意义

（1）研究变量生命周期，有助于理解变量的行为特征。

### 7.5.2、栈变量生命周期

（1）局部变量（栈变量）存储在栈上，生命周期是临时的。临时的意思就是说：代码执行过程中按照需要去创建、使用、消亡的。

（2）譬如一个函数内定义的局部变量，在这个函数每一次被调用时都会创建一次，然后使用，最后在函数返回的时候消亡。

（3）思考：一个函数内的局部变量为什么在函数外不能使用？因为是定义在栈上的这个函数运行结束后它的生命周期也结束了。

（4）思考：局部变量为什么分配在栈上？或者说局部变量为什么是临时生命周期？因为我们需要局部变量是个临时的生命周期

### 7.5.3、堆变量的生命周期

（1）首先要明白：堆内存空间是客观存在的，是由操作系统维护的。我们程序只是去申请然后使用然后释放。

（2）我们只关心我们程序使用堆内存的这一段时间，因此堆变量也有了自己的生命周期，就是：从malloc申请时诞生，然后使用，直到free时消亡。

（3）所以堆内存在malloc之前和free之后不能再去访问，因此堆内存在实践编程时都是被反复的malloc和free的。

### 7.5.4、数据段、bss段的生命周期

（1）全局变量的生命周期是永久的。永久的意思就是在程序被执行时诞生，在程序终止时消亡。

（2）全局变量所占用的内存是不能被程序自己释放的，所以程序如果申请了过多的全局变量会导致这个程序一直占用大量内存。

（3）如果说堆内存是图书馆借的书，那么全局变量就是自己买的书。

### 7.5.5、代码段、只读段的生命周期

（1）其实就是程序执行的代码，其实就是函数，它的生命周期是永久的。不过一般代码的生命周期我们并不关注。

（2）有时候放在代码段的不只是代码，还有const类型的常量，还有字符串常量。（const类型的常量、字符串常量有时候放在rodata段，有时候放在代码段，取决于平台）

****

## 7.6、链接属性

### 7.6.1、C语言程序的组织架构：多个C文件+多个h文件

（1）庞大、完整的一个C语言程序（譬如linux内核、uboot）由多个c文件和多个h文件组成的。

（2）程序的生成过程就是：编译+链接。编译是为了将函数/变量等变成.o二进制的机器码格式，链接是为了将各个独立分开的二进制的函数链接起来形成一个整体的二进制可执行程序。

### 7.6.2、编译以文件为单位，链接以工程为单位

（1）编译器工作时是将所有源文件依次读进去的（文件彼此是独立的），单个为单位进行编译的，这也是为什么我们在不同的文件中调用用函数和变量的时候需要做声明的原因。

（2）链接的时候其实实际上是把第一步编译生成的多个单个.o文件整体输入，然后处理链接成一个可执行程序。链接的实质就是查找相对应的符号（变量和函数）将其对应起来

### 7.6.3、三种链接属性：外连接、内连接、无连接

（1）外连接的意思就是外部链接属性，也就是这家伙可以在整个程序范围内（言下之意就是可以跨文件引用）进行链接，列如普通的函数和全局变量就是属于外连接。

（2）内连接的意思就是（c文件内部）内部连接属性，也就是说这家伙可以在当前c文件内部范围内进行连接（言下之意就是它不能在当前文件范围外的其他c文件中进行访问、连接）。static修饰的函数和全局变量都属于内连接。

（3）无连接的意思就是这个符号本身不参与连接，它跟连接没关系。所有局部变量（auto的、static的）都是无连接的

### 7.6.4、函数和全局变量的同名冲突

（1）因为函数和全局变量是外部链接属性，就是说每一个函数和全局变量将来在整个程序中所有的c文件都能被访问，因此在一个程序中的所有c文件中不能出现同名的函数/同名的全局变量。

（2）最简单的解决方案就是起名字不要重复，但是很难做到。主要原因是一个很大的工程中函数和全局变量名字太多了，而且一个大工程不是一个人完成的，是很多人协作完成，所以很难保证不会重名。解决方案呢？

（3）现代高级语言中完美解决这个问题的方法是命名空间namespace（其实就是给一个变量带上各个级别的前缀）。但是C语言不是这么解决的。

（4）C语言比较早碰到这个问题，当时还没发明namespace概念，当时C语言就发明了一种不是很完美但是凑活能用的解决方案，就是三种链接属性的方法。

（5）C语言的链接属性解决重名问题思路是这样的：我们将明显不会在其他c文件中引用（只在当前c文件中引用）的函数/全局变量，使用static修饰使其成为内链接属性，这样在将来连接时即使2个c文件中有重名的函数/全局变量，只要其中一个或2个为内链接属性就没事。

（6）这种解决方案在一定程度上解决了问题。但是没有从根本上解决问题，留下了很多麻烦。所以这个就导致了C语言写很大型的项目难度很大。

### 7.6.5、static第二种用法：修饰全局变量和函数

（1）普通的（非静态）的函数/全局变量，默认的链接属性是外部的

（2）static（静态）的函数/全局变量，链接属性是内部链接。

### 7.6.6、一般用法的总结

思考：为什么static一个关键字可以有2种完全不同的意思？因为这两种用法是互斥的。

****

## 7.7、总结

（1）普通（自动）局部变量分配在栈上，作用域为代码块作用域，生命周期是临时，连接属性为无连接。定义时如果未显式初始化则其值随机，变量地址由运行时在栈上分配得到，多次执行时地址不一定相同，函数不能返回该类变量的地址（指针）作为返回值。

（2）静态局部变量分配在数据段/bss段（显式初始化为非0则在数据段，显式初始化为0或未显示初始化则在bss段），作用域为代码块作用域（人为规定的），生命周期为永久（天然的），链接属性为无连接（天然的）。定义时如果未显式初始化则其值为0（天然的），变量地址由运行时环境在加载程序时确定，整个程序运行过程中唯一不变；静态局部变量其实就是作用域为代码块作用域（同时链接属性为无连接）的全局变量。静态局部变量可以改为用全局变量实现（程序中尽量避免用全局变量，因为会破坏结构性）。

（3）静态全局变量/静态函数和普通全局变量/普通函数的唯一差别是：static使全局变量/函数的链接属性由外部链接（整个程序所有文件范围）转为内部链接（当前c文件内）。这是为了解决全局变量/函数的重名问题（C语言没有命名空间namespace的概念，因此在程序中文件变多之后全局变量/函数的重名问题非常严重，将不必要被其他文件引用的全局变量/函数声明为static可以很大程度上改善重名问题，但是仍未彻底解决）。

（4）写程序尽量避免使用全局变量，尤其是非static类型的全局变量。能确定不会被其他文件引用的全局变量一定要static修饰。

（5）注意区分全局变量的定义和声明。一般规律如下：如果定义的同时有初始化则一定会被认为是定义；如果只是定义而没有初始化则有可能被编译器认为是定义，也可能被认为是声明，要具体分析；如果使用extern则肯定会被认为是声明（实际上使用extern也可以有定义，实际上加extern就是明确声明这个变量为外部链接属性）。

（6）全局变量应该定义在c文件中并且在头文件中声明，而不要定义在头文件中（因为如果定义在头文件中，则该头文件被多个c文件包含时该全局变量会重复定义）。

（7）在b.c中引用a.c中定义的全局变量/函数有2种方法：一是在a.h中声明该函数/全局变量，然后在b.c中#include <a.h>；二是在b.c中使用extern显式声明要引用的函数/全局变量。其中第一种方法比较正式。

（8）存储类决定生命周期，作用域决定链接属性

（9）宏和inline函数的链接属性为无连接。

****

# 8、一些杂散但值得探讨的问题

## 8.1、操作系统究竟是什么

### 8.1.1、像人类社会一样的计算机软件系统（有些人只埋头干活，有些人只做管理）

（1）人类社会最开始时人人都干活，这时候没有专业分工，所有人都直接做产生价值的工作。当时是合适的，因为当时生产力低下，人口稀少。这就像裸机程序一样（裸机程序的特点是：代码量小，功能简单、所有代码都和直接目的有关，没有服务性代码）。

（2）后来人口增加生产力提高，有一部分人脱离了直接产生价值的体力劳动专职指挥（诞生了阶级）。本质上来说是合理的，因为资源得到了更大限度的使用，优化了配置，提升了整体效率。程序也是一样，当计算机技术发展，计算机性能和资源大量增加，这时候写代码也要产生阶级也要进行分工，不然如果所有代码都去参加直接性的工作，则整体系统效率不高。（因为代码很难进行资源的优化配置）。

（3）解决方案就是操作系统。操作系统就是分出来的管理阶级，操作系统的代码本身并不直接产生价值，它的主要任务是管理所有资源，它主要为直接产生价值、直接劳动的那些程序（各种应用程序）提供服务。所以操作系统既是管理者也是服务者。

（4）裸机程序就好象小公司，操作系统下的程序就好象大型跨国公司；裸机程序就好象小国家，操作系统下程序就好象大国家；如果我们要做一个产品，软件系统到底应该是裸机还是基于操作系统呢？本质上取决于产品本身的复杂度。只有极简单的功能、使用极简单的CPU（譬如单片机）的产品才会选择用裸机开发；一般的复杂性产品都会选择基于操作系统来开发。

### 8.1.2、操作系统的调用通道：API函数

（1）操作系统负责管理和资源调配，应用程序负责具体的直接劳动，他们之间的接口就是API函数。当应用程序需要使用系统资源（譬如内存、譬如CPU、譬如硬件操作）时就通过API向操作系统发出申请，然后操作系统响应申请帮助应用程序执行功能。

### 8.1.3、C库函数和API的关系

（1）单纯的API只是提供了极简单没有任何封装的服务函数，这些函数应用程序是可用的，但是不太好用。应用程序为了好用，就对这个API进行了二次封装，把它变得好用一些，于是就成了C库函数。

（2）有时完成一个功能，有相应的库函数可以完成，也有API可以完成，用哪个都行。譬如读写文件，API的接口是open write read close；库函数的接口是fopen fwrite fread fclose。fopen本质上是使用open实现的，只是进行了封装。封装肯定有目的（添加缓冲机制）。

### 8.1.4、不同平台（Windows、Linux、裸机）下库函数的差异

（1）不同操作系统API是不同的，但是都能完成所有的任务，只是完成一个任务所调用的API不同。

（2）库函数在不同操作系统下也不同，但是相似性要更高一些。这是人为的，因为人下意识想要屏蔽不同操作系统的差异，因此在封装API成库函数的时候，尽量使用了同一套接口，所以封装出来的库函数挺像的。但是还是有差异，所以在一个操作系统上写的应用程序不可能直接在另一个操作系统上面编译运行。于是乎就有个可移植性出来了。

（3）跨操作系统可移植平台，譬如QT、譬如Java语言。

### 8.1.5、操作系统的重大意义：软件体系分工

（1）有了操作系统后，我们做一个产品可以首先分成2部分：一部分人负责做操作系统（开发驱动的）；一部分人负责用操作系统实现具体功能（开发应用）。实际上上层应用层的功能进一步复杂化后又分了好多层。

***

## 8.2、main函数返回给谁

### 8.2.1、函数为什么要返回值

（1）函数在设计的时候设计了参数和返回值，参数是函数的输入，返回值是函数的输出。

（2）因为函数需要对外输出数据（实际上是函数运行的一些结果值）因此需要返回值

（3）形式上来说，函数被另一个函数所调用，返回值作为函数式的值返回给调用这个函数的地方

总结：函数的返回值就是给调用它的人返回一个值

### 8.2.2、main函数被谁调用

（1）main函数是特殊的，首先这个名字是特殊的。因为C语言规定了main函数是整个程序的入口。其他的函数只有直接或间接被main函数所调用才能被执行，如果没有被main直接/间接调用则这个函数在整个程序中无用。

（2）main函数从某种角度来讲代表了我当前这个程序，或者说代表了整个程序。main函数的开始意味着整个程序开始执行，main函数的结束返回意味着整个程序的结束。

（3）谁执行了这个程序，谁就调用了main。

（4）谁执行了程序？或者说程序有哪几种被调用执行的方法？涉及到下面章节的内容了

### 8.2.3、Linux下一个新程序执行的本质

（1）表面来看，linux中在命令行中去./xx执行一个可执行程序

（2）我们还可以通过shell脚本来调用执行一个程序

（3）我们还可以在程序中去调用执行一个程序（fork exec）

​	总结：我们有多种方法都可以执行一个程序，但是本质上是相同的。linux中一个新程序的执行本质上是一个进程的创建、加载、运行、消亡。linux中执行一个程序其实就是创建一个新进程然后把这个程序丢进这个进程中去执行直到结束。新进程是被谁开启？在linux中进程都是被它的父进程fork出来的。

分析：命令行本身就是一个进程，在命令行底下去./xx执行一个程序，其实这个新程序是作为命令行进程的一个字进程去执行的。

总之一句话：一个程序被它的父进程所调用。

​	结论：main函数返回给调用这个函数的父进程。父进程要这个返回值干嘛？父进程调用子进程来执行一个任务，然后字进程执行完后通过main函数的返回值返回给父进程一个答复。这个答复一般是表示子进程的任务执行结果完成了还是错误了。（0表示执行成功，负数表示失败）

### 8.2.4、实践验证获取main函数返回值

（1）用shell脚本执行程序可以获取程序的返回值并且打印出来

（2）linux shell中用$?这个符号来存储和表示上一个程序执行结果。

### 8.2.5、启示

（1）任何人任何事物都是有妈生的，不会无缘无故出现或消亡。

（2）看起来没用、改掉或去掉没错的，也不见得就真的没用没错。要大胆总结更要小心求证。

***

## 8.3、argc、argv与main函数的传参

### 8.3.1、谁给main函数传参

（1）调用main函数所在的程序的它的父进程给main函数传参，并且接收main的返回值。

### 8.3.2、为什么需要给main函数传参

（1）首先，main函数不传参是可以的，也就是说父进程调用子程序并且给子程序传参不是必须的。 int main(void)这种形式就表示我们认为不必要给main传参。

（2）有时候我们希望程序有一种灵活性，所以选择在执行程序时通过传参来控制程序中的运行，达到不需要重新编译程序就可以改变程序运行结果的效果。

### 8.3.3、表面上：给main函数传参的实现

（1）给main传参通过argc和argv这两个C语言预订的参数来实现

（2）argc是int类型，表示运行程序的时候给main函数传递了几个参数；argv是一个字符串数组，这个数组用来存储多个字符串，每个字符串就是我们给main函数传的一个参数。argv[0]就是我们给main函数的第一个传参（一般都是执行程序的指令），argv[1]就是传给main的第二个参数····

```c
#include<stdio.h>

int main(int argc, char * argv[])
{
    int i;
    printf("argc = %d\n", argc);
    for(i = 0; i < argc; i++)
    {
        printf("argv[%d] = %s\n", argv[i]);
    }
}//不输入参数时结果是：argc = 1; argv[0] = ./a.out;
```



### 8.3.4、本质上：给main函数传参的实现

（1）上节课讲过，程序调用有各种方法但是本质上都是父进程fork一个子进程，然后子进程和一个程序绑定起来去执行（exec函数族），我们在exec的时候可以给他同时传参。

（2）程序调用时可以被传参（也就是main的传参）是操作系统层面的支持完成的。

### 8.3.5、给main函数传参要注意的点

（1）main函数传参都是通过字符串传进去的。

（2）程序被调用时传参，各个参数之间是通过空格来间隔的。

（3）在程序内部如果要使用argv，那么一定要先检验argc。

****

## 8.4、void类型的本质

### 8.4.1、C语言属于强类型语言

（1）编程语言分2种：强类型语言和弱类型语言。强类型语言中所有的变量都有自己固定的类型，这个类型有固定的内存占用，有固定的解析方法；弱类型语言中没有类型的概念，所有变量全都是一个类型（一般都是字符串的），程序在用的时候再根据需要来处理变量。

（2）C语言就是典型的强类型语言，C语言中所有的变量都有明确的类型。因为C语言中的一个变量都要对应内存中的一段内存，编译器需要这个变量的类型来确定这个变量占用内存的字节数和这一段内存的解析方法。

### 8.4.2、数据类型的本质含义

（1）数据类型的本质就决定变量的内存占用数，和内存的解析方法。

（2）所以得出结论：c语言中变量必须有确定的数据类型，如果一个变量没有确定的类型（就是所谓的无类型）会导致编译器无法给这个变量分配内存，也无法解析这个变量对应的内存。因此得出结论不可能有没有类型的变量。

（3）但是C语言中可以有没有类型的内存。在内存还没有和具体的变量相绑定之前，内存就可以没有类型。实际上纯粹的内存就是没有类型的，内存只是因为和具体的变量相关联后才有了确定的类型（其实内存自己本身是不知道的，而编译器知道，我们程序在使用这个内存时知道类型所以会按照类型的含义去进行内存的读和写）。

### 8.4.3、void类型的本质

（1）void类型的正确的含义是：不知道类型，不确定类型，还没确定类型。

（2）void a;定义了一个void类型的变量，含义就是说a是一个变量，而且a肯定有确定的类型，只是目前我还不知道a的类型，还不确定，所以标记为void。

### 8.4.4、为什么需要void类型

（1）什么情况下需要void类型？其实就是在描述一段还没有具体使用的内存时需要使用void类型。

（2）void的一个典型应用案例就是malloc的返回值。我们知道malloc函数向系统堆管理器申请一段内存给当前程序使用，malloc返回的是一个指针，这个指针指向申请的那段内存。malloc刚申请的这段内存尚未用来存储数据，malloc函数也无法预知这段内存将来被存放什么类型的数据，所以malloc无法返回具体类型的指针，解决方法就是返回一个void *类型，告诉外部我返回的是一段干净的内存空间，尚未确定类型。所以我们在malloc之后可以给这段内存读写任意类型的数据。

（3）void *类型的指针指向的内存是尚未确定类型的，因此我们后续可以使用强制类型转换强行将其转为各种类型。这就是void类型的最终归宿，就是被强制类型转换成一个具体类型。

（4）void类型使用时一般都是用void *，而不是仅仅使用void。

***

## 8.5、C语言中的NULL

### 8.5.1、NULL在C/C++中的标准定义

（1）NULL不是C语言关键字，本质上是一个宏定义

（2）NULL的标准定义：

`#ifdef _cplusplus			// 条件编译
 #define NULL 0
 #else
 #define NULL (void *)0		// 这里对应C语言的情况
 #endif`

​	解释：C++的编译环境中，编译器预先定义了一个宏_cplusplus，程序中可以用条件编译来判断当前的编译环境是C++的还是C的。

​	NULL的本质解析：NULL的本质是0，但是这个0不是当一个数字解析，而是当一个内存地址来解析的，这个0其实是0x00000000，代表内存的0地址。(void *)0这个整体表达式表示一个指针，这个指针变量本身占4字节，地址在哪里取决于指针变量本身，但是这个指针变量的值是0，也就是说这个指针变量指向0地址（实际是0地址开始的一段内存）。

### 8.5.2、从指针角度理解NULL本质

（1）int *p;		// p是一个函数内的局部变量，则p的值是随机的，也就是说p是一个野指针。

（2）int *p = NULL;	// p是一个局部变量，分配在栈上的地址是由编译器决定的，我们不必关心，但是p的值是(void *)0，实际就是0，意思是指针p指向内存的0地址处。这时候p就不是野指针了。

（3）为什么要让一个野指针指向内存地址0处？主要是因为在大部分的CPU中，内存的0地址处都不是可以随便访问的（一般都是操作系统严密管控区域，所以应用程序不能随便访问）。所以野指针指向了这个区域可以保证野指针不会造成误伤。如果程序无意识的解引用指向0地址处的野指针则会触发段错误。这样就可以提示你帮助你找到程序中的错误。

### 8.5.3、为什么需要NULL

（1）第一个作用就是让野指针指向0地址处安全。

（2）第二个作用就是一个特殊标记。按照标准的指针使用步骤是：
`int *p = NULL;		// 定义p时立即初始化为NULL
 p = xx;
 if (NULL != p)
 { 
	 *p 				// 在确认p不等于NULL的情况下才去解引用p
 }
 p = NULL			// 用完之后p再次等于NULL`

注意：一般比较一个指针和NULL是否相等不写成if (p == NULL)，而写成if (NULL == p)。原因是第一种写法中如果不小心把 == 写成了 =，则编译器不会报错，但是程序的意思完全不一样了；而第二种写法如果不小心把 == 写成了 = 则编译器会发现并报错。

### 8.5.4、注意不要混用NULL与‘\0’

（1）'\0' 和 '0' 和 0  和 NULL几个区分开。

（2）'\0'是一个转义字符，他对应的ASCII编码值是0，本质就是0

（3）'0'是一个字符，他对应的ASCII编码值是48，本质是48

（4）0是一个数字，他就是0，本质就是0

（5）NULL是一个表达式，是强制类型转换为void *类型的0，本质是0.

​	总结：'\0'用法是C语言字符串的结尾标志，一般用来比较字符串中的字符以判断字符串有没有到头；'0'是字符0，对应0这个字符的ASCII编码，一般用来获取0的ASCII码值；0是数字，一般用来比较一个int类型的数字是否等于0；NULL是一个表达式，一般用来比较指针是否是一个野指针。

****

## 8.6、运算中的临时匿名变量

### 8.6.1、C语言和汇编的区别（汇编完全对应机器操作，c对应逻辑操作）

（1）C语言叫高级语言，汇编语言叫低级语言。

（2）低级语言的意思是汇编语言和机器操作相对应，汇编语言只是CPU的机器码的助记符，用汇编语言写程序必须拥有机器的思维。因为不同的CPU设计时指令集差异很大，因此用汇编编程的差异很大。

（3）高级语言（C语言）它对低级语言进行了封装（C语言的编译器来完成），给程序员提供了一个靠近人类思维的一些语法特征，人类不用过于考虑机器原理，而可以按照自己的逻辑原理来编程。譬如数组、结构体、指针····

（4）更高级的语言如java、C#等只是进一步强化了C语言提供的人性化的操作界面语法，在易用性上、安全性上进行了提升。

### 8.6.2、C语言的一些“小动作”

（1）高级语言中有一些元素是机器中没有的

（2）高级语言在运算中允许我们大跨度的运算。意思就是低级语言中需要好几步才能完成的一个运算，在高级语言中只要一步即可完成。譬如C语言中一个变量i要加1，在C中只需要i++即可，看起来只有一句代码。但实际上翻译到汇编阶段需要3步才能完成：第1步从内存中读取i到寄存器，第2步对寄存器中的i进行加1，第3步将加1后的i写回内存中的i。

### 8.6.3、使用临时变量来理解强制类型转换

```c
#include<stdio.h>

int main(void)
{
    float a = 13.34;//a被强制转换类型后自己本身是没变的
    int b = (int)a;//a在赋值的时候是先赋值给中间变量在由中间变量赋值给b的 				  //，再将中间变量销毁，这就是C语言的小动作
    printf("a = %f, b = %d\n", a, b);//结果：a = 13.34；b = 13；
}
```



### 8.6.4、使用临时变量来理解不同数据类型之间的运算

 ```c
#include<stdio.h>

int main(void)
{
    int b;
    float a;
    b = 10;
    a = b / 3;//第一步先算b/3，第二步将第一步得结果强制转换为float类型				//生成一个临时变量，第三步将第二步生成的临时变量赋值给a，第				//四步销毁临时变量。
    
    printf("a = %f\n", a);
}
 ```



****

## 8.7、顺序结构

### 8.7.1、最浅显得顺序结构：三种结构之一

（1）代码执行的时候如果没有遇到判断跳转或者循环，默认是顺序执行的。执行完上一句则开始执行下一句。

（2）顺序结构说明CPU的工作状态，就是以时间轴来顺序执行所有的代码语句直到停机。

### 8.7.2、选择和循环结构内部的顺序结构

（1）譬如if( ){ }在{ }内部是if的代码段，在代码段内部还是按照顺序结构来执行的。

（2）switch case内部也一样，也是按照顺序结构执行的。

（3）while for内部也是按照顺序结构来执行的。

### 8.7.3、编译过程中的顺序结构

（1）一个C程序有多个.c文件组成，编译的时候多个.c文件是独立分开编译的。每个c文件编译的时候，编译器是按照从前到后的顺序逐行进行编译的。

（2）编译器编程时的顺序编译会导致函数/变量必须先定义/声明才能调用，这也是C语言中函数/变量声明的来源。

（3）链接过程中呢？应该说链接过程链接器实际上是在链接脚本指导下完成的。所以链接时的.o文件的顺序是由链接脚本指定的。如果链接脚本中明确指定了顺序则会优先考虑这个规则按照这个指定的顺序排布，如果链接脚本中没有指定具体的顺序则链接器会自动的排布。

### 8.7.4、为什么本质都是顺序结构

（1）顺序结构本质上符号CPU的设计原理，CPU又是人设计的，所以CPU的设计符合人的思考原理

****

## 8.8、程序调试的debug宏

### 8.8.1、程序调试的常见方案：单步调试、裸机LED调试、打印信息、log文件

（1）利用调试器进行单步调试（譬如IDE中，Jlink）适用于新手，最大的好处就是直观，能够帮助找到问题。缺点是限制性大、速度慢。

（2）裸机使用LED、蜂鸣器等硬件调试，适合单片机裸机程序

（3）printf函数打印调试，比较常用，作为程序员必须学会使用打印信息调试。好处是具有普遍性，几乎在所有的情况下都能用。

（4）log文件（日志文件）是系统运行过程中在特定时候会打印一些调试信息，日志文件记录下来这些调试信息以供后续查找追查问题。适合于系统级或者大型程序的调试。

### 8.8.2、打印信息不能太多也不能太少

（1）调试信息太少会不够信息找到问题所在。

（2）调试信息太多会有大量的无用的信息淹没有用信息，导致有用信息无法看见，等于没有。

### 8.8.3、调试(DEBUG)版本和发行(RELEASE)版本的区别

（1）DEBUG版本就是包含了调试信息输出的版本，在程序测试过程中会发布debug版本，这种版本的程序运行时会打印出来调试信息/log文件，这些信息可以辅助测试人员判断程序的问题所在。DEBUG版本的坏处是输出调试信息占用了系统资源，拖慢了系统运行速度。因此DEBUG版本的性能低于RELEASE版本。

（2）RELEASE版本就是最终的发布版本，相较于DEBUG版本的功能代码是一样的，但是去掉了所有的调试信息。适合最终测试通过要发布的程序，因为去掉了调试信息所以程序的运行效率要更高。

（3）DEBUG和RELASE版本其实是一套源代码。源代码中是有很多的打印调试信息的语句的，如何来控制生成DEBUG和RELEEASE版本？靠条件编译，靠一个宏。

### 8.8.4、debug宏的实现原理

（1）DEBUG宏大概的原理是：

`#ifdef DEBUG
 #define dbg()		printf()
 #else
 #define dbg()	
 #endif`

（2）工作方式是：如果我们要输出DEBUG版本则在条件编译语句前加上#define DEBUG即可，这样程序中的调试语句dbg()就会被替换成printf从而输出；如果我们要输出RELEASE版本则去掉#define DEBUG，则dbg()就会被替换成空，则程序中所有的dbg()语句直接蒸发了，这样的程序编译时就会生成没有任何调试信息的代码。

### 8.8.5、分析几个DEBUG宏

（1）应用程序中DEBUG宏

```c
#ifdef DEBUG
#define DBG(...) fprintf(stderr, " DBG(%s, %s(), %d): ", __FILE__, __FUNCTION__, __LINE__); fprintf(stderr, __VA_ARGS__)
#else
#define DBG(...)
#endif

//注：__FILE__等是C语言中的预定义宏，就是说这个东西是个宏定义，但是是C语言 //自己定义的。这些宏具有特殊的含义，譬如__FILE__表示当前正在编译的c文件的 //文件名。

```

（2）在内核中的DEBUG宏

```c
#ifdef DEBUG_S3C_MEM
#define DEBUG(fmt, args...) 	printk(fmt, ##args)
#else
#define DEBUG(fmt, args...) 	do {} while (0)
#endif
```

****

# 9、链表&状态机与多线程

## 9.1、链表的引入

### 9.1.1、从数组的缺陷说起

（1）数组有两个缺陷，一个是数组中所有的元素类型必须一致；第二个是数组的元素个数必须事先制定好并且一旦制定好了之后不能更改。

（2）如何解决数组的两个缺陷：数组的第一个缺陷靠结构体去解决，结构体允许其中的元素类型不相同，因此解决了数组的第一个缺陷。所以说结构体是因为数组不能解决某些问题所以才被发明出来的。

（3）如何解决数组的第二个缺陷：我们希望数组的大小可以实施扩展如我刚开始定了一个元素个数是10，后来程序运行时觉得不够因此动态扩展为20.普通的数组显然不行，我们可以对数组进行封装以达到这种目的；我们还可以使用一个新的数据结构来解决，这个新的数据结构就是链表。

总结：几乎可以这样理解：链表就是一个元素个数可以实时变大/变小的数组。

### 9.1.2、大学为什么都有新校区

（1）学校初建的时候（类似于变量定义并初始化时），这时候因为旁边都是荒地而没有建筑，因此学校的校园大小由自己定的；但是学校建立了之后旁边慢慢的也有了其他建筑（类似于这个变量分配了之后，内存的相邻区域又分配了其他变量与这个变量地址相连），这时候你的校园随着发展感觉不够用了想要扩展，却发现邻居已经住满了，校园的四周全部都是别人的建筑，这时候学校要扩展有2个办法：第一个是拆迁，第二个是搬迁，第三个是外部扩展。

（2）拆迁基本行不通，因为成本太高了。

（3）搬迁可以行的通。程序中解决数组大小扩展的一个思路就是整体搬迁。具体步骤是：先在另外的空白内存处建立一个大的数组，然后把原来的数组中的元素的值整个复制到新数组的头部，然后再释放掉原来数组的内存空间，并且把新的数组去替代原来的数组。这种可变数组在C语言中不支持，但是在更高级语言如C++、Java等里面是支持的。

（4）外部扩展的思路是最常见的，基本可以说是最合理的。它的一个思路就是化整为零，在原来的不动的前提下去外部扩展新的分基地。外部扩展在学校的例子中就是新校区；外部扩展在编程解决数组问题的点上就是链表。

### 9.1.3、链表是什么样的

（1）顾名思义，链表就是用锁链连接起来的表。这里的表指的是一个一个的节点（一个节点就是一个校区），节点中有一些内存可以用来存储数据（所以叫表，表就是数据表）；这里的锁链指的是链接各个表的方法，C语言中用来连接2个表（其实就是2块内存）的方法就是指针。

（2）链表是由若干个节点组成的（链表的各个节点结构是完全类似的），节点是由有效数据和指针组成的。有效数据区域用来存储信息完成任务的，指针区域用于指向链表的下一个节点从而构成链表。

### 9.1.4、时刻别忘了链表使用了干嘛的

（1）时刻谨记：链表就是用来解决数组的大小不能动态扩展的问题，所以链表其实就是当数组用的。直白点：链表能完成的任务用数组也能完成，数组能完成的任务用链表也能完成。但是灵活性不一样。

（2）简单说：链表就是用来存储数据的。链表用来存数据相对于数组来说优点就是灵活性，需要多少个动态分配多少个，不占用额外的内存。数组的优势是使用简单（简单粗暴）。

****

## 9.2、单链表的实现

### 9.2.1、单链表的节点构成

（1）链表是由节点组成的，节点中包含：有效数据和指针。

（2）定义的struct node只是一个结构体，本身并没有变量生成，也不占用内存，结构体定义相当于为链表节点定义了一个模板，但是还没有一个节点，将来在实际创建链表时需要一个节点时用这个模板来复制一个即可。

```c
//封装节点（节点是由有效数据和指针封装出来的，这个可以用结构体完成）
#include<stdio.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

```

### 9.2.2、堆内存的申请和使用

（1）链表的内存要求比较灵活，不能用栈、也不能用data数据段，只能用堆内存。

（2）使用堆内存来创建一个链表节点的步骤：1、申请堆内存，大小为一个节点的大小（检查申请结果是否正确）；2、清理申请到的堆内存；3、把我们申请到的堆内存当作一个新节点；4、填充你这个新节点的有效数据和指针区域。

```c
#include<stdio.h>
#include<string.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

int main(void)
{
    //创建一个链表的节点
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));//可以用bzero把申请到的空间变为0，也									//可以用memset指定赋值为什么
    //填充我们这个新节点
    p->date = 1;
    p->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好
}
```

### 9.2.3、链表的头指针

（1）头指针并不是节点，而是一个普通指针，只占4字节。头指针的类型时struct node * 类型的，所以它才能指向我们链表的节点。

（2）一个典型的链表的实现就是头指针指向我们链表的第一个节点，然后第一个节点中的指针指向下一个节点，然后依次类推直到最后一个节点。这样就构成了一个链。

### 9.2.4、实战：构建简单的单链表

```c
#include<stdio.h>
#include<string.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

int main(void)
{
    struct ndoe * pHeader;      //创建头指针

    /******************************************************************/

    //创建一个链表的节点
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p->date = 1;
    p->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    pHeader = p;    //将头指针和第一个节点关联起来

    /**************************************************************/

     /**************************************************************/

    //创建第二个链表的节点
    struct node *p1 = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p1)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p1,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p1->date = 2;
    p1->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    p->pNext = p1;    //将头指针和第一个节点关联起来

    /**************************************************************/

     /***************************************************************/

    //创建第三个链表的节点
    struct node *p2 = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p2)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p2,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p2->date = 3;
    p2->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    p1->pNext = p2;    //将头指针和第一个节点关联起来

    /*******************************************************/
	return 0;
}

```

****

## 9.3、单链表算法之插入节点

### 9.3.1、继续上节，访问链表中各个节点的数据

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.c>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

int main(void)
{
    struct ndoe * pHeader;      //创建头指针

    /******************************************************************/

    //创建一个链表的节点
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p->date = 1;
    p->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    pHeader = p;    //将头指针和第一个节点关联起来

    /**************************************************************/

     /**************************************************************/

    //创建第二个链表的节点
    struct node *p1 = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p1)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p1,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p1->date = 2;
    p1->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    p->pNext = p1;    //将头指针和第一个节点关联起来

    /**************************************************************/

     /***************************************************************/

    //创建第三个链表的节点
    struct node *p2 = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p2)
    {
        printf("malloc error\n");
        return -1;
    }
    //清零申请到的空间
    bzero(p2,sizeof(struct node));//可以用bzero把申请到的空间变为0，也								//可以用memset指定赋值为什么
    //填充我们这个新节点
    p2->date = 3;
    p2->pNext = NULL;//暂时没有下一个节点就将其指向NULL，实际操作时将下					//一个节点malloc返回的指针赋值给它就好

    p1->pNext = p2;    //将头指针和第一个节点关联起来

    /*******************************************************/
    
     //访问链表中各个节点中的有效数据，访问时不能使用p、p1、p2而只能使用	   //pHeader

    //访问链表第一个节点的有效数据
    printf("node 1 date = %d\n", pHeader->date);
    //pHeader->date等同于p->date

    //访问链表第二个节点的有效数据
    printf("node 2 date = %d\n", pHeader->pNext->date);
    //pHeader->pNext->date等同于p1->date

    //访问链表第三个节点的有效数据
    printf("node 1 date = %d\n", pHeader->pNext->pNext->date);
    //pHeader->pNext->pNext->date等同于p2->date
    
	return 0;
}
```

（1）只能用头指针，不能用各个节点自己的指针，因为在实际当中我们保存链表是不会保存各个节点的指针的，只能用头指针来访问链表节点。

（2）前一个节点内部的pNext指针能帮助我们找到下一个节点

### 9.3.2、将创建节点的代码封装成一个函数

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

//创建一个函数用来创建节点
//返回值就是返回创建好的节点的结构体地址
struct node * create_node(int date)
{
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return NULL;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));
    //填充我们这个新节点
    p->date = date;
    p->pNext = NULL;
    
    return p;       //将创建好的节点首地址返回
    
}

int main(void)
{
    struct node * pHeader;      //创建头指针

    pHeader = create_node(1);    //将头指针和第一个节点关联起来

    //创建第二个链表的节点

    pHeader->pNext = create_node(2);    //将头指针和第一个节点关联起来

    //创建第三个链表的节点
    
    pHeader->pNext->pNext = create_node(3);   //将头指针和第一个节点											//关联起来


    //访问链表中各个节点中的有效数据，访问时不能使用p、p1、p2而只能使用 	  //pHeader

    //访问链表第一个节点的有效数据
    printf("node 1 date = %d\n", pHeader->date);
    //pHeader->date等同于p->date

    //访问链表第二个节点的有效数据
    printf("node 2 date = %d\n", pHeader->pNext->date);
    //pHeader->pNext->date等同于p1->date

    //访问链表第三个节点的有效数据
    printf("node 1 date = %d\n", pHeader->pNext->pNext->date);
    //pHeader->pNext->pNext->date等同于p2->date

}

```

（1）封装时的关键点就是函数的接口（函数的参数和返回值）的设计

### 9.3.3、从链表头插入新节点

```c
//头插入

#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

//创建一个函数用来创建节点
//返回值就是返回创建好的节点的结构体地址
struct node * create_node(int date)
{
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return NULL;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));//可以用bzero把申请到的空间变为0，也可以用memset指定赋值为什么
    //填充我们这个新节点
    p->date = date;
    p->pNext = NULL;

    return p;       
    
}
//计算添加了新节点后，链表中有多少个节点将值写入头节点的date中
//尾节点插入
void insert_tail(struct node *pH, struct node * new)
{
    int cnt = 0;
    //第一步先找到之前链表中最后一个节点
    struct node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;//如果没找到就往后一个节点
        cnt++;
    }
    //在尾部将新节点连接上
    p->pNext = new;
    pH->date = cnt + 1;//将节点个数放入头节点中


}

//头节点插入
void insert_head(struct node *pH, struct node * new)
{
    struct node *p = pH;
    //将新添加的节点计数到头节点统计节点个数中去
    pH->date += 1;

    //将新节点的pNext指向原来的第一个节点的首地址
    new->pNext = p->pNext;

    //将头节点的pNext指向新节点的首地址
    p->pNext = new;

}

int main(void)
{
    struct node * pHeader = NULL;      //创建头指针

    pHeader = create_node(0);    //将头指针和第一个节点关联起来成为一个头节点
    
    //insert_tail(pHeader,create_node(1));  //利用函数在节点尾部增加节点
    insert_tail(pHeader,create_node(1));  //利用函数在节点尾部增加节点
  

    insert_head(pHeader,create_node(2));
  

    //访问链表中各个节点中的有效数据，访问时不能使用p、p1、p2而只能使用pHeader

    //访问链表第一个节点的有效数据
    printf("hearde node date = %d\n", pHeader->date);
    //pHeader->date等同于p->date

    //访问链表第二个节点的有效数据
    printf("node 1 date = %d\n", pHeader->pNext->date);
    //pHeader->pNext->date等同于p1->date

    //访问链表第三个节点的有效数据
    printf("node 2 date = %d\n", pHeader->pNext->pNext->date);
    //pHeader->pNext->pNext->date等同于p2->date

}

```



### 9.3.4、从链表尾部插入新节点

（1）尾部插入简单点，因为前面已经建立好的链表不用动。直接动最后一个就可以了。

（2）思路：由头指针向后遍历，知道走到最后一个节点，原来的最后一个节点的pNext是NULL ，现在我们只要把它改为new就可以了，添加之后我们新节点就变参最后一个节点了。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

//创建一个函数用来创建节点
//返回值就是返回创建好的节点的结构体地址
struct node * create_node(int date)
{
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return NULL;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));
    //填充我们这个新节点
    p->date = date;
    p->pNext = NULL;
    
    return p;       //将创建好的节点首地址返回
    
}

void insert_tail(struct node *pH, struct node * new)
{
    //第一步先找到之前链表中最后一个节点
    struct node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;//如果没找到就往后一个节点
    }
    //在尾部将新节点连接上
    p->pNext = new;


}

int main(void)
{
    struct node * pHeader = NULL;      //创建头指针

    pHeader = create_node(1);    //将头指针和第一个节点关联起来
    
    insert_tail(pHeader,create_node(2)); //利用函数在节点尾部增加节点
    
     printf("node 1 date = %d\n", pHeader->date);
    //pHeader->date等同于p->date

    //访问链表第二个节点的有效数据
    printf("node 2 date = %d\n", pHeader->pNext->date);
    //pHeader->pNext->date等同于p1->date

    
	return 0;
}

```

#### 9.3.4.1、头节点

（1）问题：因为我们在insert_tail中直接默认头指针指向了一个节点，因此如果我们的程序中只有头指针，程序就会段错误，我们不得不在定义头指针之后先create_node创建一个新节点给头指针初始化，否则不能避免这个错误；但是这样解决让程序看起来逻辑有点不太顺，因为看起来第一个节点和后面的节点的创建、添加方式有点不同。

（2）链表还有另外一种用法，就是把头指针指向的第一个节点作为头节点使用。头节点的特点是：第一，它紧跟在头指针后面。第二，头节点的数据部分是空的（有时候不是空的，而是存储整个链表的节点数），指针部分指向下一个节点，也就是第一个节点。

（3）这样看来，头节点确实和其他节点不同。我们在创建一个链表时添加节点的方法也不同。头节点在创建头指针时一并创建并且和头指针关联起来；后面的真正的存储数据的节点用节点添加的函数来完成，譬如insert_tail.

（4）链表有没有头节点是不同的。体现在链表的插入节点、删除节点、遍历节点、解析链表的各个算法函数都不同。所以如果一个链表设计的时候就有头节点那么后面的所有算法都应该这样来处理；如果设计时就没有头节点，那么后面的所有算法都应该按照没有头节点来做。实际编程中两种链表都有人用，所以大家在看别人写的代码时一定要注意看它有没有头节点。

```c
//改造之前的程序让其有头节点
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

//创建一个函数用来创建节点
//返回值就是返回创建好的节点的结构体地址
struct node * create_node(int date)
{
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return NULL;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));
    //填充我们这个新节点
    p->date = date;
    p->pNext = NULL;
    return p;       //将创建好的节点首地址返回
    
}
//计算添加了新节点后，链表中有多少个节点将值写入头节点的date中

void insert_tail(struct node *pH, struct node * new)
{
    int cnt = 0;
    //第一步先找到之前链表中最后一个节点
    struct node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;//如果没找到就往后一个节点
        cnt++;
    }
    //在尾部将新节点连接上
    p->pNext = new;
    pH->date = cnt + 1;//将节点个数放入头节点中


}


int main(void)
{
    struct node * pHeader = NULL;      //创建头指针

    pHeader = create_node(0);    //将头指针和第一个节点关联起来成为一								//个头节点
 
    insert_tail(pHeader,create_node(1));  
    insert_tail(pHeader,create_node(2));
  

    //访问链表第一个节点的有效数据
    printf("hearde node date = %d\n", pHeader->date);
    //pHeader->date等同于p->date

    //访问链表第二个节点的有效数据
    printf("node 1 date = %d\n", pHeader->pNext->date);
    //pHeader->pNext->date等同于p1->date

    //访问链表第三个节点的有效数据
    printf("node 2 date = %d\n", pHeader->pNext->pNext->date);
    //pHeader->pNext->pNext->date等同于p2->date

}

```

### 9.3.5、总结

（1）注意写代码过程中的箭头符号，和说话过程中的指针指向。这是两码事，容易搞混。箭头符号实际上是用指针方式来访问结构体，所以箭头符号的实质是访问结构体中的成员。更清楚一点说程序中的箭头和链表的连接没有任何关系；链表中的节点通过指针指向来连接，编程中表现为一个赋值语句（用=来进行连接），实质是把后一个节点的首地址，赋值给前一个节点中的pNext元素做为值。

（2）链表可以从头部插入，也可以从尾部插入。也可以两头插入。头部插入和尾部插入对链表来说几乎没有差别。对链表本身无差别，但是有时候对业务逻辑有差别。

***

## 9.4、单链表的算法之遍历节点

### 9.4.1、什么是遍历

（1）遍历就是把单链表中的各个节点挨个拿出来，就叫遍历。

（2）遍历的要点：一是不能遗漏、二是不能重复、追求效率。

### 9.4.2、如何遍历单链表

（1）分析一个数据结构如何遍历，关键是分析这个数据结构本身的特点。然后根据本身特点来制定它的遍历算法。

（2）单链表的特点就是由很多个节点组成，头指针+头节点为整个链表的起始，最后一个节点的特征是它内部的pNext指针值为NULL。从起始到结尾中间由各个节点内部的pNext指针来挂接。由起始到结尾的路径有且只有一条。单链表的这些特点就决定了它的遍历算法。

（3）遍历方法：从头指针+头节点开始，顺着链表挂接指针依次访问链表的各个节点，取出这个节点的数据，然后再往下一个节点，直到最后一个节点，结束返回。

### 9.4.3、编写遍历程序

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

//构建一个链表的节点
struct node
{
    int date;               //有效数据
    struct node *pNext;     //指向下一个节点的指针
};

//创建一个函数用来创建节点
//返回值就是返回创建好的节点的结构体地址
struct node * create_node(int date)
{
    struct node *p = (struct node *)malloc(sizeof(struct node));
    //检验是否成功申请到的空间
    if(NULL == p)
    {
        printf("malloc error\n");
        return NULL;
    }
    //清零申请到的空间
    bzero(p,sizeof(struct node));//可以用bzero把申请到的空间变为0，也可以用memset指定赋值为什么
    //填充我们这个新节点
    p->date = date;
    p->pNext = NULL;

    return p;       
    
}
//计算添加了新节点后，链表中有多少个节点将值写入头节点的date中
//尾节点插入
void insert_tail(struct node *pH, struct node * new)
{
    int cnt = 0;
    //第一步先找到之前链表中最后一个节点
    struct node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;//如果没找到就往后一个节点
        cnt++;
    }
    //在尾部将新节点连接上
    p->pNext = new;
    pH->date = cnt + 1;//将节点个数放入头节点中


}

//头节点插入
void insert_head(struct node *pH, struct node * new)
{
    struct node *p = pH;
    //将新添加的节点计数到头节点统计节点个数中去
    pH->date += 1;

    //将新节点的pNext指向原来的第一个节点的首地址
    new->pNext = p->pNext;

    //将头节点的pNext指向新节点的首地址
    p->pNext = new;

}

//遍历单链表,pH为头指针
void travers(struct node * pH)
{
    //pH->date    是头节点，不是链表的常规节点，不用算进去。
    struct node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;       //先让指针走过头节点
        printf("node date = %d\n", p->date); 
    }
}

int main(void)
{
    struct node * pHeader = NULL;      //创建头指针

    pHeader = create_node(0);    //将头指针和第一个节点关联起来成为一个头节点
    
    //insert_tail(pHeader,create_node(1));  //利用函数在节点尾部增加节点
    insert_tail(pHeader,create_node(2));  //利用函数在节点尾部增加节点
    insert_tail(pHeader,create_node(3));
    insert_tail(pHeader,create_node(4));
    insert_head(pHeader,create_node(1));

    printf("hearde node date = %d\n", pHeader->date);//打印头节点

    travers(pHeader);

}

```

***

## 9.5、单链表的算法之删除节点

### 9.5.1、为什么要删除节点

（1）一直在强调，链表到底用来干嘛的？

（2）有时候链表节点中的数据不想要了，因此要删掉这个节点。

### 9.5.2、删除节点的两个步骤

（1）第一步：找到要删除的节点；第二步：删除这个节点。

### 9.5.3、如何找到要删除的节点

（1）通过遍历来查找节点。从头指针+头节点开始，顺着链表依次将各个节点拿出来，按照一定的方法比对，找到我们要删除的那个节点。

### 9.5.4、如何删除一个节点

（1）待删除的节点不是尾节点的情况:首先把待删除的节点的前一个节点的pNext指针指向待删除的节点的后一个节点的首地址（这样就把这个节点从链表中摘出来了），然后再将这个摘出来的节点free掉。

（2）待删除的节点是尾节点的情况：首先把待删除的尾节点的前一个节点的pNext指针指向null（这时候就相当于原来尾节点前面的一个节点变成了新的尾节点），然后将摘出来的节点free掉。

### 9.5.5、注意堆内存的释放

（1）前面几节课我们写的代码最终都没有释放堆内存。当程序都结束了的情况下那些没有free的堆内存也被释放了。

（2）有时候我们的程序运行时间很久，这时候malloc的内存如果没有free会一直被占用直到你free释放它或者整个程序终止。

```c
//删除数据为date的节点
int delnode(struct node *pH,int date)
{
    //通过遍历找到节点
    struct node *p = pH;
    struct node *pr = NULL;     //定义一个指针让他在遍历的时候指向前一个地址
    while(NULL != p->pNext)
    {
        pr = p;                 //在p走向下一个节点前先将其保存
        p = p->pNext;     
        if(p->date == date)     //找到节点
        {
            if(NULL == p->pNext)    //判断是否是尾节点
            {
                pr->pNext = NULL;
                free(p);
                pH->date -= 1;
            }
            else
            {
                pr->pNext = p->pNext;
                free(p);
                pH->date -= 1;
            }
            p = pr;//p被释放了，将p重新赋值进行下一个循环
        }
    }
    
}

//删除第date个节点
int delnnode(struct node * pH,int date)
{
    int i = 0;
    struct node *p = pH;
    struct node *pr = NULL;     //定义一个指针让他在遍历的时候指向前一个地址
    if(date <= pH->date)
    {
        while(i != date)
        {
            pr = p;
            p = p->pNext;
            i++;
        } 
        if(NULL == p->pNext)
        {
            pr->pNext = NULL;
            free(p);
            pH->date -= 1;
            return 0；
        }
        else
        {
            pr->pNext = p->pNext;
            free(p);
            pH->date -= 1;
            return 0；
        }
    }

}
```

****

## 9.6、单链表的算法之逆序

### 9.6.1、什么是链表的逆序

（1）链表的逆序又叫反向，意思就是把链表中所有的有效节点在链表中的顺序给反过来。

### 9.6.2、单链表逆序算法分析

（1）当我们对一个数据结构进行一个操作时，我们就需要一套算法。这就是数据结构和算法的关系。

（2）我总结：算法有2个层次。第一个层次是数学和逻辑上的算法；第二次个层次是用编程语言来实现算法。

（3）从逻辑上来讲，链表的逆序有很多种方法。这些方法都能实现最终的需要，但是效率是不一样的。彼此的可扩展性、容错性等不同。

（4）思路：首先遍历原链表，然后将原链表中的头指针和头节点作为新链表的头指针和头节点，原链表中的有效节点挨个依次取出来，采用头插入的方法插入新链表中即可。

（5）链表逆序 = 遍历 + 头插入

### 9.6.3、编程实战

```c
//第一种写法
void nixu(node *pH)
{
    node *pNew = pH->pNext;      //定义一个指针指向要移动的第一个节点

    node *pB = NULL;             //定义一个指针指向pH的下一个节点
    while(NULL != pNew->pNext)
    {
        pB = pNew->pNext;
        if(pNew == pH->pNext)
        {
            pNew->pNext = NULL;   //第一个节点将是新链表的最后一个节点								//让他指向NULL
        }
        else
        {
            pNew->pNext = pH->pNext;//将第二个节点塞到前一个节点的前面
        }
        pH->pNext = pNew; //让头指针指向你定义的指针指向的那个节点
        pNew = pB;  //将你定义的指针指向下一个你要移动的节点
    }
    
} 
//第二种写法
void nixu(node *pH)
{
    node *pNew = create_node(0);
    node *p = pH->pNext;
    node *pr = NULL;//定义一个指针指向pH的下一个节点
    while(NULL != p->pNext)
    {
        //p = p->pNext;
        pr = p->pNext;
        insert_head(pNew,p);
        p = pr;
    }
    insert_head(pNew,p);
    pH->date = pNew->date;
    pH->pNext = pNew->pNext;
    free(pNew);
}
```

***

## 9.7、双链表的引入和基本实现

### 9.7.1、单链表的局限性

（1）单链表是对数组的一个扩展，解决了数组的大小比较死板不容易扩展的问题。使用堆内存来存储数据，将数据分散到各个节点之间，其各个节点在内存中可以不相连，节点之间通过指针进行单向链接。链表中的各个节点内存不相连，有利于利用碎片化的内存。

（2）单链表各个节点之间只由一个指针单向链接，这样实现有一些局限性。局限性主要体现在单链表只能经由指针单向移动（一旦指针移动过某个节点就无法再回来，如果要再次操作这个节点除非从头指针开始再次遍历一次），因此单链表的某些操作就比较麻烦（算法比较有局限）。回忆之前单链表的所有操作（插入、删除节点、 遍历、从单链表中取某个节点的数·····），因为单链表的单向移动性导致了不少麻烦。

总结：单链表的单向移动性导致我们在操作单链表时，当前节点只能向后移动不能向前移动，因此不自由，不利于解决更复杂的算法。

### 9.7.2、解决思路：有效数据+2个指针的节点（双链表）

（1）单链表的节点 = 有效数据 + 指针（指针指向后一个节点）

（2）双向链表的节点 = 有效数据 + 2个指针（一个指向后一个节点，另一个指向前一个节点）

### 9.7.3、双链表的封装和编程实现

```c
//实现一个双向链表的封装
#include<stdio.h>
#include<stdlib.h>

typedef struct node
{
    int date;               //有效数据结构
    struct node *pPrev;     //前向指针，指向前一个节点
    struct node *pNext;     //后向指针，指向后一个节点
}node;


node *create_node(int date);

int main(void)
{
    node *pHeader = create_node(0);


    return 0;
}


node *create_node(int date)
{
    node *p = (node *)malloc(sizeof(node));
    if(NULL == p)
    {
        printf("malloc error\n");
       return NULL;
    } 
    p->date = date;
    p->pNext = NULL;
    p->pPrev = NULL;             //默认创建的节点，前向和后向的指针都指向NULL
    
    return p;

}
```

***

## 9.8、双向链表算法之节点插入

 ### 9.8.1、头部插入

```c
//头部插入
void insert_head(node *pH, node *new)
{
    node *p = pH;
    node *pN = pH->pNext;
    if(NULL != pH->pNext)   //判定插入时原链表是否有节点，如果有将老节							//点和新节点关联起来
    {
        new->pNext = pN;
        pN->pPrev = new;
    }
    p->pNext = new;
    new->pPrev = p;        
    
   
    pH->date += 1;
}
```



### 9.8.2、尾部插入

```c
//尾部插入
void insert_tail(node *pH, node *new)
{
    node *p = pH;
    while(NULL != p->pNext)
    {
        p = p->pNext;
    }
    p->pNext = new;
    new->pPrev = p;
    pH->date += 1;

}
```

***

## 9.9、双链表的算法之遍历节点

（1）双链表是单链表的一个父集。双链表中如何完全无视pPrev指针，则双链表就变成了单链表。这就决定了双链表的正向遍历（后向遍历）和单链表是完全相同的。

（2）双链表中因为多了pPrev指针，因此双链表还可以前向遍历（从链表的尾节点向前面依次遍历直到头节点）。但是前向遍历的意义并不大，主要是因为很少有当前当了尾节点需要前向遍历的情况。

（3）总结：双链表是对单链表的一种有成本的扩展，但是这个扩展在有些时候意义不大，在另一些时候意义就比较大。因此在实践用途中要根据业务要求选择适合的链表。

***

## 9.10、双链表的算法之删除节点

### 9.10.1、删除数据为date的节点

```c
//删除数据为date的节点
void del_date_node(node *pH,int date)
{
    node *p = pH;
    int i = 0;
    while(NULL != p->pNext)
    {
        p = p->pNext;
        if(p->date == date)
        {
            if(NULL == p->pNext)        //判断数据所在节点是否是尾节点
            {
                p->pPrev->pNext = NULL;
                //p->pPrev = NULL;      //这步可以没有，因为后面把这个									//节点给free掉了
                
            }
            else
            {
                p->pPrev->pNext = p->pNext;
                p->pNext->pPrev = p->pPrev;
                
                
            }
            free(p);
            pH->date -= 1;
            i++;
        }
        
    }
    if (i == 0)
    {
        printf("not fond this date\n");
    }
    
}
```

***

## 9.11、Linux内核链表

### 9.11.1、前述链表数据区域的局限性

（1）之前定义数据区域时直接就是int date；我们认为我们链表中需要存储的是一个int类型的数，但是实际上现实编程中连接中的节点不可能这么简单，而是多种多样的。

（2）一般实际项目中的链表，节点中存放的数据其实是一个结构体，这个结构体中包含若干个成员，这些成员加起来构成了我们的节点数据区域。

### 9.11.2、一般性解决思路：数据区封装为一个结构体

（1）因为我们链表实际解决的问题是多种多样的，所以内部数据区域的结构体构成的也是各种各样的，这也导致了不同的程序当中的链表总体构成是多种多样的。导致的问题是，我们无法通过一个广泛性的、普遍适用的操作函数来访问所有的链表。这就意味着我们设计一套链表就得写一套链表的操作函数（节点创建、插入、删除、遍历……）

（2）实际上深层次的分析发现：不同的链表虽然这些方法是不能通用的需要单独写，但是实际上内部的思路和方法是相同的，只是函数的局部地区有不同。（实际上就是说链表的操作是相同的，而是涉及到数据区域的操作是不相同的）

（3）鉴于以上两点：我们的一个理念就是，能不能有一种办法把所有链表中操作方法里共同的部分提取出来用一套标准方法实现，然后把不同的部分留这让具体链表的实现者自己处理。

### 9.11.3、内核链表的设计思路

（1）内核链表中自己实现了一个纯链表（纯链表就是没有数据区，只有前后指针）的封装，以及纯链表的各种操作函数（节点创建、插入、删除……）。这个纯链表本身自己没有任何用处，它的用法是给我们具体链表最为核心来调用。

### 9.11.4、list.h文件简介

（1）内核中核心纯链表的实现在include/linux/list.h文件中

（2）listh.h中就是一个纯链表的完整封装，包含节点定义和各种链表操作方法。

***

## 9.12、内核链表的基本算法和使用简介

### 9.12.1、内核链表的节点创建、删除、遍历等

（1）、去自习研究内核链表的程序

### 9.12.2、内核链表的使用实践

（1）、问题：内核链表只是纯链表、没有数据区域，怎么使用？

（2）、设计的使用方法是就内核链表作为将来整个数据结构的结构体的一个成员内嵌进去的。

```c
//在内核中编程
#include<linux/list.h>	//包含链表头文件地址

struct driver_info
{
    int date;			//驱动信息
};

//driver结构体用来管理内核中的驱动
struct driver
{
    char name[20];				 //驱动名称
    int id;						//驱动id编号
    struct driver_info info;	  //驱动信息
    struct list_head head;		  //内核内嵌链表成员
}

/*
*分析driver结构体，可知：前三个成员都是数据区域成员（就是我们之前简化为    *int date 的东西），第4个成员是一个struct list_head类型的变量，这就是一个*纯链表。
*本来driver结构体是没有链表的，也无法用链表来管理，但是我们driver内嵌的*head成员本事就是个纯链表，所以driver通过head成员给自己扩展了链表的功能。
*driver通过内嵌的方式扩展链表成员，本身不知有链表成员，关键是可以通过利用*head本身事先实现的链表的各种操作来操作head。
*最终效果：我们可以通过遍历head来实现driver的遍历；遍历head的函数在list.h *中已经事先写好了，所以我们在内核中遍历driver时就不用重复写了。、
*通过操作head来操作driver，实质上就是通过操作结构体的某个成员变量来操作整 *个结构体变量。这里面要借助container_of宏（就是根据结构体某个成员的地址得 *到整个结构体的地址）
*/
```

****

## 9.13、什么是状态机

### 9.13.1、有限状态机

（1）常说的状态机是有限状态机FSM。FSM指的是有有限个状态（一般是一个状态变量的值），这个机器同时能够从外部接收信号和信息输入，机器在接收到外部输入的信号后会综合考虑当前自己的状态和用户输入的信息，然后机器做出动作：跳转到另一个状态。
（2）考虑状态机的关键点：当前状态、外部输入、下一个状态

### 9.13.2、两种状态机：Moore型和Mealy型

（1）Moore型状态机特点是：输出只与当前状态有关（与输入信号无关）。相对简单，考虑状态机的下一个状态时只需要考虑它的当前状态就行了。

（2）Mealy型状态机的特点是：输出不只和当前状态有关，还与输入信号有关。状态机接收到一个输入信号需要跳转到下一个状态时，状态机综合考虑2个条件（当前状态、输入值）后才决定跳转到哪个状态。

### 9.13.3、状态机的主要用途：电路设计、FPGA程序设计、软件设计

（1）电路设计中广泛使用了状态机思想

（2）FPGA程序设计

（3）软件设计（框架类型的设计，譬如操作系统的GUI系统、消息机制）

### 9.13.4、状态机解决了什么问题

（1）我们平时写程序都是顺序执行的，这种程序有个特点：程序的大体执行流程是既定的，程序的执行是遵照一定的大的方向有迹可寻的。

（2）但是偶尔会碰到这样的程序：外部不一定会按照既定流程来给程序输入信息，而程序还需要完全能够接收并响应外部的这些输入信号，还要能做出符合逻辑的输出。

****

## 9.14、C语言实现简单的状态机

### 9.14.1、题目

​	开锁状态机。功能描述：用户连续输入正确的密码则会开锁，如果密码输入过程错误则锁会退回到初始状态重新计入密码，即：用户只需要连续输入出正确的密码即可开锁（输入错误不用撤销、也不用删除）

### 9.14.2、题目分析

（1）状态机来实现密码锁类似于有重来按键，实现效果就是用户输错了后锁中的状态机将会自动将锁置为初始状态，用户的下一次输入将会作为下一组输入密码的起始部分。状态机的这种思路硬件不用设计重来按键，而且能实现相同功能。

### 9.14.3、编程实战

```c
#include<stdio.h>

//给状态机定义状态集
typedef enum
{
    STATE1,
    STATE2,
    STATE3,
    STATE4,
    STATE5,
    STATE6,
    STATE7,
    
}STATE;

int main(int argc, char const *argv[])
{
    int num = 0;
    /*
     *current_state记录状态机的当前状态，初始为STATE1，
     *用户每输入一个正确的密码STATE就会走一步，一直到STATE走到STATE7后锁就开了
     *其中只要有一次用户输入对不上就回到STATE1
     */
    STATE current_state = STATE1;       //定义状态机初始状态为STATE1
    //第一步：实现一个用户循环输入密码的循环
    printf("please input password:\n");
    while(1)
    {
        scanf("%d", &num);
        printf("num = %d\n", num);
        
        //处理用户本次输入
        switch (current_state)
        {
            case STATE1:
                if(num == 1)
                {
                    current_state = STATE2;     //这就是用户输入对了一步，STATE就走一步
                }
                else
                {
                    current_state = STATE1;
                }
                break;
            case STATE2:
                if(num == 2)
                {
                    current_state = STATE3;     
                }
                else
                {
                    current_state = STATE1;
                }
                break;
            case STATE3:
                if(num == 3)
                {
                    current_state = STATE4;    
                }
                else
                {
                    current_state = STATE1;
                }
                break;
            case STATE4:
                if(num == 4)
                {
                    current_state = STATE5;     
                }
                else
                {
                    current_state = STATE1;
                }
                break;
            case STATE5:
                if(num == 5)
                {
                    current_state = STATE6;     
                }
                else
                {
                    current_state = STATE1;
                }
                break;
            case STATE6:
                if(num == 6)
                {
                    current_state = STATE7;     
                }
                else
                {
                    current_state = STATE1;
                }
                break;
        }
        if(current_state == STATE7)
        {
            printf("password is right\n");
            break;
        }
    }

    return 0;
}

```

***

## 9.15、多线程简介

### 9.15.1、操作系统下的并行执行机制

（1）并行就是说多个任务同时被执行。并行分微观上的并行和宏观上的并行。

（2）宏观上的并行就是从长时间段（相对于人来说）来看，多个任务是同时进行的；微观上的并行就是真的在并行执行。

（3）操作系统要求实现宏观上的并行。宏观上的并行有2种情况：第一种是微观上的串行，第二种是微观上的并行。

（4）理论来说，单核CPU本身只有一个核心，同时只能执行一条指令，这种CPU只能实现宏观上的并行，微观上一定是串行的。微观上的并行要求多核心CPU。多核CPU中的多个核心可以同时微观上执行多个指令，因此可以达到微观上的并行，从而提升宏观上的并行度。

### 9.15.2、进程和线程的区别和联系

（1）进程和线程是操作系统的两种不同软件技术，目的是实现宏观上的并行（通俗一点就是让多个程序同时在一个机器上运行，达到宏观上看起来并行执行的效果）。

（2）进程和线程在实现并行效果的原理上不同。而且这个差异和操作系统有关。譬如windows中进程和线程差异比较大，在linux中进程和线程差异不大（linux中线程就是轻量级的进程）。

（3）不管是多进程还是多线程，最终目标都是实现并行执行。

### 9.15.3、多线程的优势

（1）前些年多进程多一些，近些年多线程开始用得多。

（2）现代操作系统设计时考虑到了多核心CPU的优化问题，保证了：多线程程序在运行的时候，操作系统会优先将多个线程放在多个核心中分别单独运行。所以说多核心CPU给多线程程序提供了完美的运行环境。所以在多核心CPU上使用多线程程序有极大的好处。

### 9.15.4、线程同步和锁

（1）多线程程序运行时要注意线程之间的同步。

详细情况在：《3.linux应用编程和网络编程》

***

# 10、程序员和编译器之间的暧昧

## 10.1、编程工作的演进史

### 10.1.1、CPU需要的只是1和0组成的二进制

（1）不管编程怎么变，最终编程得到的可执行二进制程序都是给CPU运行的。CPU需要的只是按照CPU设计时的规律（机器指令）排布的一串二进制1和0组成的数字（机器码），CPU根本不关心这些二进制是怎么来的。

（2）这些二进制可能是一个很厉害的程序员直接用1和0拼出来的；也可以是用汇编语言编写最终编译得到的；也可以是用C语言编写最终编译得到的；也可以是用java C# php bash等语言编写然后解释得到的；

（3）编程工作的演进其实一直是在处理上一个层次段落：就是使用何种语言编写程序（用某种语言进行编程），然后如何把这种程序源代码转成二进制（编译器的发明）。

（4）CPU接收到一串1010序列后如何工作达到目的，这就是设计制造CPU的公司要考虑的事情了，与软件工程师完全无关。

### 10.1.2、早期的纸卡打孔编程者

（1）最早期的时候，CPU也很简单，指令集很少，二进制位数也不多。那时候编译器也没被发明，编程语言也没被发明，那时候就是用二进制直接编程的。

（2）总结：最早的编程没有语言也没有编译器，程序员直接使用二进制和机器（CPU）对话。

（3）这种方式的坏处就是不容易扩展，随着CPU的进一步复杂化，指令的变多，指令位数的变多，编程难度呈几何倍数增长。人的大脑慢慢就跟不上这个节奏。

### 10.1.3、编程工作的第一次革命：由二进制机器码到汇编语言

（1）第一次革命就是：发明了汇编语言。汇编语言的本质就是用一个符号来代替一串二进制。
MOV 10101010101010
SUB	01010101010101

（2）有了汇编语言之后，程序员就不用再去记忆二进制序列了。编程时只需要用汇编指令来编程即可，汇编指令就是一个符号（符号就是由文字构成的，如MOV）。因为人类大脑天生对文字符号更加友好，因此用符号编程更简单。

（3）用汇编语言编写的源程序不能直接给CPU运行，必须通过一个翻译过程，把源代码翻译成二进制序列才能给CPU。这个翻译的过程就叫汇编，执行翻译动作的就是汇编器。

### 10.1.4、编程工作的第二次革命：由汇编语言到C语言

（1）汇编语言也有一些不尽如人意的地方，譬如：没有可移植性。在这个CPU上写的汇编程序无法直接在另一个CPU上运行。因此汇编语言是和CPU一一对应的。

（2）为了可移植性于是乎发明了高级语言。第一个高级语言就是C语言。C语言进一步靠近人的思维，为人的思维发明了很多CPU没有的东西，譬如数组。最终的目的就是降低编程难度，让高级语言更接近人的思维，然后通过编译器、汇编器等的翻译将这些源代码变成二进制然后给CPU运行。

### 10.1.5、革命无穷尽、层次变更多

（1）在C语言之上还有更高级语言，譬如：C++、Java、C#、bash等。越往上越靠近人的思维，越往上语言本身提供的封装越多，越往上编程难度越低、语言的掌握越容易。

***

## 10.2、程序员、编译器、CPU之间的关系

### 10.2.1、CPU只认识二进制机器指令

（1）CPU是最终干活的，而CPU只认识只接受二进制。

### 10.2.2、人类喜欢符号而不是二进制

（1）人类的大脑本身不喜欢二进制而喜欢符号、文字。

（2）人类和机器之间天生有代沟，于是乎编程不容易。

### 10.2.3、连接人（程序员）与机器（CPU）的桥梁：编译器

（1）编译器降低了编程难度。编译器的代表就是编程语言，每一种编程语言都有对应的编译器，这个编译器的作用就是把这种语言的源文件编译成可执行程序。

（2）关键是：有了编译器（高级语言）之后，我们程序员就不再盯着CPU（二进制），而是改为盯着编译器（编程语言、编程语言的语法），所以我们学习编程的关键变成了学习编译器的习性，也就是编程语言的语法。

### 10.2.4、发明一门语言关键就在于发明它的编译器

（1）编译语言的关键就是编译器。yacc和lex工具就是用来发明编程语言的。

### 10.2.5、高级语言与低级语言的差别

（1）越高级的语言越靠近人类思维；越低级的语言越靠近机器的需要。

（2）人与机器总劳动量（总复杂度）守恒。人要是复杂一点机器就可以简单一点；人简单一点机器就需要复杂一点。这个规律描述的就是：编程语言越简单，人使用起来越简单，编译器设计起来就更复杂；编程语言越复杂、程序员使用起来越麻烦，则编译器设计越简单，CPU执行效率越高。

***

## 10.3、像编译器一样思考

### 10.3.1、语法是什么？语法就是编译器的习性

（1）编译器反应在编程中就是语法。
譬如1：
for (i=0; i<10; i++);
{
	xxx;
}

譬如2：
int i;		!!i;
解析：!在C语言中是逻辑取反的意思，逻辑取反意思就是0取反就是1，不是0的数取反就是0.
问题：让你用C语言编程实现：如果一个数i是0则返回0，如果不是0则返回1
一般实现：					if (i == 0){return 0;} else{return 1;}
或者可以用三母运算符：		(i==0)?(0):(1);
极客式写法：				!!i;

### 10.3.2、习得一门语言就像认识一个朋友

（1）从新开始认识一个人到成为好朋友，这里面要经历：时间、共事。

（2）学习一门编程语言也需要：时间、实践（共事）

### 10.3.3、学习编程语言要懂得换位思考

（1）预处理中处理程序注释、空行。

### 10.3.4、注意实践中的摸索和总结

（1）要点一：在实践中

（2）要点二：摸索

（3）要点三：总结