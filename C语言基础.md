# C基础入门

c语言基础大模块：

数据类型； 运算符；三种程序结构；函数；数组；指针；结构体、共用体、枚举。

## 1、概念：

### （1）源文件：

​			即源代码文件，c语言文件后缀名.c

### （2）头文件:

​			头文件后缀名.h（head，头），c语言代码由源文件和头文件组成。

### （3）关键字：

​			关键字时c语言征用的一些字，这些字在c语言中已经被征用好了，轮不到我们用。每个关键字都有自己的含义，我们必须弄懂所有的关键字才能看懂c语言。

关键字：

include  （包含）              头文件包含

int（integer,整数）           定义了整形这个数据类型

char （character, 字符）   字符型数据类型

float （浮点型）                 浮点型数据类型用来表示小数的类型

return（返回）                   函数调用返回

### （4）注释：

​			c语言中注释以//开头或者/*  */，注释是给程序员看的，不是给机器看的，编译器在编译程序的时候是看不到注释的。

### （5）符号：

​			c语言程序中包含很多符号，各种符号都有自己的含义，弄懂了才能看懂程序。

### （6）变量：

​			会变化的量，在c语言程序中用变量来计算。

### （7）函数：

​			函数是c语言的基本组成单位，一个c语言程序其实就是由很多函数组成的，每个函数用来完成一定的功能，函数可以调用别的函数来完成功能。函数的标准就是（），c语言中有个特使的函数时main	，这个函数时c语言的入口，其他函数只能直接和间接的被main调用。

### 1.2、c语言写代码的步骤

第一步：编辑源代码（使用编辑器）

第二步：编译。编译就是用编译器将源文件程序转成可执行程序的过程我们在Linux中一般用gcc

例如 gcc hello.c  帮当前的hello.c 文件编译，得到可执行文件名字叫a.out

也可以自己制定可执行文件的名字 列如 gcc hello.c -o hello

第三步：执行编译生成的可执行程序，执行方式 ./hello 

第四步：调试，当你执行后发现程序结果不对，这时候返回源代码进行修改，再编译执行，再看结果，直到结果正确。

***

## 2、VMWare共享文件夹

当我们裸机安装了Windows，并且再Windows中安装了虚拟机软件VMWare，并且在虚拟机软件中安装了Ubuntu后。我们一般在Windows中编辑源码，在Linux中编译，执行源代码。这时候就需要在Windows和Linux直接进行交互。

常用的方法是：

之前是通过smb服务器，现在通过VMWear的共享文件夹。

如何建立：

第一步：先在Windows中建立一个英文文件夹、

第二步：在VMWare中，菜单中虚拟机设置->选项->共享文件夹->添加文件夹路径

第三步：在Linux中，直接到/mnt/hgfs 这个目录下找到第二步设置的共享文件夹

***

## 3、C语言数据类型

### 3.1、整形

​	c语言中的整形对应对数学中的整数，整形变量是用来描述一个整数值的，整形变量经过计算后也只能是个整数（整形），不可能出现小数（浮点型）。

要求：要学会整形变量的定义，赋值，计算

​			要学会使用printf打印出整形变量的值，作为输出和调试。

c语言中整形有三种：

​	（1）int             整形

​	（2）short int    短整型（<=整形）

​	（3）long int     长整形（>=整形）

***

### 3.2、浮点型

​	c语言中浮点型对应数学中的小数。浮点型由float和double两种使用方法一样，不同在于表示范围和精度不同。float表示的精度低（小数点后6位），而double表示范围大，精度高（精确到小数点后16位）

范围是说表示的数的大小，是指这个数的分辨率有多细

注意：打印float型和double型是要用%f和%lf

***

### 3.3、字符型

​	字符型对应ASCII字符。ASCII字符是一种编码，就是用数字编码来表示一个符号的一种方法.

本质上说字符型也是整形，只是这些整形数被用来表示一些字符的的ASCII编码值，所以叫做字符型。字符型一般用8为二进制表示，无符号字符型范围是0~255。用char来定义	

字符型其实是一个比short还短的整形，所以他可以和int相运算

***

### 3.4、有符号数和无符号数

​	数学中数是由符号的，有整数和负数。所以计算机中的数据类型也是有符号的，分为有符号数和无符号数。

有符号数：

​	整形：signed int（简写int）

​			   signed long，也叫signed long int （简写long）

​		       signed short，也叫signed short int（简写short）

​			    signed (表示signed int)

​	浮点型：signed float（简写为float）

​				   signed double（简写为double）

​	字符型：signed char（简写为char）

无符号数：

​	整形:整形的无符号数用来表示一些编码之类的东西。

​			unsigned int（无简写）

​			unsigned long int（简写为unsigned long）

​			unsigned short int（简写为unsigned short）

​	浮点型：没有无符号的浮点数。小数一般只用在数学概念中所以都是有符号的。

​	字符型：字符型有无符号数

​				unsigned char（无简写）

注意：对于整形和字符型来说，有符号数和无符号数表示的范围是不同的。有符号数在计算机编码第一位是符号位其中需要将输入的是的二进制数除符号位之外进行反码和补码转换，再给计算机看。

例如：char  a=-13  它的二进制源码是1000 1011  其反码是 1111 0100 其补码是1111 0101  最后的补码才是给计算机的结果 而无符号数的源码、反码、补码都是同一个不需要转换。

列入字符型，有符号数范围是-128 ~ 127，无符号数范围是0~255

***

## 4、C语言常用运算符

### 4.1、数学运算符

#### 4.1.1、常见数学运算符

（+）      加号

（-）       减号

（*）       乘号

（/）       除号

（%）     取余，相除以后余数

（）		括号括起来优先级最高

#### 4.1.2、跟数学中意义不同的运算符

（=）	  赋值运算符，与数学中的等号完全不同，赋值运算符的作用是将右边的值（右值）赋值给左边的值（左值）。

（+=）	a=a+b；等同于  a+=b;

（-=）	 a=a-b；等同于  a-=b;

（*=）	a=a**b；等同于  a*=b;

（/=）	a=a/b；等同于  a/=b;

（%=）  a=a%b；等同于  a%=b;

#### 4.1.3、判断运算符

(==)		等于

(!=)		不等于

(>)		大于

(<)		小于

(>=)	   大于等于

(<=)	   小于等于

#### 4.1.5、++与--

++ ：  		a++；先赋值再运算；a=5;b=a++;//b=5

​				   ++a；先运算再赋值；a=5;b=++a;//b=6

--：			  a--；先赋值再运算；等同于 a=a-a；a-=1；

​				    --a；先运算再赋值；

注意：强调程序风格。

所谓程序风格，主要指的是写代码的格式，列如空格、空行、注释、头文件、函数头等。

​	越大的公司越注重程序风格，软件界公认的准则，程序风格不良好的程序是垃圾程序，拾废品；写出程序风格不良好的程序员是不合格的程序员。

***

## 5、程序结构

程序调试方法：在不同分支或者需要处自定打印一些数据然后运行后根据打印内容，来分析程序的实际走向和运行情况，依次来做调试分析。

注意：当我们定义一个局部变量，但是没有赋初始值，这个值是随机的。

在程序结构里，一共有三种程序结构：顺序结构、选择结构（分支结构）、循环结构

顺序结构：按照事物本身特性，必须一个接着一个的完成。

选择结构：到某个节点后，会根据一次判断结果来决定之后走哪个分支。

循环结构：循环结构有个循环体，循环体是一段代码，对于循环结构来说，关键在于根据判断结果来决定循环次数。

总结：对于顺序结构来说，不需要判断，因为下一句指令就是你要执行的。对于循环与选择结构来说，都需要进行判断。然后根据判断结果来决定怎么办。

逻辑上有一种类型，叫bool类型（又写作boolean类型，中文叫布尔类型），布尔类型只有一个值，真和假。

c语言中有以下一些判断运算符

(==)		等于

(!=)		不等于

(>)		大于

(<)		小于

(>=)	   大于等于

(<=)	   小于等于

使用这些判断运算符，可以写出一个判断表达式，这个判断表达式最终的值就是一个bool类型。这个判断表达式的值就决定了我们的选择结构如何选择循环结构如何循环。

***

### 5.1、选择结构：

c语言中选择结构一共两种：

#### 第一种：if  else

引入关键字：if   else   else if

```c
if (bool值)
{
	代码段1
}
else
{
	代码段2
}			//如果bool值为真，则执行代码段1，否则执行代码段2

if (bool值1)
{
	代码段1
}
else if (bool值2)  //开头的if和结尾的else都只能有一个，中间的                     //else if可以有很多个
{
	代码段2
}
else
{
    代码段3
}            //如果bool值1为真，则执行代码段1，否则判断bool值2              //是否为真，若为真就执行代码段2，否则执行代码段3
```

***

#### 第二种：switch case

关键字：switch; case; break; default;

注意：

1、case中必须是常数，而且必须是整形（不能是float ；double，可以是int char）

2、一般说，每个case后面的代码段后面都要加上break

3、一般来说case后面都会有default，语法上来说可以不加default，但是建议在写代码时加上

switch case 和if else对比

1、if else 适合对比条件复杂但是分支较少，switch case适合对比条件简单但是分支较多的情况

2、所有的选择结构，其实都可以用if else 实现；但是只有部分才能用switch case实现；在适合使用switch case会优先使用switch case ，如果不适合使用switch case，则不得不使用if else

```c
switch (变量)
{
    case 值1:代码段1；break;//注意：case后面一定是常量
    case 值2:代码段2；break;
        :::::::
    default:代码段n；
}//switch括号里面变量的值和case后面的常量的值相等，就执行case后  //面的语句,遇到break结束switch/case语句 如果switch里面变量的值 //和case后面常量的值都不相等，就执行default后面的语句。
//case后面没有break,就会继续往下执行，即使后面的常量和变量不匹 //配，也会向下执行。直到遇到break结束switch/case
```

//题目：输入数字1，打印a；输入2，打印b；依次类推

```c
//switch case 演示
#include<stdio.h>
int main (void)
{
    int i;
    switch (i)
    {
        case 1: 
            printf ("a\n");
            break;
        case 2: 
            printf ("b\n");
            break;
        default:
            printf("c");
    }
}
```

***

### 5.2、c语言中的循环结构

c语言中常用的循环结构有三个：for循环、while循环、do while循环。

#### 5.2.1、for循环

for(循环控制变量初始化;循环终止条件;循环控制变量增量)
    {
        循环体；
    }

for循环执行步骤：

1、先运行循环控制变量初始化

2、执行循环终止条件，如果判断结果为真则执行第三步否则跳出循环

3、执行循环体

4、执行循环控制变量增量，转入第二步。

```c
//for循环演示
#include<stdio.h>
int main(void)
{               //使用for循环来计算，可以避免重复输入等机械操作
    int a, sum;
    sum=0;
    for (a=1; a<=100; a++)
    {
        sum+= a;
    }
    printf("sum=%d",sum);
}
```

注意：

1、for（）中的三部分

标准的for循环，应该把循环控制变量的初始化和增量都放到（）当中，并且在循环体中决定不应该更改循环控制变量（可以引用它的值，但是不应该改变它）。

***

#### 5.2.2、while循环

总结：不管哪种循环结构，都不能缺少一些要素：

循环控制条件初始化，终止条件，循环控制变量增量，循环体。

不同的循环方式都有这些只是格式不同，表现形式不同，放的地方不同，可读性不同，设计难度不同。

```c
//while循环演示-----1-100所有奇数和
#include<stdio.h>
int main(void)
{
    int i, sum;   
    i = 1;
    sum = 0;        //循环初始化
    while (i<100)   //终止条件
    {
        sum += i;
        printf("sum = %d", sum); //循环体
        i += 2;                  //循环控制变量增量
    }
     
}
```

while循环的执行步骤：

0、首先进行循环初始化，这一步其实不属于while循环本身

1、先判断终止条件是否满足 如果是真 则进入第二步，否则直接退出

2、执行循环体，然后转入第一步

***

#### 5.2.3、do while循环

```c
//do while循环演示-----1-100所有奇数和
#include<stdio.h>
int main(void)
{
    int i, sum;       
    i = 1;    
    sum = 0;        //循环初始化    
    do   			  
    {        
        sum += i;        
        printf("sum = %d", sum); //循环体        
        i += 2;                  //循环控制变量增量    
    }  while (i<100);         //终止条件，分行特别重要别忘加了  
}
```

do while 循环执行步骤：
0、首先进行循环初始化，这一步其实不属于do while循环本身

1、执行循环体（循环控制变量的增量是循环体的一部分）

2、判断终止条件是否满足 如果是真 则进入第一步，否则立即退出

总结while和do while 循环的不同：while循环是先判断后执行，do while是先执行后再判断等循环开始之后其实都一样。

***

## 6、函数

​	截至目前，已经学习的数据类型，运算符，三种数据结构，已经可以完成一些c语言的程序了，但是不足之处在于只能写简单程序，写不了复杂程序。

当程序简单的时候，一个人可以用一个main函数搞定功能，当程序变成复杂的时候，超出了人的大脑承受范围，这时候逻辑不清了，这时候就需要把一个大程序分成许多小的模块来组织，于是有了现在的概念叫做函数。

函数是c语言代码的基本组成部分，它是一个小的模块，整个程序是由很多功能独立的模块（函数）组成的。这就是程序设计的基本分化方法。

之前接触过的函数：

main：c语言中所谓的主函数，主函数是一个特别的函数，特别之处在于，一个c语言程序必须有且只有一个main函数。c语言规定，一个c语言程序是从主函数开始执行到主函数执行完结束

printf：函数作用是用来在标准输出中打印信息。这个函数是c语言标准库里提供的库函数。在c语言中写代码时可以引用库函数，但是必须使用#include引用这个库函数所在的头文件。

***

### 6.1、用函数写程序的关键

```c
//程序演示,计算器
#include<stdio.h>
int add(int a, int b);
int sub(int a, int b);
int mul(int a, int b);
int div(int a, int b);			//函数的声明，后面必须有分号
int main(void)
{
    int a, b, sum;
    char c;
    printf ("please input number：")；
    scanf ("%d %c %d", &a, &c, &b);
    switch (c):
    {
        case '+':
        	printf ("sum = %d", add(a, b));//函数的调用
        	break;			            
        case '-':
        	printf ("sum = %d", sub(a, b));
        	break;
        case '*':
        	printf ("sum = %d", mul(a, b));
        	break;
        case '/':
        	printf("sum = %d", div(a, b));
        	break;
    }
    			
    
}
//函数的定义
int add(int a, int b)
{
    return a + b;		//函数体，实际上就是函数的实现
}
int sub(int a, int b)
{
    return a - b;
}
int mul(int a, int b)
{
    return a * b;
}
int div(int a, int b)
{
    return a / b;
}
```

函数的定义：函数的定义是关键，是这个函数的实现。函数的定义中包含					 了函数体，函数体里的代码段决定了这个函数的功能。

函数的声明：函数声明实际上叫函数原型声明，函数的原型包含三部分：函数名，返回值类型，函数参数列表。通俗讲这个函数叫什么，接受什么类型的几个参数，返回一个什么样的值。

作用是告诉使用者，这个函数使用时应该给它传递什么样的参数，它会返回什么类型的返回值，这些东西都是写函数的人在函数的定义中规定好的，必须遵守它的规定。

函数的调用：就是使用函数名来调用函数来实现功能，调用时必须按照参考原型给函数传参数，然后从函数得到适当的返回值作为结果。

***

### 6.2、函数的参数

形参：形式参数的简称。在函数定义和函数声明中的参数列表中的参数，都是形参

实参： 实际参数的简称。在函数调用中，实际传递的参数才是实参。

注意：实参给形参传递参数的时候，按顺序传参的，不是按照名字。

​		   就是说实参的第一个参数实际传给了形参列表的第一个形参，实参                                                                    的第二个参数传给了形参列表的第二个形参，以此类推。

​			实参的名字和形参的名字没有关系，只时按照顺序依次赋值传参而     已。

​			实参的类型必须和形参的类型相同，否则就有可能出错。

函数调用的过程，其实就是将实参传递给形参的一个过程。这个传递实际上是一次拷贝。实际上传递参数时，实参（本质是一个变量）本身并没有进入函数内，而是把自己的值复制了一份给了函数中的形参，在函数中参与运算。这种传参方法，就叫做传值调用。

### 6.3、函数的返回值

关键字：return

解释：当函数执行完后，会给调用该函数的地方返回一个值，这个值的类型就是函数声明中返回值类型，这个值就是函数体中最后一句 return xxx；返回的那个值。

***

### 6.4、函数名，变量名

第一点：起名的时候不能随意，要遵守规则。这个规则有两层；第一层是合法，第二层是合理。合法就是符合c语言中命名规则。合理是起变量名起的好，人一看就知道什么意思，一看就知道这个函数是干嘛的。而且优美好记。

第二点：c语言中，所有的符号都是区分大小写的

第三点：c语言函数变量名的命令习惯。没有固定的结论，有多种使用广泛的命令方式。

一种是Linux中的命名习惯	student_age	str_to_int

另一种是骆驼命令法			stdentAge		StrToInt

***

## 7、数组

​	到目前为止，我们学习了c语言的基本数据类型：整形、浮点型、字符型。再往后就是复合数据类型。

​	所谓的复合数据类型，是指由简单数据类型，经过一定的数据结构封装，组成新的数据类型。例如数组、结构体、共用体

### 7.1、为什么需要数组

数组就是数组成一个组，数就是一个数据类型的变量

```c
/*  没有数组前定义多个变量，并且每个变量有自己的变量名，之后用变   量名来操作变量
int a, b, c, d;
a = 1;
b = 2;
c = 3;
d = 4;
*/	
   
int a[4];	//定义一个数组a，里面有4个int元素
a[0] = 1;	//之后用a[0];a[1]......来访问数组中的变量。
a[1] = 2;
a[2] = 3;
a[4] = 5;

```

### 7.2、怎么定义数组

int a[4];	 	数组中的元素类型	数组名[数组元素个数]

总结：数组中的所有元素必须是同一个数据类型，不可能在一个数组中存储两个不同的数据类型的数。

***

### 7.3、如何使用数组

数组定义是整体定义。但是使用时不能作为整体使用，使用时必须拆开使用数组中的各个元素。

列如数组 a[4]：

​	使用其中四个元素，分别是a[0], a[1]........，其中[ ]中的数字叫做数字下标（index 索引），下标是我们访问数组各个元素的指引。下标为0代表数组中第一个元素，下标1是数组第二个元素，如果数组长度为n，下标最后一个是n-1。访问数组是要特别注意下标是从0开始的，如果下标超过n-1，就会产生越界访问，结果是不可预期的。

***

### 7.4、数组的初始化

初始化（initinalize 简写 init），是为了让对象有一个预定的初始化状态。

#### （1）变量的初始化：

​	当一个局部变量定义时没有初始化，它的值是随机的。这个如果没有注意可能会导致程序出错。

方法：

1、在定义过后明确的给它赋值，使用=运算符

2、在定义变量时，同时进行初始化。

```c
#include<stdio.h>
int main(void)
{
    int a;
    a = 0;	    //第一种 先定义变量，之后对它赋值
    
    int a = 0;  //第二种 定义的同时进行初始化
}
```

总结：

1、一般来说，只要你记得显示赋值，则两种方式没有不同。但是第二种定义同时进行初始化更好一些，因为这个定义的时候就有了固定值，即使之后忘记赋值也不会造成结果随机的。

2、一般情况下，定义的同时都将它初始化为0.局部变量定义的同时初始化为0，这是写代码的好习惯。

#### （2）数组的初始化

第一种：完全初始化

第二种：不完全初始化，初始化式中值从a[0]开始，一次赋值，不足的默认用0填充赋值。

```c
#include<stdio.h>
int main(void)
{
    int i = 0;
    int a[3] = {2, 3, 4};//完全初始化
    int a[3] = {3};      //不完全初始化
    int a[3];		    //没有初始化
    int a[3] = {[2] = 100};//gcc中独有的给特定位赋值，其余为0
}
```

***

### 7.5、不同数据类型数组

int a[5];					//整形数组

float a[5];				//浮点型数组

double a[5];			//双精度浮点型数组

char a[5];				//字符型数组

程序在环境中运行时，需要一定的资源支持。这些资源包括：CPU（运算能力）、内存等，这些资源一般有运行时的环境（一般是操作系统）来提供，列如我们在Linux系统上./a.out 运行程序时Linux系统为我们提供了运算能力和内存。

程序越庞大运行时消耗的资源越多，列如内存占用，越大的程序，占用的内存越大。占用内存时其中之一，就是我们在程序中定义的变量。

c语言程序中变量的实质就是内存中的一个格子。当我们定义（创造了一个变量）了一个变量后，就相当于在内存中得到了一个格子，这个格子的名字就是变量名，以后访问这个内存格子就使用该变量名就行了，这就是变量的实质。

数据类型的实质就是内存中格子的不同种类

列如在32位机器上：

短整型格子（short）				 占用2字节空间	16位

整形格子（类型就是int）  		占用4字节空间	32位

单精度浮点型格子（float）	   占用4字节空间	32位

双精度浮点型（double）	       占用8字节空间	64位

字符型格子（char）			      占用1字节空间	8位

字节：对于8个二进制位

***

### 7.6、sizeof运算符

作用：返回一个变量或者一个数据类型的内存占用长度，以字节为单位。

```c
#include<stdio.h>
int main(void)
{	int len;
 	//测试类型占用内存
    len = sizeof(int);			//4个字节
    printf("len = %d", len);	//输出int所占用内存的字节长度
    
    //测试变量占用内存
    double d;
    len = sizeof(d);
    printf("len = %d", len);
 
	//测试数组占用内存   
    int a[5];
    len = sizeof(a)				//5 * 4 = 20字节
    printf("len = %d", len);	//一共5个数每个数占用4个字节
 
 	len = sizeof(a) / sizeof(a[0]);//测试数组里面有多少元素
}


```

***

### 7.7、字符数组以及初始化

```c
#include<stdio.h>
int main(void)
{
    int i;
    /*
    char a[5] = {'a', 'b', 'c', 'd', 'e'};定义并初始化数组
    char a[5] = {97, 98, 99, 100, 101}; 
    char a[] = {97, 98, 99, 100, 101}; 和上面效果是一样的
    char a[] = "abcde";   用字符串初始化字符数组，用双引号
    */
    char a[5] = {'a', 'b', 'c', 'd', 'e'};
    char b[5] = "abcde";
	printf("sizeof(a) = %d	sizeof(b) = %d", sizeof(a), sizeof(b));
    return 0;//a[5]的字节为5，b[5]的字节为6
}
```



在c语言中引用一个字符串的时候，应该用双引号括起来，例如"abcde"

"abcde"实际上有6个字符，分别位‘a’， ‘b’， ‘c’， ‘d’， ‘e’， ‘\0’

 ‘\0’ 这个字符是ASCII码表中的第一个字符，它的编码是0，对应的字符是空字符（不可见字符，无法显示，一般用转义字符来显示列如‘\n’为回车符 ‘\t’代表Tab符，‘\0’代表空字符）

‘\0’ 是c语言中定义的字符串的结尾标准。所有，当c语言程序中使用“abcde”这种方式初始化时，编译器会自动在字符 ‘e’ 后面添加一个‘\0’。于是变成了6个字符 

单个字符的输入输出：

getchar :从终端上接收一个字符，并通过返回值输出；

putchar：打印getchar返回的值；

```c
#include<stdio.h>

int main(void)
{
    char ch;
    ch = getchar();		//用接受的字符给定义的变量赋值
    putchar(ch);		//输出变量的字符
    putchar('\n');
        
}
```

***

## 8、指针

​	指针全称指针变量，其实质是c语言中的一个变量，这个变量很独特，通常它的值会被赋值为某个变量的地址值（p = &a），然后我们可以使用 *p来间接的访问p指向的那个变量。

```c
#include<stdio.h>
int main(void)
{
    int a = 20;
    int b = 0;
    int *p;				//定义了一个int型的指针变量p
    p = &a;				//将a的地址值赋值给p
    //*p = 111;			//代表指针变量p所指向的那个变量
    					//相当于a=111
    b = *p;
    printf("a = %d", a);	//结果是111
    printf("b = %d", b);	//b的值就是20
}
```

***

### 8.1、为什么需要指针

​	指针存在存在的目的就是间接访问。有了指针之后我们访问变量a不必通过a这个变量名来访问。而是通过p = &a;*p = xxx 的方式间接访问变量a。

***

### 8.2、两个重要的运算符号

&和*

*：指针符号。指针符号在定义和指针操作的时候，解析方法是不同

int *p；   定义指针变量p，这里的 *p含义不是代表指针变量p所指向的那个变量，在定义时这里的 *号含义时告诉编译器这是一个指针

&a;		代表变量a的地址值

int p；	含义是p是一个整形变量

int *p；   含义是p是一个指针变量，该指针指向一个整形数

&p；		代表指针变量p本身所在的地址值。

*a；		代表把a看作一个指针。 *a表示这个指针所指向的变量

使用指针的时候，*p则代表指针变量p所指向的那个变量

***

### 8.3、指针的定义和初始化

指针既然是一个变量，那么肯定可以定义，也可以初始化

第一种：先定义再赋值

·	int *p；  //定义指针

​	p = &a；//给p赋值

第二种：定义的同时初始化

​	int *p = &a；//效果等同于上面的两句（只能定义的时候这么写）

```c
#include<stdio.h>
int main(void)
{
    int *p = &a;//定义指针变量p的同时初始化。
    int a = 20;
    int *p;
    *P = &a;//错误写法！！，因为*p这个符号只有在定义指针变量时表示             //p是一个指针，在其他地方出现时，*p符号的含义都是p所             //指向的变量,所有写法错误
    p = &a;//正确写法，给指针p赋值
}
```

***

### 8.4、各种不同类型的指针

​	指针变量本质上是个变量，指针变量的类型属于指针，int *p；定义了一个指针类型的变量p，这个p所指向的那个变量是个int类型的。

```c
#include<stdio.h>
int main(void)
{
    float a = 23;
    int *p = &a;//错误的，类型不匹配
}
```

不同类型指针的命名方式：

int *pInt;					//pInt 是指针变量 指向的时int类型的

char *pChar;			//pChar 是指针类型的 指向的是char类型的

float *pFloat;			//pFloat 是指针类型的 指向的是float类型的

double *pDouble;	//pDouble 是指针类型的 指向的是double类型的

各种指针类型和他们所指向的变量类型必须匹配，否则结果未知。

***

### 8.5、指针定义的两种理解方法

int *p；

第一种：首先看到p，这个是变量名，其次看到p前面的*，说明这个变量是个指针变量，最后， *p前面有个int，说明这个变量指向的是一个int型的数据。

char * ( *( *pfunc)[ ])(char * ,char *)	类似的复杂表达式都可以用以上方法分析。

第二种：首先看到p，这份是变量名，其次看到 p前面的int * ，把 int * 作为整体来理解，int * 是一种类型（复合类型），该类型表示一种指向int 类型数据的指针。

```c
#include<stdio.h>
int main(void)
{
    int a = 23;
    int *p1;
    int* p2;
    int * p;		//三种方式都可以，效果都一样
}
```

总结：第二种方法便于理解，但是不够本质；建议用第一种方法来理解，因为这中思维过程可以帮助我们理解更复杂的表达式。

***

### 8.6、指针和数组的初步结合

```c
#include<stdio.h>
int main(void)
{
    int a[5] = {1, 2, 3, 4, 5};
    int *p;
    p = &a;			//编译报警告，但是执行结果是1
    p = &a[0];		//相当于p = &(a[0]),编译正确，执行结果是1
    p = a;			//编译正确，执行结果是1
    a = p;//编译报错，因为数组名是个常量，所以不能被赋值，所以数组			//名不能做左值
    printf("*p = %d", *p);
}
```

数组名：做右值时，数组名表示数组的首元素地址，因此可以直接赋值给指针。

如果有 int a[5]；则a和&a[0]；都表示数组首元素的地址。

而&a则表示数组的首地址。

注意数组首元素的地址和数组的地址是不同的。前者是数组元素的地址，后者是数组整体的地址。两个的含义是不相同的，但是数值上是相同的。 

根据以上，我们知道可以用指针指向数组的第一个元素，这样就可以用间接访问的方式去逐个访问数组中的各个元素，这样访问数组就有了两种方式。

用数组的方式依次访问：a[0]		a[1]		a[2]		a[3]		a[4]

用指针的方式依次访问：*p		*(p+1)	*(p+2)	*(p+3)	*(p+4)

***

### 8.7、指针与++ -- 符号进行运算

​	指针本身也是一个变量，因此也可以进行运算，但是指针变量本身存的是某个其他变量的地址值，因此该值进行乘除取余等运算是没有意义的。两个指针变量相加本身也没有意义，相减是有意义的。指针变量+1、-1是有意义的。+1代表指针所指向的格子向后移动一格，-1代表指针所指向的格子向前移动一格。

*p++ 就相当于 *(p++)，代表指针p先与++结合再与 *结合。

​	解释：++先跟p结合，但是因为++后置的原因，其本身的含义是先运算再赋值（运算指的是p++整体和前面的* 进行的运算，赋值指的是p+1），所以实际上 *p++符号整体对外表现的值是 *p的值，运算完成后再加1。所以 *p++等同于： *p；p+=1；

*++p而当同于++p； *p；

(*p)++，使用（）强制将 * 和p结合，只能像计算 *p，然后对 *p整体的值++

++(*p)，先 *p取值，再前置++，该值+1后作为整个表达式的值

总结：++符号和指针的结合，总共只有上面四种情况。--符号与++情况类似。 

```c
#include<stdio.h>
int main(void)
{
    //指针+1，表示下一格
    int a[5]={1, 2, 3, 4, 5};
    int *p;
    p = a;
    p += 1;
    printf("*p = %d", *p);//输出结果为2 = a[1];
    printf("*p++ = %d", *p++);//输出结果还是1，++后置先运算再+1
    printf("*++p = %d", *++p);//这样结果就是2，++前置先+1再运算
    printf("++(*p) = %d", ++(*p));//结果是2，先*p取值后给值+1
}
```

***

### 8.8、函数传参中使用指针

`int add(int a, int b)`	函数传参使用了int型数，其本身是数值型。实际调用该函数时，实参将自己拷贝一份并将拷贝的传递给形参，实参自己是不参与的，所以在函数中是没法改变实参的。

```c
#include<stdio.h>

int main(void)
{
    int x, y;
    x = 5;
    y = 3;
    printf("before swap x = %d, y = %d", x, y);
    //swap(x, y);
    swap_pointer(&x, &y);
    printf("after swap x = %d, y = %d", x, y);
}
//在函数内部交换值
//实际测试结果失败，并没有交换
//原因：c语言中，函数调用时，实参传递给形参实际上是传值调用，也就是 //说，实参x和y将自己的值拷贝了一份传给形参a和b，在子函数swap中实 //际上交换的是a和b，而不是实参x和y，因此函数执行完后，x和y的值没 //变，并没有别交换。
int swap(int a, int b)
{
    int temp;
    temp = a;//a时swap内的形参，实际调用时得到的时实参x的一份拷贝
    		//只时和x的值相等而已，所以时不能访问到x的
    a = b;
    b = temp;
    return 0;
}
//这时候就需要用到指针
//测试结果 交换成功
//原因：c语言函数调用时，一直是传值调用。也就是实参传递的一直是实参 //的拷贝,但是本函数中的实参和形参并不是x和y，而是x和y的地址值。这样 //让我在函数中通过间接访问*p的方式，在函数内访问到了函数外面调用时 //的实参
int swap_pointer(int *p1, int *p2)
{
    int temp;
    temp = *p1;//实际调用时，p1得到的是实参是x的地址，*p1代表x
    *p1 = *p2;
    *p2 = temp;
    return 0;
}
```

***

## 9、结构体、共用体、枚举、宏定义、预处理

### 9.1、结构体

#### 9.1.1、什么是结构体

​	没有结构体之前，在c语言中数据的组织依靠：变量+数组。最简单的时候，只需要使用基本数据类型（int char float double）来定义单个变量，需要几个变量就定义几个。后来情况复杂了，又是需要很多意义相关的变量这时候数组出现了。数组解决了需要很多类型相同、意义相关的变量的问题。数组最大的不足在于，一个数组只能存储很多数据类型相同的变量。所以当碰到需要封装几个不同类型的变量的时候，数组就无能为力了。这时候就需要结构体了

***

#### 9.1.2、结构体的定义：

​	结构体就是一种里面包含很多元素的集合，这些元素的数据类型可以相同也可以不同。所以结构体是一种数据封装的方法。结构体存在的意义就是把很多数据类型不相同的变量封装到一起，组成一个大的新的数据类型。

数据结构：把庞大复杂的数据用一定的方式组织管理起来，便于操作（查找、增加、删除）这就叫数据结构。

***

#### 9.1.3、结构体和数组的关联：

​	数组是一种特殊的结构体，特殊之处在于封装内的各个元素类型是一样的。结构体和数组都是对一些子元素的封装，因此定义的时候都是封装作为整体的定义，但是使用的时候，都是使用封装中的子元素。一般结构体变量和数组变量都不会作为整体操作。

***

#### 9.1.4、结构体使用步骤：

第一步：定于结构体类型。结构体类型的定义是在函数外面（函数外面==全局）的

第二步：定义结构体的变量，使用第一步定义的类型来定义结构变量体。

第三步：使用变量，实际上使用结构体变量的时候，使用的是结构体变量中封装的各个子元素而不是结构体变量本身。

关键字：struct

```c
//题目：将学校中学生的姓名、性别、学号
#include<stdio.h>
//注意：
//1、结构体的定义是在函数外面，不是里面
//2、结构体定义的是一个新的组合类型，不是变量，也不消耗内存。
//	稍后在定义变量的地方，再使用该结构体来定义变量。
struct Student
{
  char name[20];		//学生姓名
  unsigned int num;		//学生学号
  int IsMale;		    //性别
};					   //注意这里的分号不能少

int main(void)
{
    struct Student s1;	//s1是变量，类型是struct Student
    //给结构体变量赋值
    s1.name[0] = 'J';//s1代表结构体 name[0]代表结构体里的子元素
    				//"." 是用来连接结构体变量名和子元素的
    s1.name[1] = 'i';
    s1.name[2] = 'm';
    s1.name[3] = '\0';
    s1.num = 123;
    s1.IsMale = 1;
    //打印检验
    printf("s1.name = %s, s1.num = %d, s1.IsMale = %d\n", 				s1.name, s1.num, s1.IsMale);
    return 0;
}
```

***

#### 9.1.5、结构体的初始化

结构体变量和普通变量一样，作为局部变量时，如果定义的时候无初始化也无显式赋值，则结构体变量里面子元素的值是随机的。

```c
#include<stdio.h>

struct Mystruct
{
    int a;
    int b;
    int c;
    int d;
};

int main(void)
{
    struct Mystruct s = {2, 3, 4, 5};		//ok
    struct Mystruct s = 
    {
        s.a = 1,
        s.b = 2,
        s.c = 3,
        s.d = 4,
    };				//部分ok，只能从头到尾依次初始化不能遗漏，  					//不能使用
    struct Mystruct s =
    {
        .a = 1,
        .b = 2,
        .c = 3,
        .d = 4,
            
    };		//ok的 且可以遗漏某个变量 “.”不能省略
}
```

发现两种初始化方式。

第一种：完全初始化。{xx，xx，xx};

第二种：不完全初始化。{.a=xx, .b=xx, .c=xx, .d=xx};

***

### 9.2、共用体（union，联合，联合体）、

关键字：union

​	共用体union在使用形式上和定义上，和结构体struct很形似，但是两种数据结构是完全不同的两类东西。

结构体，是对多个数据的组合和封装

共用体，共用体中只有一个东西，只是他被好几个名字（和类型）共用

```c
#include<stdio.h>
//定义共用体
union Myunion
{
    int a;
    char c;
    float f;
};

int main(void)
{
    union Myunion u1;	//使用自定义的union类型定义变量
    u1.a = 123;
    
    printf("u1.a = %d, u1.c = %d.\n", u1.a, u1.c);
    return 0;
}
```

结构体和共同体的理解

```c
#include<stdio.h>

struct Male
{
    int age;
    char name[20];
    int bask;
};

struct Female
{
    int age;
    char name[20];
    int dance;
}

union student
{
    struct Male m;
    struct Female f;
};

int main(void)
{
    union student s[30];//数组，定义一个班的学生
    s[1].m.bask = 47;
    s[2].f.dance = 50;
}
```

***

### 9.3、宏定义

```c
#include<stdio.h>
#define N (1111)		//N 就是宏定义 值需要用括号括起来

int main(void)
{
    int a;
    a = 123;
    a = N;
    printf("a = %d", a);
    
    int a[N]={1,2};			//方便修改N值
    printf("sizeof = %d", sizeof(a));
    return 0;
}
```

`#define N 1111`  //宏定义的格式

1、宏定义一般是在函数的外面

2、宏定义必须先定义后使用。不然就会报错

3、宏定义中，宏的名字一般用大写，不是语法规定的是约定俗成的

为什么使用宏定义：

​	在c语言中一般使用常数时，都不是直接使用的，而是先把这个常数定义为一个宏，然后再程序中使用该宏名。这样的好处是，等我们需要修改这个常数的时候，只需要在宏定义处修改一次就可以了。而不用到代码中到处寻找。

```c
//题目：使用宏定义定义一年有多少秒
#include<stdio.h>
#define SEC_PER_YEAR (365 * 24 * 60 * 60)UL	//定义的值需要括          //号，后面的UL表示将其强制定义为unsigned long 的数据类型

int main(void)
{
    printf("%ld\n", SEC_PER_YEAR);
}
```

***

### 9.4、枚举

关键字：enum

```c
//定义枚举类型
#include<stdio.h>

enum week
{
    SUN,
    MON,
    TUE,
    WEN,
    THU,
    FRI,
    SAT,
};

int main(void)
{
    enum week today; //使用enum week类型，定义一个枚举变量today
    today = SAT;
    switch(today)
    {
        case SUN:
            printf("0\n");
            break;
        case MON:
            printf("1\n");
            break;
        case TUE:
            printf("2\n");
            break;
        case WEN:
            printf("3\n");
            break;
        case THU:
            printf("4\n");
            break;
    }
       
}
```

***

## 10、修饰符

### static:静态修饰符

static修饰全局变量时：

​	只能在本文件中进行访问

static修饰局部变量时：

​	1、让局部变量拥有全局变量的特点（生命周期延长，作用域不变）

​	2、静态局部变量只需要初始化一次

​	3、静态局部变量会随着程序结束而结束

static修饰函数时：

​	1、只能够在本文件中访问该函数。

​	

### 访问修饰符

​	const + 数据类型 + 变量名：const修饰变量，将变量变为常量

​	auto：变量定义的时候的默认修饰符，可以不用写。

***

#   C语言进阶篇

## 1、数据类型

### 1.1、基本数据类型

数据类型分两类：基本数据类型+复合类型

基本类型：char  short  int  long  float  double

复合类型：数组	结构体	共用体	类（C语言没有，C++有）

#### 1.1.1、内存占用与sizeof运算符

数据类型就好像一个一个模子，这个模子实列化出C语言的变量，变量存储在内存里，需要占用一定的空间的，占用多少空间是由变量的数据类型决定的。

每种数据类型在不同机器平台上占用的内存是不同的。我们一般说的时候都是以32位的CPU为默认的硬件平台来描述的。

char		1字节			8位

short	   2字节			16位

int			4字节			32位			

float		 4字节			

double	 8字节

```c
//显示数据类型所占内存字节数
#include<stdio.h>
int main(void)
{
    int len;
    len = sizeof(char);
    printf("sizeof(char) = %d", sizeof(char));
}
```

***

#### 1.1.2、有符号数和无符号数

对于char	short	int	long等整形类型的数，都是有符号有无符号数。

而对于float和double这种浮点型数来说，只有有符号数，没有无符号数。

对于c语言来说，数（也就是变量）是存储在内存中一个个格子里的，储存的时候是用二进制方式存储的。对于有符号数和无符号数来说，存储方式是不同的，列如`int`来说

`unsigned int` 无符号数，32位（字节）都是来存数的内容的，所以表示的数的范围是0 ~ 4294967295（2^32^  - 1）

`signed int`  有符号数，32位最高位表示符号（0表示正数，1表示负数）剩余的31位都是用来存数据的。所以可以用来表示数的范围是  -2147483648（2^32^ ） ~ 2147483647（2^31^  - 1）

==注意==：

​	对于整形和字符型来说，有符号数和无符号数表示的范围是不同的。有符号数在计算机编码第一位是符号位其中需要将输入的是的二进制数除符号位之外进行反码和补码转换，再给计算机看。

例如：char  a=-13  它的二进制源码是1000 1011  其反码是 1111 0100 其补码是1111 0101  最后的补码才是给计算机的结果 而无符号数的源码、反码、补码都是同一个不需要转换。

列如字符型 char，有符号数范围是-128 ~ 127，无符号数范围是0~255

结论：从绝对数值上来说，无符号数所表示的范围更大一些，因为有符号数使用了一个二进制位来表示符号位

​	

#### 1.1.3、整形数和浮点型数存储方式的不同

​	对于float和double这种浮点类型的数，它在内存当中的存储方式和整形数不太一样。所以float和int相比虽然都是4个字节，但是在内存中存储的方式完全不同，所以同一个4字节的内存，如果存储时是按照int存放的，取的时候一定要按照int方式去取，如果存的方式和取的时候理解的方式不同，那数据就完全错了。

```c
#include<stdio.h>
int main(void)
{
    int a;
    a = 123;
    printf("a = %d, a = %f", a, a);//打印结果a = 123,a = -192384
}				//就是因为定义的是int，去按照float去取造成的结果
```

总结：存取方式上，主要有两种，一种是整形一种是浮点型，这两种存取方式完全不同，没有任何关联，所以绝对不能随意改变一个变量的存取方式，在整形和浮点型之外，列如说4种整形char、short、int、long只是范围大小不同，存储方式是一样的。float和double存储原理是相同的，方式上有差异，导致了能表示的浮点型范围和精度不同。

****

### 1.2、空类型（关键字void）

​	C语言中的void类型，代表任意类型，而不是空的意思，任意类型不是说想变成谁就变成谁，而是说它的类型是未知的，是还没指定的。

`void * ` 是一个void类型的指针。void类型的指针含义是：只是个指针变量，该指针指向一个void类型的数就是说这个数有可能是int，也有可能是float，也有可能是结构体，哪种类型都可能，只是当前还不知道。

void型指针的作用就是：程序是不知道那个变量的类型的，但是程序员知道，当时给这个变量赋值的时候是什么类型的，现在取出来就还是什么类型，这些类型对不对，是否兼容，完全由程序员自己负责。编译器看到void没办法做类型检查。

```c
#include<stdio.h>

int main(void)
{
    int a = 144;
    void *pVoid;
    
    pVoid = &a;
    
    printf("*pVoid = %d.\n", *(int *)pVoid);
/*
*由于定义的是void型编译器不知道这个指针类型所以需要加强制类型转换这 *时候就需要程序员自己知道定义的时候是什么类型的变量
*/
    
    printf("*pVoid = %f.\n", *(float *)pVoid);//错误取法
}
```



在函数的参数列表和返回值中，void代表的含义是：

一个函数形参列表为void，表示这个函数调用时不需要传参。

返回值类型是void，表示这个函数不会返回一个有意义的返回值，所以调用者也不要想着去用这个返回值。

```c
#include<stdio.h>
void test(void);

    
int main(void)
{
    int a;
    test();
    return 0;
}
//void类型的参数和返回值，表示不需要
void test(void)
{
    printf("l am a void test.\n");
}
```

C语言设计的基本理念：

​	C语言相信程序员永远是对的，C语言相信程序员都是高手，C语言赋予了程序员最大的权力，所以C语言程序员必须对程序负责，必须脑袋清楚，知道自己在干嘛。

***

### 1.3、数据类型转换

​	C语言中有各种数据类型，写程序时需要定义各种类型的变量。这些变量需要参与计算。C语言中有一个基本要求就是：不同类型的变量是不能直接运算的。

也就是说，int和float类型的变量不能直接加减乘除。你要运算，就必须先把两种类型转成相同类型才行。

#### 1.3.1、隐式转换

隐式转换就是自动转换，是C语言默认会进行的，不用程序员干涉

C语言的理念：隐式类型转换默认向精度更高、范围更大的方向转换。

```c
#include<stdio.h>

int main(void)
{
    int a = 3;
    float b = 3.5;
    c = a + b;//虽然a+b是隐式转换为float型但是赋值时以左值类型为 				//准，所以又被转换为int型了
    printf("a + b = %f", a + b);
    printf("a + b = %d", a + b);//float类型的f2被当中int解析了
     						//错了
    return 0;
}
/*
*程序运行结果：a + b = 6.50000
*逐步分析
*1、编译器发现a+b中两个变量类型不同。这时候两个要加，编译器会进行隐 *式类型转换把两个转换成类型相同。根据的是隐式类型转换的规则，编译器 *构造了一个临时变量（列如叫float f1）然后把f1赋值为a，之后参与运算
*是用临时变量f1去和b进行运算的，加完之后得到一个临时变量（列如叫*float f2），这个临时变量再参与之后的运算。
*题目中printf的是%f所以需要一个float类型的结果，于是乎，f2直接拿去 *打印，结果为6.50000
*
*/
```



#### 1.3.2、强制类型转换

C语言默认不会这么做的，但是程序员自己想这么做，所以其强制这么做的。

***

### 1.3、C语言与bool类型

C语言中原生类型是没有bool类型的，c++里面有，在C语言中如果需要使用bool类型，可以用int类型来代替。

很多代码体系中，用以下宏定义来定义真假：

`#define TRUE 1` 

`#define FALSE 0` 

```c
#include<stdio.h>

int main(void)
{
    int a;
    
    a = -23;
    if(a)		//在bool类型的世界里除了0都是1
    {
        printf("a = %d.\n", a);	//结果可以运行
    }
    return 0;
}
```

***

## 2、变量和常量

### 2.1、变量

变量指的是在程序运行过程中，可以通过代码是他的值改变的量。

#### 2.1.1、局部变量

定义：在函数中的变量，就叫局部变量。

##### 2.1.1.1、普通局部变量（auto）

 ```c
#include<stdio.h>

void func1(void)
{
   (auto) int i = 1;		//普通局部变量 (auto)可加可不加
    i++;
    printf("i = %d.\n", i);
}
 ```

在局部变量中，每次调用func1这个子函数时，都会创建一个新的变量i，并给他赋初值，然后printf打印，然后结束func1函数的同时释放i变量。这就是局部变量i的全部生命周期。

##### 2.1.1.2、静态局部变量（static）

关键字：static

```c
#include<stdio.h>

void func1_static(void);

int main(void)
{
    func1_static();		//i = 2
    func1_static();		//i = 3
    func1_static();		//i = 4
}

void func1_static(void)
{
    static int i = 1;	//静态局部变量
    i++;
    return 0;
}
```

static修饰全局变量时：

​	只能在本文件中进行访问

static修饰局部变量时：

​	1、让局部变量拥有全局变量的特点（生命周期延长，作用域不变）

​	2、静态局部变量只需要初始化一次

​	3、静态局部变量会随着程序结束而结束

static修饰函数时：

​	1、只能够在本文件中访问该函数。

##### 2.1.1.3、跨文件引用全局变量（extern）

​	extern关键字可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。这里起到的是声明作用范围的用处。

##### 2.1.1.4、register关键字

register （寄存器），C语言中的关键字。

`register int i = 3`

总结：register类型的局部变量表现上和auto是一样的，这东西基本没用，register被称为：C语言中最快的变量。C语言的运行时环境承诺，会尽量将register类型的变量放在寄存器中（普通的变量是放到内存上的），所以register类型的变量访问速度会快好的。但是他是有限制的，首先寄存器数目是有限的，所以register类型的变量不能太多，在数据类型上也有限制，一般只在内核和启动代码中，需要反复使用一个变量时才会使用register。

****

#### 2.1.2、全局变量

定义在函数外面的变量，就叫全局变量

全局变量的定义和初始化是在main函数运行之前就发生的。

局部变量和全局变量的对比：

1、定义同时没有初始化则局部变量的值是随机的，而全局变量的值默认为0。

2、使用范围是：全局变量具有文件作用域，而局部变量只有代码块作用域。

3、生命周期：全局变量是在程序开始运行之前的初始化阶段就诞生了，到整个程序结束退出时候才死亡；而局部变量在进入局部变量所在的代码块时诞生，在退出该代码块的时候死亡。

4、 变量的分配位置：全局变量分配在数据段上面，而局部变量分配在栈上面。

判断一个变量能不能使用，有没有定义，需要注意两点：第一、该变量的作用域是否在当前有效，是否包含当前位置。第二、变量必须先定义后使用，所以变量的引用一定要在变量定义之后。

==基本概念==

C语言对内存的管理方式

数据段：数据段存的是数，像全局变量就存在数据段，随程序一样的生命周期

代码段：在的是程序代码，一般是只读的。

栈（stack）：是个用来定义临时变量 先进后出，C语言中局部变量就分配在栈中

##### 2.1.2.1、普通全局变量

​		普通全局变量就是平时使用的，定义前不加修饰词，普通全局变量可以在各个文件中被使用，可以在项目内的别的.c文件中被看到，所以要确保不能重名。

##### 2.1.2.2、静态全局变量

​		静态全局变量就是用来解决不能重名的问题的。静态全局变量定义时在定义前加`static` 关键字，就是告诉编译器这个变量只在本文件内使用，在别的文件中不会被使用。所以静态的全局变量用在我定义的这个变量并不是给别人使用的而是就是给我本人自己使用的。

##### 2.1.2.3、跨文件全局变量（extern）

​		就是说，你在一个程序的多个.c源文件中，可以在一个.c文件中定义全局变量g_a，并且可以在别的.c文件中引用该变量g_c（前提是你要声明）

函数和全局变量在C语言中可以快文件引用，也就是说他们的连接范围是全局的，具有文件属性，总之就是说全局变量和函数可以跨文件看到，但是定义时不能重名。

****

### 2.2、常量

​		常量，在程序运行过程中不会改变的量。常量在程序运行之前初始化的时候给定过一次，以后都不会变了，一直时这个值。

#### 2.2.1、#define定义的常量

​		`#denfine N 20` 				//符号常量 	

#### 2.2.2、const关键字

`const int i = 4;`   定义一个变量将它变为常量。它所修饰的全局变量在常量区（.ro）修饰的局部变量在栈区

```c
#include<stdio.h>

int main(void)
{
    const int i = 10;//当你在一个变量前面加const后这个变量就变成了                     //常量无法更改了
    i = 20;			//这个赋值就是错误的了
    
}
```

它所修饰的全局变量在常量区（.ro）修饰的局部变量在栈区

```c
#include<stdio.h>

void fun(void)
{
    const int a = 10;		//结果 a = 20 *p = 20 说明const修饰的局							部变量是可以被改变的，其位置存放在栈区
    int *p = &a;
    *p = 20;
    printf("a = %d, *p = %d", a, *p);
}
```



const和指针结合，共有4种方法：

`const int *p;` p是个指针指向一个int型的数据，p所指向的那个数是常量。

`int const *p;`  p是个指针指向一个int型的数据，p所指向的那个数是常量。

`int *const p;`  p是个指针指向一个int型的数据，p本身是个常量，p所指向的							量是个变量

`const int * const p;`  p是个指针指向一个int型的数据，p本身是常量，指向										的也是常量

结论和记忆方法：

​		1、const在* 号前面，就表示const作用与p所指向的那个量，所以这时候p所指向的是个常量。

​		2、const在* 号后面，就表示p本身是常量，但是p所指向的不一定是常量。

const型的指针用法

`char *strcpy(cahr *dst,  const cahr *src);` 

字符串处理函数strcpy，它的函数功能是将src指向的字符串，拷贝到dst中。

为防止传递时src里的数据被该将这个src所指向的数据变为常量 。

#### 2.2.3 枚举常量

​		枚举常量时宏定义的替代品，在某些情况下会比宏定义好用。

关键字：enum



*****

## 3、多文件C语言程序

### 3.1、简单的C语言程序

​	简单的C语言程序（项目）只有一个.c文件，编译的时候gcc a.c -o a，执行时候`./a` 

### 3.2、复杂的C语言程序

​	复杂的C语言程序是由多次.c文件构成的。列如一个项目中有两个.c文件（a.c  b.c），编译时gcc a.c b.c -o ab，执行的时候`./ab` 

实验：

​	在a.c和b.c中分别定义main函数，各自编译没有问题，但是两个文件作为一个项目来编译的时候就会报错。原因是，因为a.c和b.c这时候组成一个程序，只能由一个main函数

### 3.3、需要多文件的原因

​	因为真正的C语言项目是很复杂的，包含很多函数，写在一个文件里不利于查找、组织、识别，所以人为的将负载项目中的很多函数，分成了一个个功能模块，然后分开放在不同的.c文件下面，于是乎就有了多文件项目。

所以在b.c中定义的一个函数很可能在a.c 中需要被调用，你在任何一个文件中定义的任何一个函数，都有可能被别的文件调用，但是大家最终都是被main函数调用的。这个调用有可能是直接也有可能是间接。

### 3.4、跨文件调用函数

​	在调用函数前，要声明该被定义函数的原型。

总结：函数使用的三大要素：函数定义、函数声明、函数使用

1、如果没有定义，只有声明和调用，编译就会报错

2、如果没有声明，只有定义和调用，编译时一般会报警告，极少数情况下不会，最好还是加上

3、如果没有调用，只有定义和声明，编译时一般会报警告（有一个函数没使用），有时不会报，程序执行也没错，只是你写的函数没有用到而已

在一个项目中不管是一个文件内还是该程序的多个文件中都不能出现重名的函数。编译器在调用函数时是根据文件名来识别的。

### 3.5、跨文件的全局变量引用

（1）实验可知，在a.c中定义的全局变量在b.c中无法之间访问。

（2）想在b.c中使用a.c中的全局变量，有一个间接的方法，在a.c中写一个函数，然后在该函数中引用全局变量，然后在b.c中间接引用a.c中的那个函数。

（3）想在b.c中使用a.c中的全局变量g_a，则需要在b.c中引用前声明g_a，如何声明：`extern int g_a;` 

关键字：extern（外部的）

`extern int g_a;` 这句话就是全局变量g_a的声明，这句话告诉编译器，我在外部（程序中但不在本文件的另一个文件）定义了一个全局变量g_a，我现在需要引用他，告诉编译器。

==问题==：

​	1、如果只在b.c中声明了一个全局变量但是没有定义，这是不行的，编译器会报错。

​	2、只在a.c中定义了一个全局变量，但是在b.c中直接引用也是不行的，必须得提前声明

​	3、在a.c中定义，在b.c中声明但是没引用，是没问题得。

​	4、局部变量不能跨文件使用，因为局部变量属于代码块作用域，他的作用域只有它定义的那个函数内部。

​	5、静态局部变量也不能跨文件使用，因为他本质上还是个局部变量。

谈论跨文件使用问题时，只需要讨论全局变量和函数就好了。

C语言中，定义函数必须在外面，不能在一个函数里面定义别的函数，所以没有局部函数这个东西。

结论：不管是函数还是变量，都得有定义、声明、引用三要素。其中定义是创造了这个函数或者变量，声明是向编译器交代他的原型，引用是使用这个变量或者函数，所以只有声明和引用编译器一定会报错。

在一个程序中，一个函数只能被定义一次，引用和声明都可以无数次。因为函数得定义和全局变量得定义实际上是创造这个函数/变量，所以只能定义一次。

### 3.6、头文件的引用

#### 3.6.1、头文件的作用

​		从之前讲的内容中可以看到，函数的声明是很重要的。当我们在一个很庞大的项目中，有很多个源文件，每个源文件中都有很多函数，并且需要各个文件中相互穿插引用函数。

怎么解决函数声明问题就是靠头文件里面。

```c
//模拟a.h头文件
#ifndef __A_H__
#define __A_H__

int add(int a, int b);
int sub(int a, int b);//不要在头文件中定义变量

#endif 
```

```c
//模拟a.c源文件

#include<stdio.h>
#include"a.h"		//在这里声明包含头文件
//在没有头文件时需要使用别的文件中的定义的函数时，都要在本文件中声明
//int add(int a, int b);
//int sub(int a, int b);

int main(void)
{
    int a = 23, b = 43;
    printf("a + b = %d",add(a,b));
}
```

```c
//模拟b.c源文件


int add(int a, int b)
{
    return a+b;
}

int sub(int a, int b)
{
    return a-b;
}
```



#### 3.6.2、#include 包含头文件时<>和“”的区别

​		<>用来包含系统自带的头文件，系统自带的指的是不是你写的，是编译器或者库函数或者操作系统提供的头文件。		

​		“”用来包含项目目录中所包含的头文件，这些一般都是我们自己写的。

#### 3.6.3、防止重复包含

`#ifndef __A_H__`
`#define __A_H__` 

//C语言头文件中的声明

`endif`  

写程序时最好不要在头文件中定义变量，因为这时该头文件被多个源文件包含时，就会出现重复定义问题，变量的定义就应该放在某个源文件中，在别的源文件中使用前extern声明。